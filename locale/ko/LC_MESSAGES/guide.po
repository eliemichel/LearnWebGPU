# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2023, Ã‰lie Michel and contributors
# This file is distributed under the same license as the Learn WebGPU for
# C++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Learn WebGPU for C++ \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-25 09:45+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ko\n"
"Language-Team: ko <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../advanced-techniques/benchmarking/environmental-impact.md:1
msgid "Environmental Impact (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:4
msgid ""
"It is important to be able to asses, at least roughly, the environmental "
"impact of an application, if we want to be able to compare with other "
"(potentially non-software based) solution to the problem they address."
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:6
msgid ""
"GPU-intensive application have an environmental impact through multiple "
"expenses, for instance:"
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:8
msgid ""
"The impact of the energy expense while using the application depends on "
"how long computation run, how long the user uses intensive computations "
"in a typical workflow, how intense the computation is."
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:10
msgid ""
"The choice of minimal required limits impacts the need to manufacture new"
" hardware."
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:12
msgid ""
"Tools for measuring **instant energy** expense depend a lot on the "
"platform. For instance NVidia provides information through the [NVML "
"library](https://developer.nvidia.com/nvidia-management-library-nvml)."
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:14
msgid ""
"The **carbon impact** of this energy depends on the user's location. "
"Several APIs exist to query this information, like "
"[WattTime](https://www.watttime.org/api-documentation)."
msgstr ""

#: ../../advanced-techniques/benchmarking/environmental-impact.md:16
msgid ""
"The **manufacturing impact** is harder to evaluate, especially for non-"
"carbon related, which includes notably the challenging extraction of "
"**rare metals**, which are non-renewable."
msgstr ""

#: ../../advanced-techniques/benchmarking/index.md:1
msgid "Benchmarking"
msgstr ""

#: ../../advanced-techniques/benchmarking/index.md:4
msgid ""
"Benchmarking consists in measuring the **resources** needed for different"
" tasks, in order for instance to identify **performance bottlenecks** or "
"to compare two approaches to the same problem."
msgstr ""

#: ../../advanced-techniques/benchmarking/index.md:6
#: ../../advanced-techniques/index.md:4
#: ../../appendices/custom-extensions/index.md:10 ../../appendices/index.md:5
#: ../../basic-3d-rendering/3d-meshes/index.md:4
#: ../../basic-3d-rendering/index.md:4
#: ../../basic-3d-rendering/input-geometry/index.md:4
#: ../../basic-3d-rendering/lighting-and-material/index.md:4
#: ../../basic-3d-rendering/shader-uniforms/index.md:4
#: ../../basic-3d-rendering/some-interaction/index.md:4
#: ../../basic-3d-rendering/texturing/index.md:4
#: ../../basic-compute/image-processing/index.md:4
#: ../../basic-compute/index.md:4
#: ../../basic-compute/procedural-geometry/index.md:4
#: ../../getting-started/index.md:4 ../../index.md:8
msgid "Contents"
msgstr ""

#: ../../advanced-techniques/benchmarking/memory.md:1
msgid "Memory (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/benchmarking/processing-units.md:1
msgid "Processing Units (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:1
msgid "Time"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:5
#: ../../advanced-techniques/benchmarking/time.md:697
msgid ""
"*Resulting code:* [`step095-timestamp-"
"queries`](https://github.com/eliemichel/LearnWebGPU-Code/tree/step095"
"-timestamp-queries)"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:9
#: ../../advanced-techniques/benchmarking/time.md:701
msgid ""
"*Resulting code:* [`step095-timestamp-queries-"
"vanilla`](https://github.com/eliemichel/LearnWebGPU-Code/tree/step095"
"-timestamp-queries-vanilla)"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:12
msgid ""
"We start by **measuring compute time**, which is often the most valuable "
"resource."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:15
msgid ""
"As of September 6, 2023, wgpu-native does not support timestamp queries "
"yet. I suggest you follow this chapter with Dawn only for now."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:18
msgid "Asynchronicity"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:21
msgid ""
"Importantly, measuring GPU time is **quite different** from measuring CPU"
" time, because as you may recall **we only interact with the GPU through "
"remote calls** issued in our CPU code (C++)."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:23
msgid "In an imperative CPU code, measuring time looks like this:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:33
msgid ""
"But when doing this on the GPU, we only **submit** operations that run on"
" a **different timeline**:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:43
msgid ""
"The \"something\" may not even have started at this point. What we "
"measure is the time it takes to submit instructions, **not to actually "
"execute them**!"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:45
msgid "Timestamp Queries"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:48
msgid ""
"We must instruct the GPU to run some equivalent of `get_current_time()` "
"on its own timeline. The result of this operation is stored in a "
"dedicated object called a **timestamp query**."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:59
msgid ""
"We must then **fetch** the timestamp values back to the CPU, through a "
"mapped buffer like we see in [Playing with buffers](../../basic-3d-"
"rendering/input-geometry/playing-with-buffers.md#mapping-context)."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:61
msgid "ðŸ«¡ Okey, got it, so what about actual C++ code?"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:63
msgid ""
"Whether they measure timestamps or other things, GPU queries are stored "
"in a `QuerySet`. We typically store both the start and end time in the "
"same set:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:87
msgid ""
"I base this example on [`step095`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step095), from chapter [Simple GUI](../../basic-"
"3d-rendering/some-interaction/simple-gui.md)"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:91
msgid ""
"I created a `initBenchmark()` method (called in `onInit`) to initialize "
"benchmark-related objects like the query set. I also created a "
"`terminateBenchmark()` to release these resources."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:94
msgid ""
"However, if you try to add the code block above to your application, you "
"will face an error:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:96
msgid ""
"**Device error:** *(Dawn)* Timestamp queries are disallowed because they "
"may expose precise timing information. *(wgpu-native)* "
"Features(TIMESTAMP_QUERY) are required but not enabled on the device."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:100
msgid "Enabling Timestamp Feature"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:103
msgid "Dawn toggles"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:105
msgid ""
"Let us start with Dawn: for **privacy reasons**, Dawn disables timing "
"information. This is relevant when running on the Web, but not in our "
"native application context. Fortunately, **this safeguard can easily be "
"disabled**."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:107
msgid ""
"Dawn has a list of so-called \"toggles\" that can be turned on or off at "
"the scale of the whole WebGPU instance: the list is available in "
"[`Toggles.cpp`](https://dawn.googlesource.com/dawn/+/refs/heads/main/src/dawn/native/Toggles.cpp#33)."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:109
msgid ""
"To enable toggles, we use the Dawn-specific `DawnTogglesDescriptor` "
"**extension**, which can be chained to the instance descriptor:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:139
msgid "We then specify that we want to enable the `allow_unsafe_apis` feature:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:180
msgid ""
"The toggles descriptor can also be used as an extension of the adapter or"
" device request options. In that case, device toggles supersede adapter "
"toggles, which supersede instance toggles."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:183
msgid "The error message we get is now slightly different:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:185
msgid ""
"**Device error:** *(Dawn)* Timestamp query set created without the "
"feature being enabled."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:188
msgid ""
"This is in substance the same error than the one reported by `wgpu-"
"native` above, we treat both in the next section."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:190
msgid "Feature request"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:192
msgid ""
"When creating our WebGPU device, we mentioned already that we can set up "
"specific limits. But we can also **request specific features** from the "
"`WGPUFeatureName` enum. In particular, we need to enable "
"`FeatureName::TimestampQuery`."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:214
msgid ""
"The error messages should now be fixed! You may also want to check that "
"the adapter, and then the device, support this feature:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:243
msgid ""
"Timestamp queries are specified as an explicit feature because some "
"devices/adapters may not support them."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:246
msgid "Writing timestamps"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:249
msgid ""
"There are different ways of writing timestamp into queries. The closest "
"one to our pseudocode above is `commandEncoder.writeTimestamp()`, which "
"writes the GPU-side time into a query whenever the command is executed in"
" the **GPU timeline**."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:251
msgid ""
"If you want more specifically to measure the time taken by **a render or "
"compute pass**, you can also pass timestamp queries to the passes "
"descriptor:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:288
msgid ""
"I initialize the query set only once and store it into an attribute "
"`m_timestampQueries` of the `Application` class."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:291
msgid "Reading timestamps"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:294
msgid "Resolving timestamps"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:296
msgid ""
"Okey, the render pass writes to our first query when it begins, and "
"writes to the second query when it ends. We only need to compute the "
"difference now, right? But the timestamps still **live in the GPU "
"memory**, so we first need to **fetch them back** to the CPU."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:298
msgid ""
"The first step consists in **resolving** the query. This gets the "
"timestamp values from whatever internal representation the WebGPU "
"implementation uses to store query set and write them in a **GPU "
"buffer**."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:331
msgid ""
"And as you noticed we need to create a dedicated buffer "
"`m_timestampResolveBuffer` with the `QueryResolve` usage. This buffers "
"needs to reserve a **64-bit unsigned integer** per timestamp:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:373
msgid ""
"One the Web, the timestamp resolution may include rounding the value, to "
"avoid giving access to precise information that could lead to timing "
"attacks."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:376
msgid ""
"We can call `resolveTimestamps` in our main loop, after "
"`renderPass.end()` and before `encoder.finish()`:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:396
msgid ""
"At this stage, if we only process the timestamps on the GPU, this is all "
"we need. We can for instance provide them as uniforms in a shader."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:398
msgid "Fetching timestamps"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:400
msgid ""
"But usually we need to read timestamps on the CPU (for instance to "
"display them with ImGui)."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:402
msgid ""
"We cannot directly map the resolve buffer, because buffers that have the "
"`MapRead` usage can only be used for mapping. We thus create another "
"buffer, namely the `m_timestampMapBuffer`:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:444
msgid "We then copy to this buffer right after resolution:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:477
msgid ""
"And finally we map this buffer. But we must take care of doing this "
"**after the encoder has been submitted**, because it is not allowed to "
"copy to a buffer while it is being mapped. We thus create a new "
"`fetchTimestamps()` method, called after `queue.submit()`:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:499
msgid ""
"Also, remember that **buffer mapping is asynchronous**, so we must be "
"careful when this `fetchTimestamps()` function is called at each frame."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:502
msgid ""
"This part differs slightly in architecture depending on whether you are "
"using the C++ wrapper or the vanilla API, I invite you to pick the right "
"tab below:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:506
#: ../../advanced-techniques/benchmarking/time.md:558
msgid ""
"Overall the mapping operation looks like what we did in the [Playing with"
" buffers](../../basic-3d-rendering/input-geometry/playing-with-"
"buffers.md) chapter:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:523
msgid ""
"However to ensure that the callback **outlives the scope** in which it is"
" defined here, we must maintain its handle in the `Application` class:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:533
msgid ""
"Lastly, we **do not want to trigger a new mapping operation** if there is"
" already one going on! To check this, we may simply use the handle and "
"**return early** whenever it is not null:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:553
msgid "TODO:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:554
msgid "Define a static method to be used as callback"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:555
msgid "Add a boolean to check whether there is an ongoing mapping operation"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:586
msgid ""
"However, we **do not want to trigger a new mapping operation** if there "
"is already one going on! To check this, we add a simple boolean attribute"
" and **return early** whenever a mapping operation is already in flight:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:610
msgid ""
"Thanks to this, we can now safely call `fetchTimestamps()` at each frame,"
" right after submitting the command buffer."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:612
msgid "Using timestamp values"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:615
msgid "Display"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:617
msgid ""
"We can finally manipulate timestamp values on the CPU! At first we can "
"**display them** in the terminal: in the map callback, when mapping was "
"successful:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:628
msgid "You get in the end a little less than 1 log line per frame:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:645
msgid "Statistics"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:647
msgid ""
"Usually, I am not interested in one line per frame, but rather in showing"
" in the UI the **mean** and **standard deviation** of my measure. I use "
"for this my "
"[`TinyTimer.h`](https://gist.github.com/eliemichel/54912bdafb8d16b21b0e7d9fce73a845):"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:670
msgid "Our GPU timer displayed in the application."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:674
msgid ""
"In this example, we can see that the render pass takes much less time "
"than a frame. This is because the limiting factor here is the **VSync** "
"that caps the number of frames per second to 60 (the maximum refresh rate"
" of my display)."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:678
msgid ""
"When reporting and comparing benchmark values, and statistics in general,"
" it is important to look at the **standard deviation**, but also at the "
"**number of samples** on which this standard value is estimated."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:681
#: ../../advanced-techniques/hdr-textures.md:197
#: ../../advanced-techniques/raii.md:225
#: ../../appendices/building-for-the-web.md:312
#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:227
#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:343
#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:341
#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:224
#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:697
#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:415
#: ../../basic-3d-rendering/hello-triangle.md:477
#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:376
#: ../../basic-3d-rendering/input-geometry/index-buffer.md:187
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:481
#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:344
#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:329
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:204
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:110
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:456
#: ../../basic-3d-rendering/lighting-and-material/pbr.md:66
#: ../../basic-3d-rendering/lighting-and-material/specular.md:302
#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:258
#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:246
#: ../../basic-3d-rendering/some-interaction/camera-control.md:266
#: ../../basic-3d-rendering/some-interaction/lighting-control.md:382
#: ../../basic-3d-rendering/some-interaction/refactoring.md:268
#: ../../basic-3d-rendering/some-interaction/resizing-window.md:202
#: ../../basic-3d-rendering/some-interaction/simple-gui.md:256
#: ../../basic-3d-rendering/texturing/a-first-texture.md:477
#: ../../basic-3d-rendering/texturing/loading-from-file.md:516
#: ../../basic-3d-rendering/texturing/sampler.md:578
#: ../../basic-3d-rendering/texturing/texture-mapping.md:201
#: ../../basic-compute/compute-pipeline.md:516
#: ../../basic-compute/image-processing/convolution-filters.md:300
#: ../../basic-compute/image-processing/cubemap-conversion.md:111
#: ../../basic-compute/image-processing/cubemap-prefiltering.md:198
#: ../../basic-compute/image-processing/mipmap-generation.md:491
#: ../../getting-started/first-color.md:264
#: ../../getting-started/hello-webgpu.md:263
#: ../../getting-started/the-adapter.md:374
#: ../../getting-started/the-command-queue.md:183
msgid "Conclusion"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:684
msgid ""
"You are now able to use precise GPU-side timers, which is essential to "
"evaluate the performances of your application and identify the "
"bottlenecks. Remember that:"
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:686
msgid "GPU timers don't live on the same **timeline** as CPU timers."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:687
msgid ""
"You need to create timestamp queries, then **write** to them, **resolve**"
" them, and finally **fetch** them back asynchronously."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:688
msgid ""
"You must pay attention not to fetch before the resolve/copy operations "
"are not only encoded by **submitted** to the GPU."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:690
msgid ""
"I would suggest to create a little class responsible solely for managing "
"the timers in your application, so that the boilerplate is isolated to "
"your application's logic."
msgstr ""

#: ../../advanced-techniques/benchmarking/time.md:693
msgid ""
"If you want to measure performances for events that do **not happen at "
"each frame**, you should keep for each such counter a **boolean** telling"
" whether the counter has been updated, so that you `add_sample` upon "
"fetch callback only when the timestamps were **actually updated**."
msgstr ""

#: ../../advanced-techniques/deferred-shading.md:1
msgid "Deferred Shading (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:1
msgid "High Dynamic Range Textures (ðŸš§WIP)"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:5
#: ../../advanced-techniques/hdr-textures.md:201
msgid ""
"*Resulting code:* [`step120`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step120)"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:9
#: ../../advanced-techniques/hdr-textures.md:205
msgid ""
"*Resulting code:* [`step120-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step120-vanilla)"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:12
msgid ""
"*(NB: This used to be placed right after [Image-Based Lighting](../basic-"
"3d-rendering/lighting-and-material/ibl.md))*"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:14
msgid "High Dynamic Range"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:17
msgid "Load [`autumn_park_4k.exr`](../data/autumn_park_4k.exr):"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:23
msgid ""
"Since stb_image, the library we use to load PNGs, does not know EXR file,"
" we use [tinyexr](https://github.com/syoyo/tinyexr), which is integrated "
"in a similar spirit to our other dependencies."
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:25
msgid ""
"Download "
"[`tinyexr.h`](https://github.com/syoyo/tinyexr/raw/02310c77e5156c36fedf6cf810c4071e3f83906f/tinyexr.h),"
" "
"[`miniz.c`](https://raw.githubusercontent.com/syoyo/tinyexr/02310c77e5156c36fedf6cf810c4071e3f83906f/deps/miniz/miniz.c)"
" and "
"[`miniz.h`](https://raw.githubusercontent.com/syoyo/tinyexr/02310c77e5156c36fedf6cf810c4071e3f83906f/deps/miniz/miniz.h)"
" into your source tree and add the following to `implementations.cpp`:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:32
msgid ""
"Also add `miniz.c` and (optionally) `miniz.h`/`tinyexr.h` to the "
"CMakeLists:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:43
msgid "We also need some more tuning to our CMakeLists:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:55
msgid ""
"In the resource manager, we create a copy of `loadTexture` called "
"`loadExrTexture` where we use TinyEXR instead of stb_image and load data "
"as float rather than 8-bit integers, which affects the creation of "
"mipmaps:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:110
msgid ""
"Note that in order to avoid duplicating the mip-map creation part, I "
"isolated this templated utility function:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:177
msgid ""
"All there is to do now is call in `initTexture` one or the other of these"
" loading functions depending on the file extension:"
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:192
msgid ""
"The [texture format capabilities table](https://www.w3.org/TR/webgpu"
"/#texture-format-caps) shows that in order to allow filtering for float32"
" textures, we need to enable the `float32-filterable` **feature** when "
"creating the device."
msgstr ""

#: ../../advanced-techniques/hdr-textures.md:195
msgid ""
"We use [`float16_t.hpp`](../data/float16_t.hpp) because C++ does not have"
" a 16-bit float type out of the box."
msgstr ""

#: ../../advanced-techniques/headless.md:1
msgid "Headless context"
msgstr ""

#: ../../advanced-techniques/headless.md:5
#: ../../advanced-techniques/headless.md:304
msgid ""
"*Resulting code:* [`step030-headless`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step030-headless)"
msgstr ""

#: ../../advanced-techniques/headless.md:9
#: ../../advanced-techniques/headless.md:308
msgid ""
"*Resulting code:* [`step030-headless-"
"vanilla`](https://github.com/eliemichel/LearnWebGPU-Code/tree/step030"
"-headless-vanilla)"
msgstr ""

#: ../../advanced-techniques/headless.md:12
msgid ""
"Sometimes, one needs to use the GPU **without opening a window** at all. "
"This is quite easy to do with WebGPU!"
msgstr ""

#: ../../advanced-techniques/headless.md:15
msgid ""
"The code of this chapter is based on the "
"[`step030`](https://github.com/eliemichel/LearnWebGPU-Code/tree/step030) "
"from [Hello Triangle](../basic-3d-rendering/hello-triangle.md)."
msgstr ""

#: ../../advanced-techniques/headless.md:18
msgid ""
"In our *Hello Triangle* code, WebGPU interacts with the window in only "
"two places:"
msgstr ""

#: ../../advanced-techniques/headless.md:20
msgid "When creating the adapter."
msgstr ""

#: ../../advanced-techniques/headless.md:21
msgid "When setting up the swap chain."
msgstr ""

#: ../../advanced-techniques/headless.md:23
msgid "Adapter creation"
msgstr ""

#: ../../advanced-techniques/headless.md:26
msgid ""
"Our first change consists in replacing the `compatibleSurface` of the "
"adapter options to `nullptr`:"
msgstr ""

#: ../../advanced-techniques/headless.md:47
#: ../../getting-started/first-color.md:21
msgid "Swap Chain"
msgstr ""

#: ../../advanced-techniques/headless.md:50
msgid ""
"The swap chain is a mechanism meant to seamlessly display rendered images"
" on the window. When we no longer have a window... we simply **no longer "
"need a swap chain**!"
msgstr ""

#: ../../advanced-techniques/headless.md:76
msgid ""
"In the main render loop (which may not be a loop in a headless use case "
"by the way) we need to **manage the target texture view** ourselves "
"instead of using `swapChain.getCurrentTextureView()`."
msgstr ""

#: ../../advanced-techniques/headless.md:92
msgid "Target texture"
msgstr ""

#: ../../advanced-techniques/headless.md:94
msgid ""
"We now create the texture to render into, for instance where we used to "
"create the swap chain. See chapter [A first texture](../basic-3d-"
"rendering/texturing/a-first-texture.md) for more details about the "
"texture creation."
msgstr ""

#: ../../advanced-techniques/headless.md:143
msgid ""
"The `nextTexture` of the main loop is now simply a view of the target "
"texture."
msgstr ""

#: ../../advanced-techniques/headless.md:187
msgid ""
"Depending on your use case you could have **more advanced target texture "
"management**, with for instance multiple textures that you swap so that "
"you can render the next frame while saving the previous one on disc for "
"instance."
msgstr ""

#: ../../advanced-techniques/headless.md:190
msgid ""
"Since we reuse the same view from one frame to another one, **do not "
"release it**!:"
msgstr ""

#: ../../advanced-techniques/headless.md:206
msgid "Saving frames"
msgstr ""

#: ../../advanced-techniques/headless.md:208
msgid "We no longer need to *present* the swap chain:"
msgstr ""

#: ../../advanced-techniques/headless.md:215
msgid ""
"But this means nothing is done with the rendered texture! In order to see"
" it, we can use the `saveImage` function provided in the [Screen capture"
"](screen-capture.md) chapter."
msgstr ""

#: ../../advanced-techniques/headless.md:217
msgid ""
"With the files [save_image.h](../data/save_image.h) and "
"[stb_image_write.h](../data/stb_image_write.h) saved next to your "
"`main.cpp`, **replace the swap chain presentation** with the following:"
msgstr ""

#: ../../advanced-techniques/headless.md:224
msgid "Also include the save_image.h file at the beginning of your main file:"
msgstr ""

#: ../../advanced-techniques/headless.md:231
msgid "Main Loop"
msgstr ""

#: ../../advanced-techniques/headless.md:234
msgid ""
"The main loop consisted in rendering a new frame until the window gets "
"closed:"
msgstr ""

#: ../../advanced-techniques/headless.md:244
msgid ""
"What this becomes totally depends on your use case. For the sake of this "
"example, we will just keep the brackets but actually run its content "
"**only once** then terminate the program:"
msgstr ""

#: ../../advanced-techniques/headless.md:253
msgid "Clean-up"
msgstr ""

#: ../../advanced-techniques/headless.md:256
msgid ""
"If you run the program now, it should already create a `output.png` file "
"(in the `build` directory)! You may finally remove all the unused parts "
"and get rid of GLFW altogether:"
msgstr ""

#: ../../advanced-techniques/headless.md:290
msgid ""
"You may also remove the directories `glfw` and `glfw3webgpu` and remove "
"them from the `CMakeLists.txt`:"
msgstr ""

#: ../../advanced-techniques/index.md:1
msgid "Advanced Techniques"
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:1
msgid "Instanced Drawing (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:4
msgid ""
"Drawing the **same geometry multiple times** is very common. It happens "
"when **scattering objects** like rocks or trees on a terrain, when "
"drawing **particle systems**, etc."
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:6
msgid ""
"Turns out that the GPU is particularly good at drawing such repeated "
"geometry thanks to the mechanism of **instancing**."
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:9
msgid ""
"It is much **more efficient** than issuing multiple draw calls, not only "
"because it avoids repeating the **overhead of building a draw command**, "
"but also because it enables the GPU to better **manage memory** by "
"streaming the instances through the rendering pipeline simultaneously."
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:12
msgid ""
"Both the `draw` and `drawIndexed` methods of a render pipeline encoder "
"support instancing (`wgpuRenderPipelineEncoderDraw` and "
"`wgpuRenderPipelineEncoderDrawIndexed`) through their second argument."
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:18
msgid ""
"But as you will quickly notice if changing this instance count argument, "
"all instances get drawn at the **very same position**!"
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:20
msgid ""
"A first solution to distinguish instances is in the shader, using the "
"`@builtin(instance_id)` attribute in the vertex shader inputs."
msgstr ""

#: ../../advanced-techniques/instanced-drawing.md:26
msgid "A second solution is to use instance-level vertex attributes. TODO"
msgstr ""

#: ../../advanced-techniques/multi-sampling.md:1
msgid "Multi-Sampling (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/raii.md:1
msgid "RAII"
msgstr ""

#: ../../advanced-techniques/raii.md:4 ../../advanced-techniques/raii.md:230
msgid ""
"*Resulting code:* "
"[`gist`](https://gist.github.com/eliemichel/2e154152f981e3f16827ba4d17d1123a)"
msgstr ""

#: ../../advanced-techniques/raii.md:6
msgid ""
"Ever tired of managing the `foo.release()` to make sure that it matches "
"the `device.createFoo()` and that you don't have dangling resources? This"
" **manual mechanism** is required for a C API, but in C++ we can **wrap**"
" it into a more convenient interface thanks to **destructors**."
msgstr ""

#: ../../advanced-techniques/raii.md:8
msgid ""
"The **programming idiom** presented here is called "
"[RAII](https://en.cppreference.com/w/cpp/language/raii), which stands for"
" *\"Resource Acquisition Is Initialization\"*; it applies to many other "
"non-WebGPU related contexts!"
msgstr ""

#: ../../advanced-techniques/raii.md:10
msgid ""
"The idea is to write a C++ class that we force **by construction** to be "
"such that the underlying resource it represents exists **if and only if**"
" the instance of the class is still alive."
msgstr ""

#: ../../advanced-techniques/raii.md:12
msgid "Motivational examples"
msgstr ""

#: ../../advanced-techniques/raii.md:15
msgid "Function"
msgstr ""

#: ../../advanced-techniques/raii.md:17
msgid ""
"Let us start with some examples, where we assume that we have a class "
"`raii::Buffer` that wraps the `wgpu::Buffer` resource using the RAII "
"idiom."
msgstr ""

#: ../../advanced-techniques/raii.md:31
msgid ""
"Note how there is no need here to call `buffer.release()`: **as soon as "
"the variable goes out of scope** the buffer it wraps is automatically "
"released."
msgstr ""

#: ../../advanced-techniques/raii.md:33
msgid "Class"
msgstr ""

#: ../../advanced-techniques/raii.md:35
msgid ""
"If we need the buffer to live longer, we can typically define it as a "
"class member:"
msgstr ""

#: ../../advanced-techniques/raii.md:58
msgid ""
"This time, the buffer is released whenever the instance of `Foo` is "
"destructed: it automatically calls the destructor of `raii::Buffer`, "
"which releases the buffer resource."
msgstr ""

#: ../../advanced-techniques/raii.md:61
msgid ""
"Since the `raii::Buffer` cannot exist without an underlying buffer, so it"
" must be initialized by the constructor."
msgstr ""

#: ../../advanced-techniques/raii.md:64
msgid "Smart pointers"
msgstr ""

#: ../../advanced-techniques/raii.md:66
msgid ""
"Sometimes we really want to be able to store a \"null\" buffer, so the "
"need to initialize it as soon as we define the RAII instance can be "
"annoying. The typical solution is to use the **smart pointers** provided "
"by the standard library:"
msgstr ""

#: ../../advanced-techniques/raii.md:94
msgid ""
"The smart pointer ensures that the object it points to is destructed when"
" nothing points to it (e.g., when `Foo` gets destructed)."
msgstr ""

#: ../../advanced-techniques/raii.md:97
msgid ""
"The standard type "
"[`std::optional`](https://en.cppreference.com/w/cpp/utility/optional) can"
" also be an interesting option to store a \"maybe buffer\"."
msgstr ""

#: ../../advanced-techniques/raii.md:100
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:92
#: ../../basic-compute/image-processing/cubemap-conversion.md:35
msgid "Implementation"
msgstr ""

#: ../../advanced-techniques/raii.md:103
msgid ""
"So how do we write this `raii::Buffer` wrapper? It looks easy but there "
"are **some caveats to avoid**!"
msgstr ""

#: ../../advanced-techniques/raii.md:131
msgid "This somehow works... until we meet this kind of scheme:"
msgstr ""

#: ../../advanced-techniques/raii.md:143
msgid ""
"At the end of the `if` block, the variable `buffer2` goes out of scope, "
"so its `m_raw` member is released. Except that it was the same `m_raw` as"
" `buffer1` due to the `=` assignment!"
msgstr ""

#: ../../advanced-techniques/raii.md:145
msgid ""
"This snippet will actually systematically crash with a **double free "
"error** because even if you don't use `buffer1` after the `if`, whenever "
"it gets out of scope on its turn its destructor attempt to release a "
"second time `m_raw`."
msgstr ""

#: ../../advanced-techniques/raii.md:147
msgid "Rule of three"
msgstr ""

#: ../../advanced-techniques/raii.md:149
msgid ""
"There is a general rule of thumb in C++ that accurately applies in our "
"case, namely the [Rule of "
"three](https://en.cppreference.com/w/cpp/language/rule_of_three). It says"
" in short:"
msgstr ""

#: ../../advanced-techniques/raii.md:151
msgid ""
"If a class needs either a user-defined **destructor** (`~Foo()`), a user-"
"defined **copy assignment** operator (`operator=(const Foo& other)` or a "
"user-defined **copy constructor** (`Foo(const Foo& other)`), then it very"
" likely need **the three of them**."
msgstr ""

#: ../../advanced-techniques/raii.md:153
msgid ""
"In our case we obviously need a custom destructor, to release the "
"resource, so the rule tells us that we should also manually define **how "
"to copy RAII buffers**."
msgstr ""

#: ../../advanced-techniques/raii.md:172
msgid "How do we implement these copy operations? We have **three options**:"
msgstr ""

#: ../../advanced-techniques/raii.md:174
msgid ""
"**Option A**: We create a new buffer and copy the content of the previous"
" one."
msgstr ""

#: ../../advanced-techniques/raii.md:175
msgid "**Option B**: We deactivate the possibility to copy buffers."
msgstr ""

#: ../../advanced-techniques/raii.md:176
msgid "**Option C**: We count references."
msgstr ""

#: ../../advanced-techniques/raii.md:178
msgid ""
"The problem of Option A is that it turns a seemingly innocent line of "
"code like `buffer2 = buffer1` into a time and memory consuming operation."
" And it requires the buffer object to hold a reference to the `Device` "
"object that must be used to create the new buffer."
msgstr ""

#: ../../advanced-techniques/raii.md:180
msgid ""
"Option B make things clearer to the user of the API by forcing the use of"
" a more explicit method (e.g., `buffer.copyFrom(device, other)`). In this"
" case we simply delete the copy operator/constructor:"
msgstr ""

#: ../../advanced-techniques/raii.md:188
msgid ""
"Option C consists in using a counter to keep track of how many different "
"RAII instances use the same `m_raw`, so that we release it only when no "
"body else is using it."
msgstr ""

#: ../../advanced-techniques/raii.md:190
msgid ""
"One possibility for this is to implement Option B but then use "
"`std::shared_pointer<raii::Buffer>`, because a shared pointer is "
"precisely a (smart) pointer with a reference counter."
msgstr ""

#: ../../advanced-techniques/raii.md:192
msgid ""
"Another possibility is to use the `buffer.reference()` (or "
"`wgpuBufferReference`) procedure to increase an internal counter on the "
"WebGPU backend side."
msgstr ""

#: ../../advanced-techniques/raii.md:194
msgid "Rule of five"
msgstr ""

#: ../../advanced-techniques/raii.md:196
msgid ""
"Defining custom copy operator/constructor deactivates the automatic "
"creation of **move** operator/constructor. A variant of the Rule of "
"three, called the **Rule of five**, states that should also take care of "
"these move semantics."
msgstr ""

#: ../../advanced-techniques/raii.md:198
msgid ""
"These defines what happens when we do, among others, `buffer2 = "
"std::move(buffer1)`, which means that `buffer1` will never be used again."
" It also enables one to create a function that returns a `raii::Buffer` "
"without performing any copy."
msgstr ""

#: ../../advanced-techniques/raii.md:200
msgid ""
"In such a case, we can simply move the value of `m_raw` from `buffer1` to"
" `buffer2`, removing it from `buffer1` so that it can no longer release "
"it."
msgstr ""

#: ../../advanced-techniques/raii.md:222
msgid ""
"We created a way to have a RAII object that points to no underlying "
"resource, but this is done in a way that follows the C++ lifetime "
"semantics so the compiler can be aware of it."
msgstr ""

#: ../../advanced-techniques/raii.md:228
msgid ""
"We have seen how to create a RAII wrapper around a WebGPU buffer, and "
"from this one implementing other classes is straightforward (you could "
"even automate it). And keep this design pattern in mind even for other "
"projects, as it is a very common and powerful idiom!"
msgstr ""

#: ../../advanced-techniques/raytracing.md:1
msgid "Raytracing (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/render-bundles.md:1
msgid "Render Bundles (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/render-bundles.md:4
msgid ""
"A [Render Bundle](https://www.w3.org/TR/webgpu/#gpurenderbundle) is a way"
" to record a series of render passes so that they can be replayed "
"together in a single call."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:1
msgid "Scene tree (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:5
#: ../../advanced-techniques/scene-tree.md:235
msgid ""
"*Resulting code:* [`step100-gltf`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step100-gltf)"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:9
#: ../../advanced-techniques/scene-tree.md:239
msgid ""
"*Resulting code:* [`step100-gltf-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step100-gltf-vanilla)"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:12
msgid "Multiple objects"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:15
msgid ""
"Before moving on to a whole scene tree, let us start organizing our code "
"to draw **more than a single mesh**."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:17
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:14
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:90
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:95
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:202
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:26
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:75
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:91
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:107
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:299
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:303
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:358
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:407
#: ../../basic-3d-rendering/lighting-and-material/pbr.md:12
#: ../../basic-compute/image-processing/cubemap-conversion.md:38
#: ../../basic-compute/image-processing/cubemap-conversion.md:109
#: ../../basic-compute/image-processing/cubemap-prefiltering.md:16
#: ../../basic-compute/image-processing/cubemap-prefiltering.md:79
#: ../../basic-compute/image-processing/cubemap-prefiltering.md:84
#: ../../basic-compute/image-processing/cubemap-prefiltering.md:196
#: ../../basic-compute/procedural-geometry/deformation.md:46
msgid "TODO"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:19
msgid "Loading GLTF"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:22
msgid ""
"A very common format for representing 3D scenes made of a hierarchy of "
"multiple (potentially animated) objects is "
"[GLTF](https://github.com/KhronosGroup/glTF). In this chapter, we see how"
" to load a GLTF file into our example application."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:24
msgid ""
"We use the popular [TinyGLTF](https://github.com/syoyo/tinygltf) library:"
" it is header-only (thus easy to integrate), well maintained, and relies "
"on dependencies that we are already using for texture loading: "
"`stb_image.h`."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:27
msgid "This chapter is based on `step100`."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:30
msgid ""
"Download "
"[`tiny_gltf.h`](https://github.com/syoyo/tinygltf/blob/release/tiny_gltf.h),"
" [`json.hpp`](https://github.com/syoyo/tinygltf/blob/release/json.hpp) "
"and "
"[`stb_image_write.h`](https://github.com/syoyo/tinygltf/blob/release/stb_image_write.h)"
" (you should already have `stb_image.h`)."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:32
msgid ""
"Similarly to all the tiny libraries that we have been using, add the "
"following to `implementations.cpp` (or any other cpp file as long as it "
"is **only in one** of them)."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:47
msgid ""
"In order to get familiarized with this new loading library, let us do as "
"if it was only loading a single mesh, like our OBJ loading function. "
"Create a new static method in the `ResourceManager` class:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:57
msgid "We start by simply checking that we load the file correctly:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:90
msgid "As an example, we will use the typical Sci-Fi Helmet:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:94
msgid ""
"Download [DamagedHelmet.glb](https://github.com/KhronosGroup/glTF-Sample-"
"Models/raw/master/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb) into "
"your resource directory and try to load it in the application:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:105
msgid ""
"GLTF files can have either the `.gltf` or `.glb` extension. The latter "
"has a 'b' for **binary** and is more compact, but less human-readable. It"
" also embeds all its dependencies, whereas a .gltf"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:108
msgid "Uploading Scene Data"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:111
msgid ""
"Now that we have loaded the GLTF data in its native representation on "
"CPU, we must organize it to fit our render pipeline, and upload all we "
"need to the GPU."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:113
msgid ""
"In order to **avoid unneeded copies** and data processing, we try to let "
"the GLTF scene drive our rendering process. There are however a few "
"points that are driven by the need of our shader:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:115
msgid "The list of **input vertex attributes** that we support and expect."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:117
msgid "Initializing the GPU counterpart of the CPU model data consists in:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:119
msgid ""
"Uploading resources (buffers and images), assuming that they are all "
"needed (otherwise we can eventually add a step to clean up the GLTF "
"data). Create mipmaps for textures (called \"images\" in GLTF "
"terminology)."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:120
msgid "Create samplers (on to one mapping of the concept of mappings in GLTF)"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:121
msgid "Create a Material bind group for each material"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:122
msgid "Create one Node bind group per mesh node"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:123
msgid "Store vertex buffer indices for all mesh primitives"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:125
msgid "WIP Outline:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:126
msgid ""
"Refactor the geometry loading so that we have a Scene and GpuScene "
"object, used for both loading and drawing."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:127
msgid "Switch this to GLFW."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:130
msgid ""
"The existence of a vertex attribute binding must depend on what the "
"shader uses, but the layout itself depends on the GLTF data."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:133
msgid "Debug Renderer"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:135
msgid ""
"We start with a simple debug renderer that draws one frame per node in "
"the scene tree."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:158
msgid ""
"Let us start by what we want to draw. As we said, we want one frame per "
"node in the scene tree:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:178
msgid ""
"We do not use instancing here on purpose. It is true that for drawing the"
" very same geometry at each node like we do here it is a waste not to use"
" instancing, but we will use this simplified example as a base for "
"drawing a different mesh at each node. I will show afterwards how to "
"switch to instancing in this debug renderer."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:181
msgid ""
"Now that we know what we are looking for, let us define our required "
"attributes and initialize them in the `create` method:"
msgstr ""

#: ../../advanced-techniques/scene-tree.md:197
msgid ""
"Note that we keep a reference to the device, in order to use it in "
"various methods. It is also used as a mean to tell that the renderer has "
"been initialized when it is not null."
msgstr ""

#: ../../advanced-techniques/scene-tree.md:215
msgid ""
"We then create init/terminate methods for the various elements of our "
"renderer:"
msgstr ""

#: ../../advanced-techniques/screen-capture.md:1
msgid "Screen capture (ðŸš§WIP)"
msgstr ""

#: ../../advanced-techniques/screen-capture.md:4
msgid "Render screen to file"
msgstr ""

#: ../../advanced-techniques/screen-capture.md:7
msgid ""
"Download [save_image.h](../data/save_image.h) and "
"[stb_image_write.h](../data/stb_image_write.h) next to your `main.cpp`."
msgstr ""

#: ../../advanced-techniques/screen-capture.md:34
msgid "After introducing the `Application` class:"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:1
msgid "Shadow maps (ðŸ›‘TODO)"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:4
msgid "Basic shadow mapping:"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:5
msgid "Render a depth-only view from the point of view of your light"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:6
msgid "Render your scene from the camera as usual"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:7
msgid ""
"In the fragment shader of this draw call, compute the vector going from "
"the light to your fragment, and use it for 2 things: a. Given its "
"direction, determine which pixel it corresponds to in the depth-only view"
" from step 1, fetch the depth for this pixel b. Compare that depth to the"
" length of the fragment-light vector."
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:11
msgid ""
"If the saved depth is smaller, this means there is an obstacle between "
"your fragment and the light, so the fragment is in a shadow. If the saved"
" depth roughly equals the length, fragment is lit. If it is larger, "
"there's sth wrong (or just aliasing going on)"
msgstr ""

#: ../../advanced-techniques/shadow-maps.md:14
msgid ""
"It is easy to go wrong in **3.a.** with the math, I'd advise to double "
"check. Also for **3.b.** be aware that a depth buffer does not directly "
"store a length, you must linearize its value to be able to compare it "
"with the length of a vector."
msgstr ""

#: ../../advanced-techniques/tesselation.md:1
msgid "Tesselation (ðŸ›‘TODO)"
msgstr ""

#: ../../appendices/building-for-the-web.md:1
#: ../../getting-started/hello-webgpu.md:139
msgid "Building for the Web"
msgstr ""

#: ../../appendices/building-for-the-web.md:4
#: ../../appendices/building-for-the-web.md:317
msgid ""
"*Resulting code:* [`step095-emscripten`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step095-emscripten)"
msgstr ""

#: ../../appendices/building-for-the-web.md:6
msgid ""
"Even if this guide focuses on native application development, a nice "
"byproduct of using WebGPU it to be able to compile our code as a Web "
"page."
msgstr ""

#: ../../appendices/building-for-the-web.md:8
msgid ""
"In such a case, we no longer need a distribution (wgpu-native or Dawn), "
"we rather have the compiler map our calls to WebGPU symbols to calls to "
"the actual JavaScript WebGPU API."
msgstr ""

#: ../../appendices/building-for-the-web.md:10
msgid "Build system"
msgstr ""

#: ../../appendices/building-for-the-web.md:13
msgid "Emscripten toolchain"
msgstr ""

#: ../../appendices/building-for-the-web.md:15
msgid ""
"Building C++ code into a web page requires a **specific compiler** that "
"can target **WebAssembly** instead of native binaries. The typical choice"
" is *Emcripten*, and I invite you to **follow the [installation "
"instructions](https://emscripten.org/docs/getting_started/downloads.html)**."
msgstr ""

#: ../../appendices/building-for-the-web.md:17
msgid ""
"Open a terminal and activate `emsdk` (see installation instruction), such"
" that **the command `emcmake` is available** in the `PATH` (you may check"
" with `where emcmake` on Windows `which emcmake` on others)."
msgstr ""

#: ../../appendices/building-for-the-web.md:19
msgid "Configuration"
msgstr ""

#: ../../appendices/building-for-the-web.md:21
msgid ""
"This is a command provided by Emcripten to ease the compilation of CMake-"
"based into WebAssembly. It must simply be used **as a prefix** of the "
"`cmake` configuration call:"
msgstr ""

#: ../../appendices/building-for-the-web.md:30
msgid ""
"Prefixing with `emcmake` is **only needed for the first call** to CMake. "
"Relevant information are then properly stored in the `CMakeCache.txt`, "
"such that you can use CMake as usual afterwards."
msgstr ""

#: ../../appendices/building-for-the-web.md:33
msgid ""
"Note however that it won't correctly run as is, we need to change a few "
"things in the CMakeLists."
msgstr ""

#: ../../appendices/building-for-the-web.md:35
msgid "Dependencies"
msgstr ""

#: ../../appendices/building-for-the-web.md:37
msgid ""
"Emscripten provides its own version of GLFW, because drawing on a Web "
"page is very different from drawing on a native window. We thus tell "
"CMake to include our own `glfw` directory only when **not** using "
"Emscripten:"
msgstr ""

#: ../../appendices/building-for-the-web.md:46
msgid ""
"Other dependencies (`webgpu`, `glfw3webgpu` and `imgui`) are not affected"
" or already handle Emscripten internally."
msgstr ""

#: ../../appendices/building-for-the-web.md:48
msgid ""
"However, in order to have Emscripten use its own GLFW when **linking** "
"the application, we must tell it to use the `-sUSE_GLFW=3` argument. We "
"also use `-sUSE_WEBGPU` to tell the linker that it must **handle WebGPU "
"symbols** (and replace them with calls to the JavaScript API):"
msgstr ""

#: ../../appendices/building-for-the-web.md:63
msgid ""
"The `-sASYNCIFY` option is needed when using `Instance::requestAdapter` "
"or `Instance::requestDevice` in the wrapper. It makes these functions "
"work as **sync** operations while in JavaScript they are async (which "
"would require one to write our whole application in callbacks)."
msgstr ""

#: ../../appendices/building-for-the-web.md:66
msgid ""
"A last change to the `CMakeLists.txt` before we can build: **by default**"
" Emscripten generates a **WebAssembly module**, but not a web page. In "
"order to get a default web page around it, we must change the extension "
"of the `App` target to `.html`:"
msgstr ""

#: ../../appendices/building-for-the-web.md:75
msgid ""
"We see below how to customize the HTML part of this web page (a.k.a. the "
"*shell*)."
msgstr ""

#: ../../appendices/building-for-the-web.md:78
msgid "Build"
msgstr ""

#: ../../appendices/building-for-the-web.md:80
msgid "Building the project is then simply the following, as usual with CMake:"
msgstr ""

#: ../../appendices/building-for-the-web.md:86
msgid "Run"
msgstr ""

#: ../../appendices/building-for-the-web.md:88
msgid ""
"Once the build is ready, it creates an `App.html` page. In order to "
"circumvent browser safety rules, you **must not** open it directly but "
"rather run a **local server**, for instance using Python:"
msgstr ""

#: ../../appendices/building-for-the-web.md:94
msgid ""
"You may now browse to "
"[`http://localhost:8000/App.html`](http://localhost:8000/App.html)! Note "
"that **only Chromium/Google Chrome** has WebGPU support enabled for now."
msgstr ""

#: ../../appendices/building-for-the-web.md:97
msgid ""
"At this stage, the project should build successfully, but the web page "
"**will not run correctly**."
msgstr ""

#: ../../appendices/building-for-the-web.md:100
msgid "Code changes"
msgstr ""

#: ../../appendices/building-for-the-web.md:103
msgid "Get limits"
msgstr ""

#: ../../appendices/building-for-the-web.md:105
msgid ""
"The first error we face (as of September 4, 2023) is a missing feature of"
" Chromium:"
msgstr ""

#: ../../appendices/building-for-the-web.md:111
#, python-format
msgid ""
"No choice here, we must hard-code some values. We only use supported "
"limits for the two \"min\" limits. Turns out that according to "
"[web3dsurvey](https://web3dsurvey.com/webgpu), setting them to 256 "
"enables us to **support 99.95% of users**!"
msgstr ""

#: ../../appendices/building-for-the-web.md:140
msgid ""
"The WebAssembly module may be cached by your browser, so when reloading "
"the page use Ctrl/Cmd+F5 instead of just F5."
msgstr ""

#: ../../appendices/building-for-the-web.md:143
#: ../../basic-compute/compute-pipeline.md:166
msgid "Resources"
msgstr ""

#: ../../appendices/building-for-the-web.md:145
msgid "The next issue we face occurs when trying to create our render pipeline:"
msgstr ""

#: ../../appendices/building-for-the-web.md:151
msgid ""
"If you pay attention to the log lines above, you may see that the shader "
"module is set to a null value: `<wgpu::ShaderModule 0>`. Indeed, the "
"program has **no way to access the shader on your local file system**!"
msgstr ""

#: ../../appendices/building-for-the-web.md:153
msgid ""
"Fortunately there is a way to tell Emscripten **what data to package** "
"together with the WebAssembly module. We thus add a new option to the "
"`target_link_options` line of the CMakeLists:"
msgstr ""

#: ../../appendices/building-for-the-web.md:162
msgid ""
"This makes the content of the `resource` directory available to the Web "
"page."
msgstr ""

#: ../../appendices/building-for-the-web.md:165
msgid ""
"The whole content of the `resource` directory will be downloaded by your "
"end user. Make sure to **only include what is needed** here so that your "
"web page is not too heavy! You may instead enumerate the required files "
"individually."
msgstr ""

#: ../../appendices/building-for-the-web.md:168
msgid "Maximum memory"
msgstr ""

#: ../../appendices/building-for-the-web.md:170
msgid "We are now facing an **out-of-memory** (OOM) error:"
msgstr ""

#: ../../appendices/building-for-the-web.md:176
msgid ""
"As detailed in the error message, a WebAssembly module only gets a "
"**limited amount of memory by default**. We may either increase this "
"default amount, or allow the browser to incrementally allocate more "
"memory as it gets needed. We go for the second option here as we did not "
"settle for a specific use case."
msgstr ""

#: ../../appendices/building-for-the-web.md:178
msgid "Once again, it is solved by an extra linker option:"
msgstr ""

#: ../../appendices/building-for-the-web.md:187
msgid "Main loop"
msgstr ""

#: ../../appendices/building-for-the-web.md:189
msgid ""
"Now the application gets initialized correctly, but after stalling a "
"little bit and displaying a first frame, it fails again:"
msgstr ""

#: ../../appendices/building-for-the-web.md:195
msgid ""
"This actually hides a more general issue of Emscripten-built "
"applications: it is **not possible** to have **an explicit main loop**!"
msgstr ""

#: ../../appendices/building-for-the-web.md:197
msgid ""
"A web application **must not stall** the browser in which it is running, "
"so it cannot just loop forever. Instead in JavaScript one typically uses "
"[`requestAnimationFrame`](https://developer.mozilla.org/en-"
"US/docs/Web/API/window/requestAnimationFrame) to have the browser call "
"**the body** of the main loop at each frame."
msgstr ""

#: ../../appendices/building-for-the-web.md:199
msgid ""
"When building C++ code using Emscripten, the later provides in the "
"[`emscripten/html5.h`](https://emscripten.org/docs/api_reference/html5.h.html)"
" header some utility functions interfacing with the browser's animation "
"frames."
msgstr ""

#: ../../appendices/building-for-the-web.md:201
msgid ""
"We use in particular "
"[`emscripten_set_main_loop_arg`](https://emscripten.org/docs/api_reference/emscripten.h.html#c.emscripten_set_main_loop_arg),"
" which acts like a main loop except **the body** of the loop is given by "
"a **function pointer**:"
msgstr ""

#: ../../appendices/building-for-the-web.md:213
msgid ""
"The type `em_arg_callback_func` is a function pointer taking a `void*` as"
" argument and returning nothing. Like raw WebGPU callbacks, this void "
"pointer is just a **blind forwarding** of the `void *arg` argument, which"
" we can use to pass any data to the body."
msgstr ""

#: ../../appendices/building-for-the-web.md:215
msgid ""
"In our case, we use this `arg` user pointer to pass a pointer to the "
"application:"
msgstr ""

#: ../../appendices/building-for-the-web.md:230
msgid ""
"The `func` argument can be given as a [C++ "
"lambda](https://en.cppreference.com/w/cpp/language/lambda) **only if** it"
" is not capturing any variable. This is why we need to use `arg`."
msgstr ""

#: ../../appendices/building-for-the-web.md:233
msgid "In the end, our `main.cpp` file remains rather simple:"
msgstr ""

#: ../../appendices/building-for-the-web.md:271
msgid ""
"As for the initial issue of the swap chain, we may simply ignore the call"
" to `wgpuSwapChainPresent` in the emscripten version:"
msgstr ""

#: ../../appendices/building-for-the-web.md:283
msgid "Our interactive application, finally running in the browser."
msgstr ""

#: ../../appendices/building-for-the-web.md:286
msgid "Bonus: Shell"
msgstr ""

#: ../../appendices/building-for-the-web.md:289
msgid ""
"If you want to change the HTML template in which Emscripten wraps your "
"application, you can specify **yet another link option** to set a **shell"
" file**: `--shell-file`."
msgstr ""

#: ../../appendices/building-for-the-web.md:291
msgid ""
"For instance download [`shell_minimal.html`](https://github.com"
"/emscripten-core/emscripten/blob/main/src/shell_minimal.html) from "
"Emscripten's repository."
msgstr ""

#: ../../appendices/building-for-the-web.md:293
msgid ""
"I also add in the snippet below a `LINK_DEPENDS` property to the `App` "
"target that ensures that **whenever the shell file is edited**, the build"
" systems knows that it must re-link the app (even if nothing changed in "
"the code)."
msgstr ""

#: ../../appendices/building-for-the-web.md:315
msgid ""
"You are now able to port pretty much any step of this guide! There are "
"also many advanced options of Emscripten that you can explore, but I do "
"not detail them here because they are not specific to WebGPU."
msgstr ""

#: ../../appendices/custom-extensions/index.md:1
msgid "Custom Extensions"
msgstr ""

#: ../../appendices/custom-extensions/index.md:4
msgid ""
"When using WebGPU in a non-Web context, there is no reason to be limited "
"by the Web requirements. This chapter gives an overview of how to add "
"support for new device features through WebGPU's extension mechanism."
msgstr ""

#: ../../appendices/custom-extensions/index.md:7
msgid ""
"I do not use the [`webgpu.hpp`](https://github.com/eliemichel/WebGPU-Cpp)"
" helper here as the extension file must define a C API. The `webgpu.hpp` "
"wrapper can then easily be generalized to your own custom extension by "
"using [`generator.py`](https://github.com/eliemichel/WebGPU-Cpp#custom-"
"generation)."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:1
msgid "The extension mechanism (ðŸš§WIP)"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:4
msgid "Disclaimer"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:5
msgid ""
"This section of the guide explores **internal APIs** running behinds the "
"scenes of the official `webgpu.h`. These are highly **subject to "
"changes**, as they are conventions of the developers with themselves, not"
" meant to be documented."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:7
msgid ""
"I do my best to update this section from time to time, but the example "
"code **may not work as is** on newer versions. **The overall idea should "
"still hold** anyways, and I invite you to share your experiments on the "
"[Discord server](https://discord.gg/2Tar4Kt564) if you run into trouble!"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:10
msgid "Descriptor extensions"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:13
msgid ""
"You must have noticed this `nextInChain` pointer present in all "
"descriptors. This is a way to **add extra fields to the descriptor**, "
"that may or may not be read by the backend depending on whether they "
"recognize the extension."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:15
msgid "Structure type"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:17
msgid ""
"When creating a new extension, we first need to pick an extension `SType`"
" (\"structure type\") identifier. This identifier can be any value that "
"fits in a 32-bit integer, but **some values are reserved**. For instance,"
" the first values correspond to official extensions:"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:38
msgid ""
"Each backend picked its own range of values, as far as possible to avoid "
"collisions: `wgpu-native` starts at `0x60000001` (`1610612737`) and Dawn "
"starts at `0x000003E8` (`1000`)."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:41
msgid ""
"In the near future, Dawn will move to `0x20000` (`131072`) and wgpu-"
"native to `0x30000` (`196608`)."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:78
msgid "ðŸ˜ How should I pick a value for my extension then?"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:80
msgid ""
"Do **not** use values close **after the ones that already exist**. Each "
"backend and the standard header may add new values just after the ones "
"they already use, so if you used one you will run into a **collision**."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:82
msgid ""
"There is no recommended range in particular yet (I guess there will "
"eventually be more guidance but there is little feedback on this "
"extensions mechanism for now). Just pick a base value far enough from "
"others and sequentially add you extensions there."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:84
msgid ""
"For the sake of the example, I use `0x40000` (`262144`). In a custom "
"`webgpu-ext-foo.h` I define my extension `SType`. To introduce our new "
"feature \"Foo\" we may need to add extension to multiple descriptors."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:100
msgid ""
"Do not forget the `WGPUNativeSType_Force32 = 0x7FFFFFFF`, which is used "
"to ensure that the C++ compiler does not optimize the representation of "
"the enum's value on less than 32 bits."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:104
msgid ""
"Throughout the next sections, we present here **a very simple and "
"uninteresting extension**, called **foo**, which adds an optional `foo` "
"integer member to the `RenderPipeline` and display it in a debug line "
"whenever `setPipeline` is called on a render pass encoder."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:107
msgid "Structure fields"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:109
msgid ""
"Let us follow the logic of the WebGPU device when it receives a "
"descriptor:"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:111
msgid ""
"Look at `nextInChain` if it is not null. This has type "
"`WGPUChainedStruct`, which means its first field is another chain pointer"
" `next`, and its second field is an integer called `sType`."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:112
msgid "Look at the value `nextInChain->sType` and check that it knows this value."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:113
msgid ""
"If it does know it, the device is aware that `nextInChain` actually point"
" to a structure that is **more than just** `WGPUChainedStruct`, but "
"instead a structure that starts in the same way but has **extra fields**."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:114
msgid ""
"The device **casts** `nextInChain` to this known structure and reads the "
"extra fields."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:115
msgid "Repeat from step 1. by replacing `nextInChain` by `nextInChain->next`."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:117
msgid ""
"The heart of the extension lies in step 3. Our extension must provide the"
" definition of this structure that starts like a `WGPUChainedStruct`, "
"that both the user code and the backend code agree on."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:119
msgid ""
"To start like `WGPUChainedStruct`, we use the C-idiomatic inheritance "
"mechanism: have **the first attribute** of your struct be of type "
"`WGPUChainedStruct`. This ensure that an instance of your struct can be "
"cast to a `WGPUChainedStruct`:"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:132
msgid "In the end user code, this would be used as follows:"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:151
msgid "Adapter features"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:154
msgid ""
"When introducing a new extension, we must advertise its availability to "
"the user code by adding a new **feature** in the adapter. Thus at startup"
" when checking adapter capabilities the end user code can figure out "
"whether it is allowed to use the extension of not."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:156
msgid ""
"The logic is very similar to `SType`: there are standard ones, and "
"backend-specific ones starting at the same indices than STypes."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:198
msgid "We can add our own \"Foo\" feature, still in our `webgpu-ext-foo.h` file:"
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:211
msgid ""
"The `webgpu-ext-foo.h` file that we have is all we need as an interface "
"between the user code and our modified backend. For the implementation of"
" this header, we need to chose what backend to edit."
msgstr ""

#: ../../appendices/custom-extensions/mechanism.md:213
msgid ""
"The next 2 chapters focus respectively on [`wgpu-native`](with-wgpu-"
"native.md), then [Dawn](with-dawn.md), to show more **internal details** "
"of how to implement this basic Foo extension."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:1
msgid "With Dawn (ðŸš§WIP)"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:4
#: ../../appendices/custom-extensions/with-dawn.md:340
msgid ""
"*Resulting code:* "
"[`dawn:eliemichel/foo`](https://github.com/eliemichel/Dawn/tree/eliemichel/foo)"
" and [`step030-test-foo-extension-dawn`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step030-test-foo-extension-dawn)"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:7
msgid ""
"If you have not already, don't forget to read the introduction of the "
"[Extension Mechanism](mechanism.md)."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:10
#: ../../appendices/custom-extensions/with-wgpu-native.md:6
#: ../../basic-3d-rendering/some-interaction/simple-gui.md:105
#: ../../basic-compute/image-processing/convolution-filters.md:91
msgid "Setup"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:13
msgid ""
"Instead of fetching Dawn source at configuration time and have it lost in"
" `build/_deps`, we clone Dawn as a git submodule (or just copy it) in our"
" source tree."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:16
msgid ""
"I start from the [`step030-headless`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step030-headless) branch to have a minimalistic "
"version of the test app (and strip down the `save_image` part)."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:33
msgid ""
"Update `webgpu/webgpu.cmake` to use the local Dawn submodule (simply copy"
" from [here](https://github.com/eliemichel/LearnWebGPU-Code/blob/step030"
"-test-foo-extension-dawn/webgpu/webgpu.cmake))."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:36
msgid ""
"I also copied [`webgpu.hpp`](https://github.com/eliemichel/WebGPU-"
"Cpp/blob/main/dawn/webgpu.hpp) into `webgpu/include/webgpu/`."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:39
msgid "New feature"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:42
#: ../../appendices/custom-extensions/with-dawn.md:193
msgid "Public API"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:44
msgid ""
"We start by updating the descriptor structs to handle our new Foo "
"extension. Contrary to `wgpu-native`, we do **not directly write the "
"extension header** (that we called `webgpu-ext-foo.h`), because Dawn's "
"`webgpu.h` is **auto-generated**."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:46
msgid ""
"The source of this generation is the large `dawn.json` file, at the root "
"of Dawn's repo. Locate for instance `\"feature name\": {` to add our Foo "
"feature:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:63
msgid ""
"We add the tag `native` to mean that this feature must only be generated "
"for native builds, not for web-based setups."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:67
msgid ""
"Do not forget to add a comma (`,`) at the end of the previous line, "
"before our custom one."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:70
msgid "We can now check that the feature is indeed supported:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:81
msgid "ðŸ˜¡ It is **not** supported here!"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:83
msgid ""
"The code that was auto-generated from the json file above describes the "
"**public API** of the Dawn library. We now need to manually modify the "
"**internal `dawn::native` API** that is used to dialog with the different"
" backends (Vulkan, DirectX, Metal, etc.)."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:85
#: ../../appendices/custom-extensions/with-dawn.md:262
msgid "Internal API"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:87
msgid "We add our feature to the internal `Feature` enum:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:104
msgid "Update"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:105
msgid ""
"I wrote this on an earlier version of Dawn, lately this has been moved to"
" the auto-generated version so no need to worry about it!"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:108
msgid ""
"We then specify in `Features.cpp` how to convert back and forth between "
"the public and internal APIs:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:136
msgid "Finally, we add some information about this feature:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:151
msgid ""
"I leave the feature state to `Stable` for the sake of simplicity. If you "
"want to set it to `Experimental`, you must make sure to enable the "
"`allow_unsafe_apis` toggle in your application code."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:154
msgid "Backend change (Vulkan)"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:156
msgid ""
"Okey now our feature is correctly wired up in the internal API, but so "
"far **none of the backends support it**! At this stage we must focus on "
"**a single one at a time**."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:158
msgid ""
"We start with **Vulkan**, looking inside `dawn/src/dawn/native/vulkan`. "
"So let's first force the Vulkan backend in our application:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:167
msgid ""
"In Vulkan wording (and also in Dawn's internal), the available feature "
"set is provided by a `PhysicalDevice`."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:169
msgid ""
"In `vulkan/PhysicalDeviceVk.h`, we can see that the `PhysicalDevice` "
"class, specific to this backend, inherits from the `PhysicalDeviceBase` "
"class, defined by the internal backend-agnostic `dawn::native` API."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:171
msgid ""
"This base class contains a protected method `void EnableFeature(Feature "
"feature)`, that the child class may call to enable a particular feature. "
"**In practice** this is done in `InitializeSupportedFeaturesImpl()`, "
"where we add our feature:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:182
msgid "You should now see the feature supported:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:188
msgid ""
"Add it to the list of `requiredFeatures` of the **device descriptor** and"
" you can then check that `wgpuDeviceHasFeature(device, "
"WGPUFeatureName_Foo)` is true!"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:190
msgid "Render pipeline"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:195
msgid ""
"Let us now actually add some behavior to this extension. We create an "
"extension of the `RenderPipelineDescriptor`, thus we create a type that "
"can be chained to this descriptor."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:197
msgid ""
"The **public API** is handled in `dawn.json`: we define the extension "
"chained struct by adding anywhere in the root scope (at the end for "
"instance), the following entry:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:211
msgid "And we must also add **the very name of this struct** to the SType enum:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:228
msgid "We can now try to use this new struct in our application:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:245
msgid ""
"Since so far the render pipeline descriptor was not extended by any "
"feature, a sanity check in `ValidateRenderPipelineDescriptor` ensures "
"that there is no chained data in the descriptor. We must remove that and "
"check instead the validity of the chain:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:260
msgid "Our application now runs correctly, but does nothing special."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:264
msgid ""
"This time, the internal version of `RenderPipelineDescriptor` is "
"identical to the public one (it has a different type name, but is "
"`reinterpret_cast`-ed). So we can directly proceed to the backend change."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:266
msgid "Backend change (agnostic)"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:268
msgid ""
"Our example feature is **so simple** that it can actually be implemented "
"in the `RenderPipelineBase` class, which is **agnostic to the backend**!"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:270
msgid ""
"We add in the struct **two private attributes**, storing the value of "
"\"foo\" provided by our extension of the descriptor, and a boolean "
"telling whether it was provided:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:283
msgid ""
"We then **modify the constructor** to read these values from the "
"descriptor. The handy `FindInChain` utility function **recursively "
"inspects the extension chain**, looking for the right SType:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:300
msgid "We also define a `DoTestFoo` method that emits our test log line:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:318
msgid ""
"In order to trigger this line whenever `setPipeline` is called, we go to "
"the definition of the `RenderEncoderBase` class:"
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:329
msgid ""
"Method names that start with `API` directly correspond to calls to the "
"public API. The mapping is auto-generated."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:332
msgid ""
"And tadam! We were able to create a custom extension, and propagate the "
"extra \"foo\" information from our application code all the way to Dawn's"
" internals."
msgstr ""

#: ../../appendices/custom-extensions/with-dawn.md:338
msgid ""
"Of course this was only a basic example, but from there on changes highly"
" depend on the actual extension you want to implement!"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:1
msgid "With `wgpu-native` (ðŸš§WIP)"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:4
#: ../../appendices/custom-extensions/with-wgpu-native.md:391
msgid ""
"*Resulting code:* "
"[`wgpu`](https://github.com/eliemichel/wgpu/tree/eliemichel/foo), [`wgpu-"
"native`](https://github.com/eliemichel/wgpu-native/tree/eliemichel/foo) "
"and [`step030-test-foo-extension`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step030-test-foo-extension)"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:9
msgid ""
"Before modifying any code, we need to set up the **2 repositories** that "
"`wgpu-native` relies on."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:11
msgid "Building `wgpu-native`"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:13
msgid ""
"Start by building a \"regular\" `wgpu-native` using [the instructions "
"from their repository](https://github.com/gfx-rs/wgpu-native/wiki"
"/Getting-Started). You need in particular [rust](https://www.rust-"
"lang.org/) and [LLVM/Clang](https://rust-lang.github.io/rust-"
"bindgen/requirements.html). With these installed, building looks like "
"this:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:23
msgid ""
"Adapt the value of `LIBCLANG_PATH` above to your actual installation of "
"LLVM/Clang."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:26
msgid ""
"You then find the binaries in `target\\release`. If you use the `wgpu-"
"native` based [WebGPU-distribution](https://github.com/eliemichel/WebGPU-"
"distribution/tree/wgpu) in your end project, simply replace the relevant "
"files in `webgpu/bin`."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:28
msgid "Building `wgpu`"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:30
msgid ""
"The `wgpu-native` repository is a **thin layer** exposing as a C "
"interface the actual `wgpu` backend. When creating a custom extension, we"
" need to change the backend, and instruct the `wgpu-native` layer to use "
"our custom `wgpu` branch."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:38
msgid ""
"To point `wgpu-native` to our custom `wgpu`, we can modify its `wgpu-"
"native/Cargo.toml` and add:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:47
msgid ""
"To make sure to reproduce the very same binaries, check out in the `wgpu`"
" directory the commit specified after `rev =` in the `Cargo.toml` of "
"`wgpu-native`."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:54
msgid ""
"But since you are writing an extension you may want to use the last "
"version of `wgpu` instead."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:57
msgid ""
"You may also need to update the rev hash of `[dependencies.naga]` to "
"match what your version of `wgpu` uses."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:59
msgid "The Foo Extension"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:62
msgid "Extending types"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:64
msgid ""
"We can copy our `webgpu-ext-foo.h` header in the `wgpu-native/ffi/` "
"directory, next to `wgpu.h`. In order to have rust's build system parse "
"these files, we add our custom header to `build.rs`:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:74
msgid ""
"This defines in rust's `native` namespace symbols that are equivalent to "
"what the C header files expose. We must also modify some existing types "
"in `wgpu-types/src/lib.rs`. At least to add our new adapter feature:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:89
msgid ""
"In our running example, we want to add a field `foo` to the render "
"pipeline. We thus modify the `RenderPipelineDescriptor` in `wgpu/wgpu-"
"core/src/pipeline.rs`:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:100
msgid ""
"When trying to build from the `wgpu` root, do not try to build the whole "
"project, we only use `wgpu-core` and `wgpu-types` (which the former "
"depends on), so try building with:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:106
msgid "But more likely you will build from the `wgpu-native` projects:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:112
msgid ""
"If you want your extension to also be available to rust users, you must "
"also adapt the `wgpu` package, but I will not cover it here."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:115
msgid "Extending native wrapper"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:117
msgid ""
"Conversion utilities to link rust-side types defined in `wgpu/wgpu-types`"
" with the `native` defines that follow the C header. Add your feature "
"name to `features_to_native` and `map_feature` in `wgpu-"
"native/src/conv.rs`:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:138
msgid ""
"In order to recognize our `SType` when it is passed in the extension "
"chain of a `RenderPipelineDescriptor`, we modify the "
"`wgpuDeviceCreateRenderPipeline` procedure in `wgpu-native/src/lib.rs`:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:163
msgid "This calls a `map_render_pipeline_descriptor` that we create in `conv.rs`:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:175
msgid ""
"Do not forget to add `map_render_pipeline_descriptor` to the `use "
"conv::{...}` line at the beginning of `lib.rs`."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:178
msgid "Extending core"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:180
msgid ""
"If your extension is shallow enough not to affect the backends, you "
"should only have to modify `wgpu/wgpu-core`. But if you take the time to "
"write a custom extension, it likely requires to modify one or multiple "
"backends."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:182
msgid "Extending backends"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:185
msgid ""
"TODO: I still need to learn better how the code is organized. So far I "
"noticed that:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:187
msgid "`wgpu-native` maps C entry points to the rust API of `wgpu-core`"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:188
msgid ""
"`wgpu-core` maintains the common user API, that application based on wgpu"
" use, either through the native wrapper or through `wgpu-rs` (a.k.a. just"
" `wgpu`). Behinds the scenes, it maps instructions to `wgpu-hal`"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:189
msgid ""
"`wgpu-hal` is the backend/hardware abstraction layer, it defines the "
"internal API that each backend (Vulkan, Metal, DX12, etc.) must implement"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:190
msgid ""
"`wgpu-hal/vulkan` is the Vulkan backend, that implements all of the HAL's"
" requirements"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:193
msgid ""
"The file `wgpu/wgpu-hal/src/lib.rs` defines the interface that each "
"backend must implement. Backends are the subdirectories of `wgpu/wgpu-"
"hal/src` as well as the `empty.rs` file that defines a default behavior "
"that does nothing."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:195
msgid ""
"We implement backends one by one, maybe only for the ones that interest "
"us in practice. We must thus make sure that the `Foo` feature is "
"advertised by the adapter only for the backend that we implemented."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:197
msgid ""
"Let's start with the Vulkan backend. We first advertise that the adapter "
"(a.k.a. *physical device* in Vulkan wording) supports our feature."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:200
msgid ""
"Of course you may inspect the actual physical device properties to "
"conditionally list the `FOO` feature only if the mechanism you want to "
"implement is indeed supported."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:221
msgid "Now in DirectX 12 backend:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:242
msgid "We focus only on the Vulkan backend in the remainder of this section."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:245
msgid ""
"We can now check that the feature is correctly made available in our "
"application code. I start from the "
"[`step030-headless`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step030-headless) branch."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:256
msgid ""
"After you copy the DLL and headers of your custom `wgpu-native`, you "
"should see the Foo feature supported."
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:259
msgid ""
"You can force a particular backend by playing with the **instance "
"extras** extension of `wgpu-native` in the instance descriptor:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:273
msgid "Do not forget to also request the feature when creating your device:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:289
msgid "We can then try extending the render pipeline:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:304
msgid ""
"In order to test that the value is correctly propagated, we just print a "
"log line whenever `setPipeline` is called for this pipeline:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:318
msgid ""
"We need for this to add a `foo` field to the RenderPipeline (we only "
"added it to the descriptor for now):"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:329
msgid "And we propagate from the descriptor when creating the render pipeline:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:344
msgid ""
"But, as you may notice, this is **yet another** taste of "
"`RenderPipelineDescriptor` type (defined in `wgpu-hal/lib.rs`). As this "
"is getting quite confusing, let me summarize with a figure:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:383
msgid ""
"At this stage, if you build `wgpu-native`, update the DLL in your C++ "
"application and run that application, it should eventually display the "
"test log line:"
msgstr ""

#: ../../appendices/custom-extensions/with-wgpu-native.md:389
msgid ""
"**Congratulation**, you have your first extension of `wgpu-native`! Of "
"course it does not do much, and it only does so on the Vulkan backend. "
"But we have explored the architecture of the project. What remains now "
"depends highly on what exact extension you want to implement!"
msgstr ""

#: ../../appendices/dawn-vs-wgpu-native.md:1
msgid "Dawn vs wgpu-native"
msgstr ""

#: ../../appendices/dawn-vs-wgpu-native.md:4
msgid ""
"Despite the kind of click-bait title, this page does not intend to tell "
"which implementation is better, but rather to list the key divergence "
"that it is important to be aware of while reading the guide because I did"
" not update all examples and chapters to support both backend yet (I'm "
"waiting for the API to settle before taking the time to review all code "
"examples)."
msgstr ""

#: ../../appendices/dawn-vs-wgpu-native.md:6
msgid "Most annoying divergences are:"
msgstr ""

#: ../../appendices/dawn-vs-wgpu-native.md:8
msgid "Drop vs Release"
msgstr ""

#: ../../appendices/dawn-vs-wgpu-native.md:9
msgid "Drop on finish()"
msgstr ""

#: ../../appendices/dawn-vs-wgpu-native.md:10
msgid "Poll vs Tick"
msgstr ""

#: ../../appendices/dawn-vs-wgpu-native.md:12
msgid "Another limiting issue:"
msgstr ""

#: ../../appendices/dawn-vs-wgpu-native.md:14
msgid "GLFW did not merge https://github.com/glfw/glfw/pull/2333 yet"
msgstr ""

#: ../../appendices/dawn-vs-wgpu-native.md:15
msgid "Dawn uses size_t vs uint32_t everywhere in standard header"
msgstr ""

#: ../../appendices/dawn-vs-wgpu-native.md:16
msgid ""
"With Dawn, stencilLoadOp and stencilStoreOp must be set to respectively "
"LoadOp::Undefined and StoreOp::Undefined."
msgstr ""

#: ../../appendices/debugging.md:1
msgid "Debugging (ðŸš§WIP)"
msgstr ""

#: ../../appendices/debugging.md:4
msgid ""
"It is important to get familiar with some basic debugging tips as early "
"as possible."
msgstr ""

#: ../../appendices/debugging.md:6
msgid "Graphics debugger"
msgstr ""

#: ../../appendices/debugging.md:9
msgid ""
"There is a particular challenge when it comes to graphics debugging: the "
"usual debugging tools **can only see what happens on the CPU**, because "
"that's where they live."
msgstr ""

#: ../../appendices/debugging.md:11
msgid ""
"We hence need a dedicated tool, called a **graphics debugger**. This "
"debugger still runs on the CPU, but it gets **injected between your "
"application and the GPU command queue**, and monitors everything that "
"passes so that it can **replay** all your commands. Kind of a [man-in-"
"the-middle](https://en.wikipedia.org/wiki/Man-in-the-middle_attack), if "
"you will."
msgstr ""

#: ../../appendices/debugging.md:13
msgid ""
"A graphics debugger really help a lot at debugging shaders, buffers, "
"textures, etc. by enabling us to inspect the GPU memory and state. And it"
" can also give performance hints."
msgstr ""

#: ../../appendices/debugging.md:15
msgid "I use two graphics debuggers:"
msgstr ""

#: ../../appendices/debugging.md:17
msgid ""
"[RenderDoc](https://renderdoc.org/) is really great for **debugging**, it"
" is actively and very accurately maintained."
msgstr ""

#: ../../appendices/debugging.md:19
msgid ""
"[Nsight Graphics](https://developer.nvidia.com/nsight-graphics) also has "
"a debugger, but I use it mostly for its **frame profiler** that gives "
"detailed insights about the time spent by various GPU units."
msgstr ""

#: ../../appendices/debugging.md:21
msgid "Debugging textures"
msgstr ""

#: ../../appendices/debugging.md:24
msgid ""
"This first example of debugging is inspired by a real bug encountered by "
"a reader[^iazalong] when following the [texture loading](../basic-3d-"
"rendering/texturing/loading-from-file.md) chapter."
msgstr ""

#: ../../appendices/debugging.md:28
msgid "Clearly, something was wrong with the texture:"
msgstr ""

#: ../../appendices/debugging.md:33
msgid "Something is wrong with the texture."
msgstr ""

#: ../../appendices/debugging.md:36
msgid ""
"First reflex before touching at the code is to **diagnose** a little "
"better the issue with RenderDoc. In the *Launch Application* tab of "
"RenderDoc, browse to your application in *Executable Path*, maybe adapt "
"the *Working Directory* if you load resources from relative paths, and "
"you should see your program start with a **debug overlay** on the top:"
msgstr ""

#: ../../appendices/debugging.md:41
msgid "The application launched from RenderDoc."
msgstr ""

#: ../../appendices/debugging.md:44
msgid ""
"This overlay confirms that RenderDoc was able to inject itself between "
"your program and the GPU, and as it suggests, press F12 to capture a "
"frame. This records everything that transits to the GPU and creates a "
"**Capture**."
msgstr ""

#: ../../appendices/debugging.md:47
msgid ""
"You may then close your program, the capture contains everything it needs"
" to replay your very frame."
msgstr ""

#: ../../appendices/debugging.md:50
msgid ""
"Double click on the capture to open it. The *Event Browser* shows all the"
" events (i.e., commands) that were intercepted by the debugger, and "
"clicking on one goes to the state of the GPU as it was at that time. "
"Locate for instance the main draw call:"
msgstr ""

#: ../../appendices/debugging.md:55
msgid "The list of events in RenderDoc."
msgstr ""

#: ../../appendices/debugging.md:58
msgid ""
"You can use the *Outputs* tab of the *Texture Viewer* to help you "
"navigate through the events."
msgstr ""

#: ../../appendices/debugging.md:61
msgid ""
"The captured events do not exactly match the WebGPU commands, because "
"RenderDoc captures the low-level API that is hidden behind it. In my "
"example, WebGPU runs on a Vulkan backend so what we see is Vulkan events."
" On a different platform, you may see a different API such as Metal or "
"DirectX, but you should anyway recognize the overall structure."
msgstr ""

#: ../../appendices/debugging.md:64
msgid ""
"Since something seems wrong the input texture, let's go to the *Inputs* "
"tab and look at it (make sure you are on the right draw call in the event"
" browser):"
msgstr ""

#: ../../appendices/debugging.md:69
msgid "The input texture inspected in RenderDoc."
msgstr ""

#: ../../appendices/debugging.md:72
msgid ""
"So far so good, so what is wrong? Mmh, let's now inspect the different "
"mip levels:"
msgstr ""

#: ../../appendices/debugging.md:77
msgid "The mip levels inspected in RenderDoc."
msgstr ""

#: ../../appendices/debugging.md:80
msgid ""
"Here we are, the mip levels are not built correctly! We now know that we "
"should focus our debugging effort on the part of `loadTexture` that "
"builds and upload the mip levels."
msgstr ""

#: ../../appendices/debugging.md:83
msgid ""
"As it turns out, the problem was that the `writeTexture` call was "
"pointing to the original pixel buffer for all mip levels."
msgstr ""

#: ../../appendices/debugging.md:86
msgid "Debugging geometry"
msgstr ""

#: ../../appendices/debugging.md:89
msgid ""
"Another typical use case of RenderDoc is to inspect the geometry. And "
"more generally, the *Pipeline State* tab gives precious information about"
" draw calls:"
msgstr ""

#: ../../appendices/debugging.md:94
msgid "The graphics pipeline tab in RenderDoc."
msgstr ""

#: ../../appendices/debugging.md:97
msgid ""
"We can see here the whole **render pipeline**, with both its fixed-"
"function and programmable stages. In the *Vertex Input* stage, there is "
"in particular a *Mesh View* that is very insightful:"
msgstr ""

#: ../../appendices/debugging.md:102
msgid "The mesh view in RenderDoc."
msgstr ""

#: ../../appendices/debugging.md:105
msgid ""
"You can see, both as a table and in a 3D viewer, the assembled input "
"geometry and the post vertex shader one."
msgstr ""

#: ../../appendices/debugging.md:107
msgid "Debugging in browser"
msgstr ""

#: ../../appendices/debugging.md:110
msgid ""
"If you are compiling your project as a web page using emscripten, you "
"should check out [the `webgpu-devtools` Chrome "
"extension](https://chrome.google.com/webstore/detail/webgpu-"
"devtools/ckabpgjkjmbkfmichbbgcgbelkbbpopi), it provides advanced WebGPU-"
"specific debugging tools!"
msgstr ""

#: ../../appendices/debugging.md:26
msgid "Thanks *Iazalong*!"
msgstr ""

#: ../../appendices/feedback-needed.md:1
msgid "Feedback needed"
msgstr ""

#: ../../appendices/feedback-needed.md:4
msgid ""
"This guide is still a Work in Progress. Because it is not finished, to "
"begin with, but also importantly because to feel satisfied I need more "
"feedback about the following points."
msgstr ""

#: ../../appendices/feedback-needed.md:6
msgid ""
"Any suggestion? [**Please fill this feedback "
"form!**](https://forms.gle/SUHKuogBRMMnXf7PA)"
msgstr ""

#: ../../appendices/feedback-needed.md:8
msgid ""
"You may also contact me on Twitter [@exppad](https://twitter.com/exppad) "
"and join the support Discord server: "
"[https://discord.gg/2Tar4Kt564](https://discord.gg/2Tar4Kt564)."
msgstr ""

#: ../../appendices/feedback-needed.md:10
msgid "Is it easy to follow?"
msgstr ""

#: ../../appendices/feedback-needed.md:13
msgid ""
"*Where you able to follow the different steps. Is there anything that "
"blocked you, that took you more time than expected, that was "
"frustrating?*"
msgstr ""

#: ../../appendices/feedback-needed.md:15
msgid ""
"Even if it is something that is actually mentioned and that you missed, "
"the fact that you missed it is a sign that I may need to rephrase."
msgstr ""

#: ../../appendices/feedback-needed.md:17
msgid ""
"*Is it engaging enough? Did you stop reading it at some point? Where "
"exactly? Do you plan on continuing the lecture?*"
msgstr ""

#: ../../appendices/feedback-needed.md:19
msgid "Is level of detail right?"
msgstr ""

#: ../../appendices/feedback-needed.md:22
msgid ""
"Give too many details, and people get lost, or bored, because they'd like"
" to go to the point faster. Don't give enough, and people don't get "
"things right, or miss important concepts."
msgstr ""

#: ../../appendices/feedback-needed.md:24
msgid ""
"*Is the level of detail right for your case? What is your use case by the"
" way? Is the level of detail constant enough, or did you feel that "
"sometimes it's too fast and sometimes it's too slow?*"
msgstr ""

#: ../../appendices/feedback-needed.md:26
msgid "Is it up to date?"
msgstr ""

#: ../../appendices/feedback-needed.md:29
msgid ""
"Writing a guide about a moving not-standard-yet API requires to follow "
"tightly new development, which I may fail at. Or I followed but forgot to"
" update some corners of this guide."
msgstr ""

#: ../../appendices/feedback-needed.md:31
msgid ""
"*Was any information outdated? Did you spot any inconsistency from one "
"chapter to another?*"
msgstr ""

#: ../../appendices/feedback-needed.md:33
msgid "Are things introduced in the right order?"
msgstr ""

#: ../../appendices/feedback-needed.md:36
msgid ""
"*Did you feel you had to go through chapter that don't interest you to "
"reach the ones that do?*"
msgstr ""

#: ../../appendices/feedback-needed.md:38
msgid ""
"The potential audience of this guide is made of various profiles. Some "
"people already know another graphics API and want to learn what is "
"different with WebGPU. Some people already know WebGPU and want to know "
"what is different in native and/or C++ programming. Some people are "
"newcomers to real-time graphics and want to learn how to create a little "
"video game."
msgstr ""

#: ../../appendices/feedback-needed.md:40
msgid ""
"I wish I can provide a comfortable reading route to all of these readers "
"but it requires some organization."
msgstr ""

#: ../../appendices/feedback-needed.md:42
msgid "Is it accurate?"
msgstr ""

#: ../../appendices/feedback-needed.md:45
msgid ""
"The answer to this would come from people who already know WebGPU before "
"reading this guide, and in particular people who drafted the standard: "
"*Do they agree with what is said? Did I do mistakes?*"
msgstr ""

#: ../../appendices/feedback-needed.md:47
msgid "Is it complete?"
msgstr ""

#: ../../appendices/feedback-needed.md:50
msgid ""
"Wherever I put \"WIP\" in the title it means that I know it is missing "
"something, but what else?"
msgstr ""

#: ../../appendices/feedback-needed.md:52
msgid ""
"*Do you think this guide misses something important? Or are they advanced"
" techniques that you would love to see included?*"
msgstr ""

#: ../../appendices/feedback-needed.md:54
msgid ""
"Again, if you want to tell something about any of these points, [**here "
"is the feedback form!**](https://forms.gle/SUHKuogBRMMnXf7PA)"
msgstr ""

#: ../../appendices/index.md:1
msgid "Appendices"
msgstr ""

#: ../../appendices/memory-model.md:1
msgid "Memory Model (ðŸ›‘TODO)"
msgstr ""

#: ../../appendices/memory-model.md:4
msgid "Here we summarize how memory is laid out in a GPU."
msgstr ""

#: ../../appendices/references.md:1
msgid "References (ðŸš§WIP)"
msgstr ""

#: ../../appendices/references.md:4
msgid "*This list is highly WIP*"
msgstr ""

#: ../../appendices/references.md:6
msgid "[WebGPU Official Specification](https://www.w3.org/TR/webgpu)"
msgstr ""

#: ../../appendices/references.md:7
msgid "[Learn wgpu for Rust](https://sotrh.github.io/learn-wgpu)"
msgstr ""

#: ../../appendices/references.md:8
msgid ""
"[WebGPU Buffer upload best practices](https://toji.github.io/webgpu-best-"
"practices/buffer-uploads.html)"
msgstr ""

#: ../../appendices/references.md:9
msgid "[WebGPU Explainer](https://gpuweb.github.io/gpuweb/explainer)"
msgstr ""

#: ../../appendices/references.md:10
msgid ""
"[Efficiently rendering glTF models - A WebGPU Case "
"Study](https://toji.github.io/webgpu-gltf-case-study)"
msgstr ""

#: ../../appendices/references.md:11
msgid ""
"[Awesome WebGPU: A curated list of WebGPU ressources, libraries and "
"tools](https://github.com/mikbry/awesome-webgpu)"
msgstr ""

#: ../../appendices/references.md:12
msgid ""
"[Another list of WebGPU ressources](https://wiki.nikiv.dev/computer-"
"graphics/webgpu)"
msgstr ""

#: ../../appendices/references.md:13
#, python-format
msgid ""
"[WebGPU is Not Just About the "
"Web](../data/2023-03_WebGPU%20is%20not%20just%20about%20the%20Web.pdf), "
"an introduction to this guide that was given at *QCon London 2023* (and "
"[another ref](http://kvark.github.io/web/gpu/native/2020/05/03/point-of-"
"webgpu-native.html) backing this claim)."
msgstr ""

#: ../../appendices/references.md:14
msgid ""
"[A detailed introduction to Computer "
"Graphics](https://www.scratchapixel.com)"
msgstr ""

#: ../../appendices/references.md:15
msgid ""
"Filament's [material "
"guide](https://google.github.io/filament/Materials.html) and [design "
"document](https://google.github.io/filament/Filament.html)"
msgstr ""

#: ../../appendices/references.md:16
msgid ""
"A simple playground for testing WGSL shaders: "
"[https://takahirox.github.io/online-wgsl-"
"editor](https://takahirox.github.io/online-wgsl-editor)"
msgstr ""

#: ../../appendices/references.md:17
msgid ""
"A guide to get started with the WebGPU Shader Language [Tour of "
"WGSL](https://google.github.io/tour-of-wgsl/)"
msgstr ""

#: ../../appendices/references.md:18
msgid ""
"Examples of AI tool based on WebGPU: https://mlc.ai/web-llm/ and "
"https://mlc.ai/web-stable-diffusion/"
msgstr ""

#: ../../appendices/references.md:19
msgid "[WebGPU fundamentals](https://webgpufundamentals.org/)"
msgstr ""

#: ../../appendices/references.md:20
msgid ""
"[A blog post with nice diagrams about WebGPU "
"usage](https://cohost.org/mcc/post/1406157-i-want-to-talk-about-webgpu)"
msgstr ""

#: ../../appendices/references.md:21
msgid ""
"[WebGPU Bind Group best practices](https://toji.dev/webgpu-best-practices"
"/bind-groups.html)"
msgstr ""

#: ../../appendices/references.md:22
msgid ""
"A blog post to get started with WebGPU C++ targeting the web: [WebGPU: "
"the cross-platform graphics API of "
"tomorrow](https://developer.chrome.com/blog/webgpu-cross-platform/)"
msgstr ""

#: ../../appendices/references.md:23
msgid ""
"[A Technical report on WebGPU's "
"safety](https://chromium.googlesource.com/chromium/src/+/main/docs/security/research/graphics/webgpu_technical_report.md)"
msgstr ""

#: ../../appendices/teaching-native-graphics-in-2023.md:1
msgid "Teaching native graphics in 2023"
msgstr ""

#: ../../appendices/teaching-native-graphics-in-2023.md:4
msgid ""
"*This is a more detailed explaination of the section [Why "
"WebGPU](../introduction.md#why-webgpu) of the lecture's introduction.*"
msgstr ""

#: ../../appendices/teaching-native-graphics-in-2023.md:6
msgid ""
"My interest for using WebGPU for native development grew while looking "
"for **the best graphics API to teach** in a computer graphics curriculum."
msgstr ""

#: ../../appendices/teaching-native-graphics-in-2023.md:9
msgid ""
"Graphics API evolved very quickly over the last 20 years (think of how "
"OpenGL 1.1 looked like for those of you who know it), so it is important "
"lectures follow at a reasonable pace this evolution."
msgstr ""

#: ../../appendices/teaching-native-graphics-in-2023.md:12
msgid ""
"For a long time, I had been teaching **OpenGL**. This was a perfectly "
"standard and cross-platform API for interacting with GPUs. But over the "
"years this API and its idioms started to become **legacy**. First, Apple "
"stopped supporting it after version 4.1 (leaving me with the frustration "
"of not being able to use "
"[DSA](https://www.khronos.org/opengl/wiki/Direct_State_Access) in the "
"lectures, among other things), and **deprecated** it all together from "
"macOS 10.14 onward (since 2018). Basically, they could drop it at any "
"time, so teaching OpenGL now is really **not a future-proof bet**."
msgstr ""

#: ../../appendices/teaching-native-graphics-in-2023.md:15
msgid ""
"Secondly, it is clear that there will be no new version of OpenGL "
"anyways. Its steering consortium is now working on **Vulkan**. Vulkan was"
" meant to remain a cross-platform API, despite its whole new design, and "
"even unify desktop and mobile platforms, thus being able to fully "
"**replace OpenGL** on the long run. **But**... here comes Apple again."
msgstr ""

#: ../../appendices/teaching-native-graphics-in-2023.md:17
msgid ""
"Like many actors of the graphics world, **Apple** felt in the early 2010s"
" the need to evolve from the design of OpenGL (which had diverged too "
"much from the way the hardware had evolved), and started their own API "
"called **Metal**. Unlike the others though, they **refused to join** "
"efforts into the Vulkan initiative. So, although there are [ways to use "
"Vulkan on Apple devices](https://www.lunarg.com/wp-"
"content/uploads/2021/06/The-State-of-Vulkan-on-Apple-03June-2021.pdf), we"
" cannot really consider Vulkan as cross-platform enough. I don't want my "
"lecture to feel a bit of a hack to macOS users."
msgstr ""

#: ../../appendices/teaching-native-graphics-in-2023.md:19
msgid ""
"This scattered state of the graphics APIs is a **source of concern** for "
"all software vendors who try to support both Linux, Windows and macOS "
"(not to mention mobile platforms). They are forced to implement the same "
"processes in different APIs, and while factorizing these parallel "
"implementations, a lot of them spontaneously end up writing **custom "
"graphics abstraction** libraries."
msgstr ""

#: ../../appendices/teaching-native-graphics-in-2023.md:21
msgid ""
"**Should we teach such an abstraction library?** I am quite reluctant at "
"doing this. A lot of them make domain-specific choices related to the "
"context in which they have been developed. And they are very often "
"incomplete because not enough time can be invested into making them "
"reusable. The longevity of these libraries is likely much shorter than "
"the one of more standardized APIs (which are themselves dying too fast "
"already). They might enforce specific idioms that are uncommon, making "
"the transition to other graphics APIs harder."
msgstr ""

#: ../../appendices/teaching-native-graphics-in-2023.md:23
msgid ""
"The **Web consortium** faced the same issue when trying to expose a "
"unified GPU abstraction to JavaScript code, and they drafted "
"[WebGPU](https://gpuweb.github.io/gpuweb)."
msgstr ""

#: ../../appendices/teaching-native-graphics-in-2023.md:25
msgid ""
"This API has a growing developer/documentation base, is general purpose, "
"cross-platform and future-oriented, which thus makes it a good candidate "
"even for desktop applications! This is why Google Chrome's implementation"
" of this API has been designed as a separate code base, called "
"[Dawn](https://dawn.googlesource.com/dawn), and that can be linked by "
"other applications."
msgstr ""

#: ../../appendices/tmp.md:1
msgid "Temporary page"
msgstr ""

#: ../../appendices/tmp.md:4 ../../appendices/tmp.md:8
msgid "youp"
msgstr ""

#: ../../appendices/tmp.md:5
msgid "topic"
msgstr ""

#: ../../appendices/tmp.md:9
msgid "admonition"
msgstr ""

#: ../../appendices/tmp.md:13
msgid "attention"
msgstr ""

#: ../../appendices/tmp.md:17
msgid "caution"
msgstr ""

#: ../../appendices/tmp.md:21
msgid "danger"
msgstr ""

#: ../../appendices/tmp.md:25
msgid "error"
msgstr ""

#: ../../appendices/tmp.md:29
msgid "hint"
msgstr ""

#: ../../appendices/tmp.md:33
msgid "important"
msgstr ""

#: ../../appendices/tmp.md:37
msgid "note"
msgstr ""

#: ../../appendices/tmp.md:41
msgid "seealso"
msgstr ""

#: ../../appendices/tmp.md:45
msgid "tip"
msgstr ""

#: ../../appendices/tmp.md:49
msgid "warning"
msgstr ""

#: ../../appendices/tmp.md:52
msgid "Known Limitations"
msgstr ""

#: ../../appendices/tmp.md:55
msgid ""
"The window's ratio should be applied to the x coord instead of y to match"
" the behavior of GLM from the very beginning of the lecture."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:1
#: ../../basic-compute/compute-pipeline.md:19
msgid "A simple example"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:5
#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:245
msgid ""
"*Resulting code:* [`step050`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step050)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:9
#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:249
msgid ""
"*Resulting code:* [`step050-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step050-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:12
msgid ""
"Let's dive into what you are quite likely here for: rendering **3D "
"shapes**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:15
msgid ""
"I rolled back the part of the code about dynamic uniforms for now. I also"
" set the `offset` to `vec2f(0.0)`;"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:18
msgid "Switching to 3D data"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:21
msgid "The first thing we need is a 3rd column in our point position!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:23
msgid "Here is a simple shape that you can save in `resources/pyramid.txt`:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:50
msgid ""
"Of course we need to adapt our `loadGeometry` function to handle this "
"extra dimension. I added a `int dimensions` argument that should be "
"either 2 or 3 depending on whether we are in 2D or 3D:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:64
msgid "We can now load the geometry as follows:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:70
msgid ""
"As a consequence of this new dimension, we need to update the vertex "
"buffer stride, the position attribute format and the color attribute "
"offset:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:87
msgid "We also need to increase the maximum stride of vertex arrays:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:95
msgid "And don't forget to update the vertex input struct in the **shader**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:105
msgid ""
"Now it kinda works, we can guess a pyramid is here, but I wouldn't call "
"it 3D yet. And adding `in.position.z` to `out.position.z` does not change"
" anything so far:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:110
msgid "The pyramid... seen from above, with no perspective."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:114
msgid ""
"I intentionally set a different color for the tip of the pyramid so that "
"we can see better. This will be better addressed when introducing a basic"
" **shading**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:117
msgid "Basic transform"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:120
msgid ""
"*This is a gentle introduction to trigonometry. If you are familiar with "
"the concept, you may jump ahead.*"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:122
msgid ""
"Seen from above, this pyramid boringly looks like an square. Could we "
"**rotate** this? A very basic way to change the view angle is to swap "
"axes:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:136
msgid "The pyramid seen from the side (still no perspective)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:139
msgid ""
"What about in-between rotations? The idea is to **mix axes**, adding a "
"little bit of z in the y coordinates and a little bit of y in the z "
"coordinates."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:153
msgid "The pyramid from a tilted view angle."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:156
msgid ""
"Of course at some point we have to remove some of `in.position.y` from Y "
"so that after a quarter of turn we reach `Y = 0.0 * in.position.y + 1.0 *"
" in.position.z`, as in the example above. So more generally our transform"
" writes like this, where `alpha` and `beta` depend on the rotation angle:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:171
msgid ""
"If you payed close attention to the snippet above, you should have "
"noticed **a minus sign** `-` before the second `beta`. It is not visible "
"on our pyramid because it is symmetrical but swapping axes also flips the"
" object. To **counter-balance** this, we can change the sign of one of "
"the dimensions. Hence the Z coordinate after a quarter of turn must be "
"`-in.position.y` instead of `in.position.y`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:174
msgid ""
"It turns out that these weights `alpha` and `beta` are not easy to "
"express in terms of basic operations with respect to the angle. So "
"mathematicians came up with a dedicated name for them: **cosine** and "
"**sine**! And the good news is that these are **built-in operations** in "
"WGSL:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:207
msgid ""
"Congratulations, you have learned most of what there is to know about "
"**trigonometry** for computer graphics!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:210
msgid ""
"**If you cannot remember** which one is the $cos$ and which one is the "
"$sin$ among `alpha` and `beta` (don't worry it happens to all the time), "
"**just take an example** of very simple rotation: `angle = 0`. In such a "
"case, we need `alpha = 1` and `beta = 0`. If you look at a plot of the "
"$sin$ and $cos$ functions you'll quickly see that $cos(0) = 1$ and "
"$sin(0) = 0$"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:214
msgid ""
"The argument of trigonometric functions is an **angle**, but be aware "
"that it must be expressed in **radians**. There is a total of $2\\pi$ "
"radians for a full turn, which leads to the following elementary cross-"
"multiplication rule:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:216
msgid ""
"\n"
"\\frac{r \\text{ radians}}{d \\text{ degrees}} = \\frac{2\\pi \\text{ "
"radians}}{360 \\text{ degrees}}\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:220
msgid ""
"So to convert an angle $d$ in degrees into its equivalent $r$ in radians,"
" we simply do:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:222
msgid ""
"\n"
"r = d \\times \\frac{\\pi}{180}\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:230
msgid ""
"We have a beginning of something. With this rotation, it starts looking "
"like 3D, but there remains some important points to be concerned about:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:232
msgid ""
"**Depth fighting** As highlighted in the image below, the triangles do "
"not overlap in the correct order."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:233
msgid ""
"**Transform** We have the basics, but it is a bit manual, and there is "
"still **no perspective**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:234
msgid ""
"**Shading** The trick of setting the tip of the pyramid to a darker color"
" was good for starting, but we can do much better."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:236
msgid ""
"These points are, in this order, the topic of the next 4 chapters "
"(transforms are split in 2 chapters)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:241
#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:15
msgid "There is something wrong with the depth."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:1
msgid "Basic shading"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:5
#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:349
msgid ""
"*Resulting code:* [`step056`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step056)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:9
#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:353
msgid ""
"*Resulting code:* [`step056-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step056-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:12
msgid ""
"From the beginning of this 3D mesh section, **we have been cheating** by "
"darkening the color of the tip of the pyramid in order to get some sense "
"of the geometry. But in reality, the strongest **visual clues** we get "
"about the geometry of the objects that surround us come from the "
"**lighting effects**, and in particular the **shading**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:14
msgid ""
"In this chapter we get **an intuition** about how to shade a scene, but "
"do not follow a very physically based approach (this will come later on)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:16
msgid "Theory"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:19
msgid ""
"Let's be quick with the theory, because we've had enough in the previous "
"chapter. Simply look at this picture:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:24
msgid "It is always a good idea to observe natural images."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:27
msgid ""
"The jar has a more or less uniform material. Yet, its different sides "
"**look** different, the left-hand squared area is darker than the right-"
"hand one."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:29
msgid ""
"Why so? Because they have different **orientations**. One is oriented "
"towards the light, whereas the other one faces a different direction."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:31
msgid ""
"The direction of a face is expressed as **a vector that is perpendicular "
"to the face**. This is called a **normal** vector, and it always has "
"length 1 because all we care about is its direction (it is called a "
"*normalized* vector, or a *unit* vector)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:48
msgid ""
"There are **two possible** vectors that are perpendicular to the face and"
" have a unit length: one and its opposite (going towards the other side "
"of the face). **By convention**, we point the normal towards the outside "
"of the object, but this might not be well defined for meshes that are not"
" closed. Whenever you encounter weird shading artifacts, always check "
"your normals!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:51
msgid "Normal"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:54
msgid "Data"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:56
msgid ""
"The normals can be mathematically computed (using the cross product of "
"two sides of the triangle), but it is common to **store them in the 3D "
"file** format, because sometimes we use intentionally fake normals to "
"give the feeling that triangles are slightly curved."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:58
msgid ""
"We will add this normal information to our little file format and add a "
"new vertex attribute:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:102
msgid ""
"I had to **duplicate some points**, because although they have the same "
"location, they have different normals depending on the face they belong "
"to. Actually, vertices should be considered in general as **face "
"corners** rather than 3D points."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:106
msgid ""
"To better see the impact of our shading, I gave the same base color to "
"the whole pyramid this time."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:109
#: ../../basic-compute/image-processing/mipmap-generation.md:56
msgid "Loading"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:111
msgid ""
"We do not need to change our geometry loading procedure, only the number "
"of float attributes per vertex:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:118
msgid ""
"The `vertexData` array now contains 3 attributes per vertex. In order to "
"**better manage** our vertex attributes, we can create a structure that "
"we will use similarly to the `MyUniforms` struct:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:132
msgid "This structure mirrors the `VertexInput` struct from the WGSL shader:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:142
msgid ""
"The **order of the fields** does not need to be the same. The order of "
"the fields in the C++ struct `VertexAttributes` is driven by the order in"
" which the data is stored in the loaded file."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:144
msgid ""
"The order in `VertexInput` does not matter, and the `@location` must "
"match the attribute definition:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:171
msgid "And do not forget to change the device limits:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:188
msgid "Shading"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:191
msgid "Light direction"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:193
msgid ""
"Now the normal data is loaded from the file, and accessible to the vertex"
" shader. But shading occurs in the **fragment shader**, so we need to "
"forward the normal attribute:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:213
msgid ""
"In order to **check that everything is piped up correctly**, you can try "
"to just use the coordinates of the normal vector as the output color. "
"Since these coordinates are in the range $(-1,1)$, I usually add ` * 0.5 "
"+ 0.5` to remap them in the range $(0,1)$, which the color output "
"expects:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:231
msgid "Let's now do some experiments with this normal:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:243
msgid ""
"Multiplying the color by the normal axes creates axis-aligned directional"
" lights."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:246
msgid ""
"To apply a lighting coming from an arbitrary direction, we again use a "
"linear combination of the different axes:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:259
msgid ""
"Mixing multiple axes can create a directional light coming from any "
"direction."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:262
msgid ""
"The coefficient $(0.5, -0.9, 0.1)$ are in fact the **light direction** "
"This combination is called a **dot product**:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:274
msgid ""
"The term \"direction\" suggests that this is a **normalized** vector "
"(i.e., a vector whose length is $1$. Here we actually encode the "
"direction plus the **intensity** of the light, through the magnitude "
"(i.e., length) of the vector."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:277
msgid "Multiple lights"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:279
msgid ""
"Adding multiple light sources is as simple as summing the contribution of"
" multiple directions. One important thing though:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:318
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:321
msgid "Transform"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:321
msgid ""
"In the previous part, the light direction changes with the object's "
"orientation. To apply a fixed global lighting, we need to transform the "
"normal wrt. the model transform, but not the view transform (hence the "
"distinction)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:346
msgid ""
"We will see a much more accurate material model in the [Lighting and "
"material](/basic-3d-rendering/lighting-and-material/index.md) chapter."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:1
msgid "Depth buffer"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:5
#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:353
msgid ""
"*Resulting code:* [`step052`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step052)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:9
#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:357
msgid ""
"*Resulting code:* [`step052-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step052-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:18
msgid "The Z-Buffer algorithm"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:21
msgid ""
"The issue we are facing with this basic example comes from the problem of"
" **visibility**. As easy to conceive as it is, the question \"does this "
"point see that one\" (i.e., does the line between them intersect any "
"geometry) is hard to answer efficiently."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:23
msgid ""
"In particular, when producing a **fragment**, we must figure out whether "
"the 3D point it corresponds to is seen by the view point in order decide "
"whether it must be blended into the output texture."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:25
msgid ""
"The **Z-Buffer algorithm** is what the GPU's render pipeline uses to "
"solve the visibility problem:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:27
msgid ""
"**For each pixel**, it stores the depth of the last fragment that has "
"been blended into this pixel, or a default value (that represents the "
"furthest depth possible)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:28
msgid ""
"Each time a new fragment is produced, its **depth is compared** to this "
"value. If the fragment depth is larger than the currently stored depth, "
"it is **discarded** without being blended. Otherwise, it is blended "
"normally and the stored value is updated to the depth of this new closest"
" fragment."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:30
msgid ""
"As a result, only the fragment with the lowest depth is visible in the "
"resulting image. The depth value for each pixel is stored in a special "
"**texture** called the **Z-buffer**. This is the only memory overhead "
"required by the Z-buffer algorithm, making it a good fit for real time "
"rendering."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:32
msgid "About transparency"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:33
msgid ""
"The fact that only the fragment with the lowest depth is visible is **not"
" guaranteed** when fragments have **opacity values that are neither 0 or "
"1** (and alpha-blending is used). Even worst: the order in which "
"fragments are emitted has an impact on the result (because blending a "
"fragment **A** and then a fragment **B** is different than blending **B**"
" then **A**)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:35
msgid ""
"Long story short: **transparent objects are always a bit tricky** to "
"handle in a Z-buffer pipeline. A simple solution is to limit the number "
"of transparent objects, and dynamically sort them wrt. their distance to "
"the view point. More advanced schemes exist such as [Order-independent "
"transparency](https://en.wikipedia.org/wiki/Order-"
"independent_transparency) techniques."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:38
msgid "Pipeline State"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:41
msgid ""
"Since this Z-Buffer algorithm is a critical step of the 3D rasterization "
"pipeline, it is implemented as a **fixed-function** stage. We configure "
"it through the `pipelineDesc.depthStencil` field, which we had left null "
"so far."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:82
msgid ""
"The first aspect of the Z-Buffer algorithm that we can configure is the "
"**comparison function** that is used to decide whether we should keep a "
"new fragment or not. It defaults to `Always`, which basically deactivate "
"the depth testing (the fragment is always blended)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:84
msgid ""
"**The most common choice** is to set it to `Less` to mean that a fragment"
" is blended only if its depth is **less** than the current value of the "
"Z-Buffer."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:98
msgid ""
"The second option we have is whether or not we want to **update the "
"value** of the Z-Buffer once a fragment passes the test. It can be useful"
" to deactivate this, when rendering user interface elements for instance,"
" or when dealing with transparent objects, but **for a regular use "
"case**, we indeed want to write the new depth each time a fragment is "
"blended."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:104
msgid ""
"Lastly, we must tell the pipeline how the depth values of the Z-Buffer "
"are **encoded** in memory:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:123
msgid ""
"Depth textures **do not use the same formats** as color textures, they "
"have their own set of possible values (all starting with `Depth`). The "
"same texture is used to represent both the depth and the *stencil* value,"
" when enabled, and the total budget is 32 bits per pixel, so it is common"
" to use a depth encoded on 24 bits and leave the last 8 bits to a "
"potential stencil buffer."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:126
msgid ""
"Lastly, **we deactivate the stencil** by telling that it should neither "
"read nor write any of the bytes of the stencil buffer."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:134
msgid "Depth texture"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:137
msgid ""
"We must allocate the texture where the GPU stores the Z-buffer ourselves."
" I'm going to be quick on this part, as **we will come back on textures "
"later on**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:139
msgid ""
"We first create a texture that has the size of our swap chain texture, "
"with a usage of `RenderAttachment` and a format that matches the one "
"declared in `depthStencilState.format`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:173
msgid ""
"We also create a **texture view**, which is what the render pipeline "
"expects. In general a texture view represents a sub-part of a texture, "
"potentially exposed as a different format, but here we have a simple "
"texture and the view mostly represents the whole texture. Only the "
"`aspect` set to `DepthOnly` limits the scope of the view."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:205
msgid ""
"Like buffers, textures must be destroyed after use, and both views and "
"textures must be released:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:225
msgid ""
"Lastly, we need to update the required limits to state the maximum "
"texture size:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:235
msgid "Again, more on textures and texture views later!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:238
msgid "Depth attachment"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:241
msgid ""
"Like when attaching a color target or binding a uniform buffer, we define"
" an object to \"connect\" our depth texture to the render pipeline. This "
"is the `RenderPassDepthStencilAttachment`:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:267
msgid ""
"We must set up clear/store operations for the stencil part as well even "
"if we do not use it:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:315
#: ../../basic-3d-rendering/hello-triangle.md:461
#: ../../basic-3d-rendering/hello-triangle.md:491
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:402
#: ../../getting-started/first-color.md:72
#: ../../getting-started/the-device.md:222
msgid "Dawn"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:316
msgid ""
"When using the Dawn implementation of WebGPU, `stencilLoadOp` and "
"`stencilStoreOp` must be set to respectively `LoadOp::Undefined` and "
"`StoreOp::Undefined` instead."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:318
msgid ""
"Furthermore, a `clearDepth` attribute of `depthStencilAttachment` must be"
" turned to NaN (it's a backward compatibility thing):"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:326
#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:14
#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:14
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:41
#: ../../basic-3d-rendering/texturing/a-first-texture.md:417
#: ../../basic-compute/image-processing/mipmap-generation.md:295
msgid "Shader"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:329
msgid ""
"The last thing we need to do is to set up a depth for each fragment, "
"which we can do through the **vertex shader** (and the rasterizer will "
"interpolate it for each fragment):"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:335
msgid ""
"The depth value must be in the range $(0,1)$. We will build a proper way "
"to define it in the next chapter but for now let use simply remap our "
"`position.z` from its range $(-1,1)$ to $(0,1)$:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:344
msgid ""
"We now fixed the depth issue, and setup an important part of the 3D "
"rendering pipeline that we won't have to edit so much."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:349
msgid "The depth ordering issue is gone!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/index.md:1
msgid "3D Meshes"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:1
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:1
#: ../../basic-3d-rendering/texturing/loading-from-file.md:1
#: ../../basic-3d-rendering/texturing/texture-mapping.md:102
msgid "Loading from file"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:5
#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:234
msgid ""
"*Resulting code:* [`step058`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step058)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:9
#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:238
msgid ""
"*Resulting code:* [`step058-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step058-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:12
msgid ""
"This time, we are ready to load **an actual 3D file format** instead of "
"the ad-hoc one we have been using so far, so that you can play with any "
"model you'd like."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:14
msgid ""
"In this chapter we load 3D models from the "
"[OBJ](https://en.wikipedia.org/wiki/Wavefront_.obj_file) format. This is "
"a very common format for storing 3D meshes with extra attributes (vertex "
"colors, normals, but also texture coordinates and any other arbitrary "
"data). You can for instance create an OBJ file by exporting it from "
"[Blender](https://www.blender.org/)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:16
msgid "TinyOBJLoader"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:18
msgid ""
"Instead of manually parsing OBJ files, we use the "
"[TinyOBJLoader](https://github.com/tinyobjloader/tinyobjloader) library. "
"The file format is **not that complex**, but parsing files is not the "
"main point of this tutorial series, and this library has been intensively"
" tested and has a very small footprint."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:20
msgid ""
"Similarly to [our `webgpu.hpp` wrapper](/getting-started/cpp-idioms.md), "
"TinyOBJLoader is made of a single file "
"[`tiny_obj_loader.h`](https://raw.githubusercontent.com/tinyobjloader/tinyobjloader/release/tiny_obj_loader.h)"
" that you may simply save next to your `main.cpp`. Exactly one of your "
"source files must define `TINYOBJLOADER_IMPLEMENTATION` before including "
"it:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:27
msgid "We create a new loading function:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:33
msgid ""
"We can use [the example "
"code](https://github.com/tinyobjloader/tinyobjloader#example-code-"
"deprecated-api) from TinyOBJLoader's README as a base, that shows how to "
"call the `LoadObj` function it provides:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:64
msgid ""
"Once the tinyobj-specific structures are filled in (`shape_t`, "
"`attrib_t`), we can extract our vertex array data, making the code a bit "
"clearer:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:94
msgid ""
"We can generalize to all the parts of the model by iterating over "
"`shapes`:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:108
msgid "Loading a first object"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:110
msgid ""
"We stop using indexed drawing but switch to a vector of "
"`VertexAttributes` rather than a blind vector of `float` for the vertex "
"buffer data:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:162
msgid ""
"One last thing we need is to increase the maximum buffer size to be able "
"to load various meshes:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:169
msgid ""
"Test this with [pyramid.obj](../../data/pyramid.obj), which is the same "
"pyramid but with beveled edges (I also set the `T1 = mat4x4(1.0)` and "
"`focalPoint = vec3(0.0, 0.0, -1.0)`):"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:174
msgid "The 3D model is correctly loaded but not oriented as expected."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:178
msgid ""
"If you see a warning about missing material information when loading the "
"OBJ, do not worry:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:184
msgid ""
"OBJ files may have a companion .mtl file providing information about "
"materials but we do not use this information here."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:187
msgid "Vertical axis convention"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:189
msgid ""
"There is **no consensus** among 3D modeling and 3D rendering tools about "
"which axis should represent the vertical direction. But file formats "
"usually impose a convention. In the case of the OBJ format, it is "
"specified that **the Y axis represents the upward vertical direction**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:191
msgid ""
"Since we have been implicitly following the convention that **Z is the "
"vertical in our code**, we need to either change our convention (by "
"changing the view matrix) or convert upon loading. I chose the latter:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:211
msgid "The loaded 3D model, correctly oriented."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:214
msgid "Another example"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:216
msgid ""
"Want something a bit more interesting? Try "
"[mammoth.obj](../../data/mammoth.obj)! And thank the Smithsonian for "
"[sharing the model](https://sketchfab.com/3d-models/mammuthus-"
"primigenius-blumbach-229976b3db4646b39c44e57a7e3d8744)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:221
msgid "A complex 3D model."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:227
msgid ""
"This chapter concludes this part about loading and rendering 3D meshes. "
"It was quite of a part, congratulations for having followed so far!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:229
msgid ""
"From now on we will see how to improve on top of this base, but feel free"
" to take some time to **play around**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:231
msgid ""
"You can now load your own models (going through Blender to convert them "
"if you get them in a different file format), animate the position of "
"different objects, change the lighting (even animate it using uniforms), "
"etc."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:1
msgid "Projection matrices"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:5
#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:712
msgid ""
"*Resulting code:* [`step055`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step055)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:9
#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:716
msgid ""
"*Resulting code:* [`step055-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step055-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:12
msgid ""
"Now that we are familiar with the concept of matrices, we see how they "
"are used to represent projections, although a **perspective projection** "
"is neither a linear nor an affine transform so it is not exactly what "
"matrices are supposed to represent, mathematically speaking."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:14
msgid ""
"We also present in a second part a **typical way** of managing transform "
"and projection matrices from the C++ code, using the GLM library."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:16
msgid "Orthographic projection"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:19
msgid ""
"What have we been doing so far regarding the projection of the 3D scene "
"onto our 2D screen? The $x$ and $y$ coordinates of the output position "
"`out.position` is mapped to the window coordinates, and the $z$ "
"coordinate does not affect the pixel position of our geometry, so this is"
" **an orthographic projection along the Z axis**:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:25
msgid ""
"Remember that we had to remap the $z$ coordinate to the range $(0,1)$, "
"because anything outside this range is **clipped out**, the same way "
"anything outside the range $(-1,1)$ along the $x$ and $y$ axes falls "
"outside the window."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:41
msgid ""
"We call this the **clipping volume**. Only the geometry that lies inside "
"this volume after the vertex shader can produce **visible fragments**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:44
msgid ""
"The expected range for the output $z$ coordinate differs with the "
"graphics API. All modern APIs (DirectX 12, Metal, Vulkan, WebGPU) use "
"$(0,1)$ but OpenGL and WebGL expect $(-1,1)$. The projection matrices "
"have thus slightly different definitions."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:47
msgid ""
"Of course this orthographic projection can be easily represented as a "
"matrix:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:61
msgid ""
"Note that the coefficients $0.5$ in the matrix above come from the fact "
"that we want to remap Z coordinate from the range $(-1,1)$. In general, "
"if the $z$ coordinates of our model are in range $(n,f)$, we get "
"$z_{\\text{out}} = \\frac{z - n}{f - n} = \\frac{z}{f - n} - \\frac{n}{f "
"- n}$ and so the coefficients become $p_{zz} = \\frac{1}{f - n}$ and "
"$p_{zw} = \\frac{- n}{f - n}$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:63
msgid ""
"We can also change the range of view by dividing the XY size of the scene"
" to fit a larger part of it in the view frustum."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:78
msgid "Perspective projection"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:81
msgid "Focal point"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:83
msgid ""
"A perspective projection is (more or less) the projection that occurs "
"**in an actual camera** or a human eye. Instead of projecting the scene "
"onto a plane, it **projects onto a single point**, called the **focal "
"point**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:85
msgid ""
"The pixels of the screen correspond to different **incoming directions** "
"from which elements of geometry are projected."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:97
msgid ""
"If we want to map the perspective **view frustum** (i.e., the set of "
"visible directions) to the normalized clip space described above, we "
"**need to divide** the XY position by the $z$ coordinate. Let us take an "
"example:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:109
msgid ""
"The points $A$ and $C$ project along the same direction, so they should "
"have the same $y_\\text{out}$ coordinate. At the same time, the points "
"$A$ and $B$ have the same input $y$ coordinate."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:111
msgid ""
"The thing is that they have **different depths**, and as we know "
"**objects that are further away look smaller**. This is modeled by a "
"division by the depth:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:113
msgid ""
"\n"
"y_\\text{out} = \\frac{y}{z}\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:117
msgid ""
"Since $A$ and $B$ have different $z$, they end up at different "
"$y_\\text{out}$ coordinates, which means we see them in slightly "
"different directions (i.e., different pixels in the final image)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:119
msgid "We can try this out:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:151
msgid "Ta-dam, it works!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:153
msgid "Focal length"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:155
msgid ""
"Dividing by the raw $z$ coordinate was a bit arbitrary, and the formula "
"above is a bit suspicious because its terms are **not commensurable**: "
"$y_\\text{out}$ is a **length** (e.g., in meters or feet), but $y / z$ is"
" a **ratio** (unit-less). We can in fact scale the division factor:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:162
msgid "This corresponds to introducing the **focal length** $l$ in the formula:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:164
msgid ""
"\n"
"y_\\text{out} = l\\frac{y}{z}\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:169
msgid ""
"The focal length can be seen as **the distance between the focal point "
"and a virtual sensor** corresponding to the output window (can be "
"verified using Thales's theorem)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:188
msgid ""
"The focal length is a user parameter that corresponds to the **level of "
"zoom** of our virtual camera."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:193
msgid ""
"This lens ranges from focal length 18mm to 55mm, depending on how the "
"zoom ring is turned."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:197
msgid ""
"The projection depends only on **the ratio** between the **sensor size** "
"and the actual **focal length** (it is easy to see that if we multiply by"
" 2 the size of the sensor and move it twice as far from the focal point, "
"we get the same image)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:199
msgid ""
"As a consequence, commercial focal lengths are generally expressed for a "
"given **standard sensor size**, namely 35 mm along its diagonal (a size "
"called \"full frame\")."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:201
msgid ""
"Since our clip space has a width of 2 units (from -1 to 1), if we want "
"the visual look of a commercial 50 mm lens, we need to set our "
"`focalLength` to `2 * 50 / 35 = 2.86`. And actually with the `640/480` "
"ratio the diagonal of our clip space is `2.5` so the `focalLength` ends "
"up being `3.57`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:204
msgid "Perspective matrix"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:206
msgid ""
"Unfortunately, a perspective projection is **not a linear transform**, "
"because of the division by $z$. However, since this division is that "
"commonly used, it is embedded **in the fixed pipeline**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:208
msgid ""
"How didn't we notice it yet? Because for more flexibility it does not "
"divide by `out.position.z` but rather by `out.position.w`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:210
msgid ""
"We want $w$ to be `position.z / focalLength`, so in the projection matrix"
" `P` we set the coefficient $p_{wz}$ to `1.0 / focalLength`, and set the "
"last diagonal coefficient $p_{ww}$ to $0$ instead of $1$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:227
msgid "The $z$ coordinate itself is also divided by $w$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:233
msgid ""
"The projection is the same, but since the $z$ coordinate is also divided "
"by $w$, the depth information is messed up."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:236
msgid ""
"Before addressing this, we can notice that thanks to the hard-coded "
"division, our perspective projection **can be fully encoded as a "
"matrix**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:253
msgid ""
"The coefficients `p_zz` and `p_zw` used to be respectively `1.0 / (far - "
"near)` and `-near / (far - near)` so that $z_\\text{out}$ is in range "
"$(0,1)$. Now we need it to be in range $(0, w_\\text{out}) = (0, "
"\\frac{z_\\text{in}}{l})$ so that after the normalization by "
"$w_\\text{out}$ it ends up in $(0,1)$:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:255
msgid ""
"\n"
"\\left\\{\n"
"\\begin{align}\n"
"p_{zz} & = \\frac{f}{l(f - n)} \\\\\n"
"p_{zw} & = -\\frac{fn}{l(f - n)}\n"
"\\end{align}\n"
"\\right.\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:264
msgid "Proof"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:265
msgid ""
"For $z_\\text{in} = n$, the result is $z_\\text{out} = 0$, and for "
"$z_\\text{in} = f$, the result is $z_\\text{out} = "
"\\frac{z_\\text{in}}{l} = \\frac{f}{l}$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:267
msgid ""
"\n"
"\\left\\{\n"
"\\begin{align}\n"
"n p_{zz} + p_{zw} & = 0 \\quad\\quad (L_1)\\\\\n"
"f p_{zz} + p_{zw} & = \\frac{f}{l} \\quad\\quad (L_2)\n"
"\\end{align}\n"
"\\right.\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:276
msgid "Subtract $L_2 - L_1$ and $f L_1 - n L_2$:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:278
msgid ""
"\n"
"\\left\\{\n"
"\\begin{align}\n"
"f p_{zz} - n p_{zz} & = \\frac{f}{l} \\\\\n"
"f p_{zw} - n p_{zw} & = -\\frac{fn}{l}\n"
"\\end{align}\n"
"\\right.\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:287
msgid "Divide by $f - n$ and this lead to the result above."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:291
msgid ""
"(TODO: explain) This does not work if $n$ is **not null**. We must thus "
"set `near` to a small but non-zero value."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:312
msgid ""
"We are back to what we had with a manual division, only this time it's "
"all matrices!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:315
msgid ""
"Our matrix `P` as defined in the last code block is a **perspective "
"projection matrix**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:317
msgid ""
"The projection matrix is in general globally multiplied by `focalLength` "
"compared to our last formula:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:328
msgid ""
"This does not affect the end result because it also scales the $w$ "
"coordinate. Similarly, multiplying `out.position` by any value does not "
"change the end pixel of the vertex."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:331
msgid ""
"The value `out.position / out.position.w` that is computed by the fixed "
"pipeline is called the ***Normalized** Device Coordinate* (NDC). It is "
"this NDC that must fall within the normalized clipping volume described "
"above."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:335
msgid ""
"Mathematically, considering that two vectors are **equivalent** when they"
" are a multiple of each others (like we do here with `out.position`) "
"defines a [projective "
"space](https://en.wikipedia.org/wiki/Projective_space), namely a space of"
" directions. Its elements are represented by **homogeneous coordinates**,"
" called so to remind one that they are not unique, so they do not form a "
"regular (Euclidean) coordinate system."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:338
msgid "Matrix Uniforms"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:341
msgid "Coordinate systems"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:343
msgid ""
"Instead of building the same matrices for each vertex of each object of "
"the scene, we build them once and store them in a **uniform buffer**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:345
msgid "We can thus extend our uniform structure:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:371
msgid ""
"Remember the **alignment** rules: put the matrices first as they are "
"larger structures."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:374
msgid ""
"This is the occasion to more formally introduce **the typical way of "
"splitting the transform**. We could just store one single matrix $M$ that"
" would encode the whole transform from the input position to the output "
"clip position, but instead we separate it into a product of a **model** "
"matrix, then a **view** matrix, and then the **projection** matrix:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:381
msgid ""
"Changing the **projection** matrix corresponds to changing the virtual "
"camera that captures the scene. It happens rarely (unless we create zoom "
"in/out effects)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:383
msgid ""
"Changing the **view** matrix corresponds to moving and turning the "
"camera. It happens almost all the time, whenever the user interacts with "
"your tool/game usually."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:385
msgid ""
"Changing the **model** matrix corresponds to moving the object with "
"respect to the global scene, which is often called the **world**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:387
msgid ""
"As a consequence, we give a name to the intermediate **coordinate "
"systems** through which the position passes while being transformed:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:389
msgid ""
"`in.position` is the **local** coordinates, or **model coordinates** of "
"the object. It describes the geometry as if the object was alone and "
"centered around the origin."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:390
msgid ""
"`modelMatrix * in.position` gives the **world** coordinates of the "
"points, telling where it is relatively to a global static frame."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:391
msgid ""
"`viewMatrix * modelMatrix * in.position` gives the **camera** "
"coordinates, or **view** coordinates. This is the coordinates of the "
"point as seen from the camera. You can think of it as if instead of "
"moving the eye, we actually move and rotate the whole scene in the "
"opposite direction."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:392
msgid ""
"And finally multiplying by `projectionMatrix` applies the projection, "
"either orthographic or perspective, to give us **clip** coordinates."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:393
msgid ""
"Afterwards, the fixed pipeline divides the clip coordinates by its $w$, "
"which gives the **NDC** (normalized device coordinates)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:396
msgid ""
"In order to alleviate notations I omitted above the fact that we actually"
" use the homogeneous coordinates `vec3f(in.position, 1.0)` as the input "
"of the transform."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:399
msgid "Precomputing"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:401
msgid ""
"For now the content of the matrices is **precomputed on the CPU** and "
"then uploaded, but this could also be done in a compute shader, as we "
"will see in [the compute part](/basic-compute/index.md) of this "
"documentation."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:403
msgid ""
"Make sure to lift the device limit on the uniform buffer size, and define"
" a value for the matrices:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:417
msgid ""
"Remember that we added a `transpose` operation all the time. Make sure to"
" flip the coefficient along the matrices compared to our definitions "
"above."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:420
msgid ""
"ðŸ˜’ Ahem this is a bit annoying, couldn't we rather define this `transpose`"
" operation? What about the matrix multiplication?"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:422
msgid ""
"Yes we could, or we could even reuse what has already been done! Which "
"leads us to the GLM library."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:424
msgid "GLM"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:426
msgid ""
"The [GLM](https://github.com/g-truc/glm) library reproduces the "
"matrix/vector types and operations that are available in shaders, so that"
" we can **easily port code** between C++ and shaders."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:428
msgid ""
"It was originally designed to be as close as possible to the GLSL syntax,"
" which is close in features to WGSL (although type names are slightly "
"different). It is widely used, supported on multiple platforms, "
"battlefield-tested, header-only (so easy to integrate)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:430
#: ../../getting-started/hello-webgpu.md:80
msgid "Integration"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:432
msgid ""
"Here is a stripped down version of GLM: "
"[glm.zip](../../data/glm-0.9.9.8-light.zip) (392 KB, as opposed to the "
"5.5 MB of the official release). Unzip this directly into your source "
"tree. You can include it as follows:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:439
msgid ""
"Make sure to add the main source directory to the include path in your "
"`CMakeLists.txt`, as some compiler require it to use the `<...>` brackets"
" in include directives:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:446
#: ../../getting-started/opening-a-window.md:58
msgid "Basic usage"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:448
msgid ""
"Everything GLM defines is contained in the `glm` namespace. You can "
"either use it globally with a `using namespace glm;` or import individual"
" types:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:465
msgid ""
"The `mat4x4` type of GLM corresponds to WGSL's `mat4x4f`. The equivalent "
"of `mat4x4<f64>` is `dmat4x4`, with the prefix `d` for `double`. It also "
"has an alias called `mat4` to correspond to GLSL, which you might like as"
" it is less characters to type. The same goes for vectors (`vec3` is "
"`vec3f`) for integers (`ivec2` is WGLS's `vec2<i32>`), etc."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:468
msgid ""
"It is thus easy to reproduce what we were doing in WGSL. Let's start with"
" the **model** transform:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:503
msgid ""
"Then comes the **view** transform. Do not forget to include the "
"translation of the focal point (which we did not represent as a matrix "
"product above but the conversion is straightforward):"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:531
msgid "And finally the projection:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:547
msgid "The vertex shader simply becomes:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:558
msgid ""
"I am not putting the image again, you should still obtain the same "
"result. Only this time it is **much less energy consuming** since "
"matrices are computed only once, instead of once per vertex and per frame"
" (which can easily count in millions or more in a practical scenario)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:560
msgid "Extensions"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:562
msgid ""
"The construction of **atomic matrices** like translations, rotations, "
"scaling or perspective is something that is very common. Yet it is not "
"part of the built-in functions of WGSL because, as we just saw, we are "
"not supposed to do it in the shader code."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:564
msgid ""
"Since GLM intends to reproduce the types of the shader languages, it does"
" not include those neither. At least not in the `glm/glm.hpp`. But it "
"does in its **extensions**, which we can include like this:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:570
msgid "The construction of the model and view matrices becomes as simple as this:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:583
msgid ""
"Note that transformation functions provided by GLM all take an input "
"matrix to transform, in order to spare us a matrix multiplication. Here "
"we always use the **identity** matrix `mat4x4(1.0)` to build atomic "
"transforms, but the model matrix above could have also been built this "
"way:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:593
msgid ""
"I personally find it harder to read though, because we must apply the "
"operations in reverse."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:596
msgid ""
"The `rotate` function enables one to turn around any axis (the second "
"argument) instead of being limited to the X, Y and Z axes like we did "
"when manually building rotation matrices."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:599
msgid ""
"GLM extensions also provide a procedure for building **projection "
"matrices**, and in particular a perspective projection:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:609
msgid ""
"It has almost the same parameters as we used, except that instead of a "
"**focal length**, it uses a **field of view** argument, a.k.a. **fov**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:612
msgid ""
"There are actually two *hidden* settings that the `perspective` function "
"depends on and which we **must take care of**. Both of these settings are"
" enabled globally by defining preprocessor variables before including "
"GLM:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:620
msgid ""
"The first one is `GLM_FORCE_DEPTH_ZERO_TO_ONE`, which tells GLM that the "
"clip volume's Z range is $(0,1)$. By default, it assumes that it is "
"$(-1,1)$ because this is the convention that was used by OpenGL, which is"
" different from WebGPU."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:622
msgid ""
"The second one is the `GLM_FORCE_LEFT_HANDED` to mean that our view space"
" uses a **left-handed coordinate system**. This is the choice that we "
"have implicitly adopted so far because the clip space is left-handed. "
"Switching to a right-handed system is possible, in which case be aware "
"that the camera looks in the direction -Z of the view space instead of "
"+Z."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:626
msgid ""
"You may also define these settings globally in your `CMakeLists.txt` with"
" `target_compile_definition` in order to ensure that they are consistent "
"across all of your files."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:629
msgid "Back to the field of view: it is directly related to the focal length:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:641
msgid ""
"We can see from this figure that $\\tan\\frac{\\alpha}{2} = "
"\\frac{1}{l}$, which gives us the following **conversion rules** between "
"focal length and field of view:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:643
msgid ""
"\n"
"\\begin{align}\n"
"l & = \\frac{1}{\\tan(\\alpha/2)} = \\cot\\frac{\\alpha}{2} \\\\\n"
"\\alpha & = 2 \\arctan\\frac{1}{l}\n"
"\\end{align}\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:650
msgid ""
"Most probably you will use either fov or focal length and stick to it so "
"there will be no need for conversion! We can still check that our formula"
" gives again the same result:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:658
msgid ""
"The field of view expected by `glm::perspective` must be expressed in "
"**radians**. If you want to set it to $45\\deg$ (which is a common "
"value), you must set `fov = 45 * PI / 180`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:664
msgid "Still looking the same... but we make our code base so much more robust!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:667
msgid "ðŸ˜Ÿ Hey it's no longer turning around for me..."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:669
msgid "You need to update the model matrix in the main loop!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:700
msgid "In this quite mathematical chapter, we have seen fundamental points:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:702
msgid ""
"**Projections** (either orthographic or perspective) can be **encoded as "
"matrices** thanks to the coordinate normalization performed by the fixed "
"pipeline (the division by $w$)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:703
msgid ""
"A **perspective** projection is parameterized either by a **focal "
"length** or a **field of view**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:704
msgid ""
"Transform matrices (mode, view, projection) should be computed once and "
"stored in a **uniform buffer** to avoid unnecessary costly computation."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:705
msgid ""
"The GLM library provides us with all we need to easily compute these "
"matrices on the CPU side."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:708
msgid ""
"The GLM library is focused on vector and matrices up to the 4th "
"dimension. For linear algebra of higher dimensions, I usually turn to the"
" [Eigen](https://eigen.tuxfamily.org) library instead, but we won't need "
"it here."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:1
msgid "Transformation matrices"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:5
#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:423
msgid ""
"*Resulting code:* [`step054`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step054)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:9
#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:427
msgid ""
"*Resulting code:* [`step054-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step054-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:12
msgid ""
"We have been manipulating **transforms** in our shader code at multiple "
"occasions already: offset of the 2D scene, viewport ratio, rotation of "
"the 3D object. This chapter presents **a proper and unified way** of "
"handling these. This will lead us in the next part to the introduction of"
" the **perspective** transform!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:14
msgid ""
"This chapter introduces **mathematical concepts**. But **don't worry** if"
" you do not feel comfortable with math: I try to introduce it as smoothly"
" as possible and to always justify its use. Think of it as a way to "
"**learn math thanks to 3D** and not the other way around!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:16
msgid "A common formalism"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:19
msgid ""
"Let us summarize the **various cases of transforms** that we have "
"encountered in the previous chapters:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:39
msgid ""
"There is **not much difference** between moving the object and moving the"
" viewpoint. The line `position.x += 0.25` can be seen either as **moving "
"the object forward** along the X axis or **moving the viewpoint "
"backwards** along the X axis. But as soon as we have multiple objects "
"and/or light sources, this distinction becomes relevant."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:42
msgid ""
"We can actually unify these transforms under a **common formalism**. "
"First of all, we can see both the object and screen projection as **a "
"scaling plus a translation**:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:59
msgid ""
"What about the **rotation**? We need a bit more than a vector scaling for"
" this, because we **mix multiple axes**. And this is exactly what a "
"**matrix** is for!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:61
msgid "Matrices"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:64
#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:32
msgid "Definition"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:66
msgid ""
"A matrix is a **double entry table** that describes a way to build a new "
"vector by **linearly mixing** the coordinates of an input vector. **Each "
"row** of the matrix lists the mixing coefficients to build one of the "
"output coordinates."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:82
msgid ""
"The $i$-th row describes the $i$-th output coordinate. And on each row, "
"the $j$-th coefficient tells how much of the input's $j$-th coordinate we"
" must mix."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:85
msgid ""
"The term **\"linearly\"** just means that we can only scale and add input"
" coordinates. We cannot for instance multiply $x$ by $y$. In general "
"linear coordinate mixes have the form $\\alpha x + \\beta y + \\gamma z$ "
"where $\\alpha$, $\\beta$ and $\\gamma$ are predefined factors "
"(coefficients of the matrix)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:88
msgid "Scaling matrix"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:90
msgid ""
"Let us see a simple example first: **scaling** a vector consists in "
"applying a diagonal matrix, because the $i$-th coordinate of the scaled "
"vector only depends on the $i$-th coordinate of the input one:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:92
msgid ""
"\n"
"M = \\left(\n"
"\\begin{array}{ccc}\n"
"1.0 & 0 & 0 \\\\\n"
"0 & \\text{ratio} & 0 \\\\\n"
"0 & 0 & 0.5\n"
"\\end{array}\n"
"\\right)\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:102
msgid ""
"The application of the transform described by the matrix to a vector is "
"denoted as a **product**: $b = M \\times a$ or just $b = Ma$, and `M * a`"
" in code means \"transform the position $a$ using the matrix $M$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:105
msgid ""
"This choice of notation results from the fact that this operation behaves"
" in many ways **like a multiplication** between two numbers (more details"
" later). But note however that it is **not fully the same**. In "
"particular, we cannot swap the operand and write $x \\times M$ (it is "
"called *non-commutative*)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:123
msgid ""
"WGSL (like GLSL and HLSL) expects the arguments of the `mat3x3f` "
"constructor to be given **column by column**, despite the fact that they "
"**visually appear in rows** in our source code. Instead of always "
"thinking in mirror, which is quite prone to error, I added a `transpose` "
"operation after the creation of the matrix in order to **flip it along "
"its diagonal**. It does not make a difference for a diagonal matrix like "
"this one, but this is very important in general."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:127
msgid ""
"The matrix with 1.0 on the diagonal and 0.0 anywhere else is called the "
"**identity matrix** $I$ and has a very special property: it changes "
"nothing ($Ix = x$ for any vector $x$)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:130
msgid "Rotation matrix"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:132
msgid ""
"For a simple scale, matrices seem a bit overkill, but it becomes "
"interesting when we want to **encode a rotation**:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:156
msgid ""
"Perfect, this matrix-based formalism enable us to **represent both "
"scaling and rotation**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:158
msgid "Homogeneous coordinates"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:161
msgid ""
"But what about the **translation**? There is **good and bad news**. The "
"bad is that a $3 \\times 3$ matrix **cannot encode a translation**. The "
"good is that a $4 \\times 4$ matrix can!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:163
msgid ""
"Let me explain: the matrix tells how to transform a vector by mixing its "
"coordinate with each others. But it does **not allow to add** anything to"
" the mix that is a **constant** value (i.e., something that does not "
"depend on an input coordinate)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:166
msgid ""
"A matrix represents what is known as a **linear transform**, which also "
"gives its name to the whole field of **linear algebra** by the way. The "
"combination of a linear transform with a translation is called an "
"**affine transform**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:169
msgid ""
"How do we address this? We add **an extra coordinate that is meant to "
"always equal 1**. Adding a constant value $t$ now corresponds to adding "
"$t$ times the 4th coordinate and is thus a \"legal\" mix:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:186
msgid ""
"Mathematically, the code above makes sense: a non-square 3x4 matrix takes"
" an input vector of size 4 and returns an output of size 3. However, "
"**WGSL only supports square matrices** (and so do other shading "
"languages)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:189
msgid ""
"There would anyway be only little use of non-square matrices, because "
"this prevents us from **chaining transforms**. Instead of returning a "
"vector $(x, y, z)$, we would rather return the vector $(x, y, z, 1.0)$ so"
" that we may apply again another transform. This should be easy:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:207
msgid ""
"Notice how the upper-left $3 \\times 3$ quadrant is the **identity "
"matrix**. This part of the $4 \\times 4$ matrix corresponds to the scale "
"and/or rotation (and/or skew)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:210
msgid ""
"It is important to note that this 4th coordinate is **not just a hack** "
"for storing the translation on top of the linear transform. Everything "
"behaves as if there was a 4th dimension, so all the nice **mathematical "
"properties** about matrices **still hold**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:212
msgid ""
"As long as the last coordinate remains $1.0$, these vectors still "
"represent 3D points. This is called the **_homogeneous coordinate_** of "
"the point, and we'll understand why better when talking about "
"perspective!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:214
msgid "Composition"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:217
msgid ""
"Matrices provide a common way to represent rotation, scaling and "
"translation. But the power of matrices gets even crazier when we start "
"**composing** them!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:219
msgid "Product"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:221
msgid ""
"For instance if we want to combine a scaling and a translation, we can "
"manually coin a matrix that does both:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:241
msgid ""
"But this can be **tedious** when it comes to mixing rotations for "
"instances. We can instead reuse our previous atomic matrices and combine "
"them together with a **matrix multiplication**:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:267
msgid "There are a few **important** things to note here:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:269
msgid "`M` is `T * S` in **this order**, and this is different from `S * T`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:270
msgid "This product **reads backwards**: we apply `S` **then** `T`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:271
msgid ""
"The matrix-matrix product `T * S` is a matrix obtained by taking each "
"column of `S` and transforming it with `T` as if it was a vector."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:273
msgid "**Why does this work?** We can decompose it:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:282
msgid ""
"We can directly write `c = T * (S * a)`, and the math tells us that we "
"can actually evaluate the products with a different precedence: `c = (T *"
" S) * a`. This is why applying the transform `M = T * S` is equivalent to"
" applying `S` **then** `T`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:285
msgid ""
"This change from `T * (S * a)` to `(T * S) * a` is called the "
"**associativity**. It is a property that the matrix multiplication shares"
" with the real multiplication, and thus one of the motivations for using "
"the same notation. The matrix multiplication is however not "
"*commutative*."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:289
msgid ""
"In this case applying `T` before `S` would lead to an overall translation"
" of only $0.125$ (half $0.25$) because the translation would be affected "
"by the scaling."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:292
msgid "Rotations"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:294
msgid ""
"Equipped with this new multiplication tool, we can start experimenting "
"with more complex transforms that were hard to define before. A good "
"example is the **combination of 2 rotations along different axes**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:310
msgid ""
"We can define these two transforms independently as matrices, then simply"
" multiply them together:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:348
msgid ""
"This example would have been quite hard to create manually. Furthermore, "
"we will see that it is very useful to keep the model transform separate "
"from the view angle."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:351
msgid "The formula to directly create the matrix `R2 * R1` is:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:361
msgid ""
"This is really **not an intuitive result**, which shows how helpful it is"
" to see combined transforms as matrix multiplications."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:364
msgid "More advanced example"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:366
msgid ""
"We finish this chapter by a little exercise of matrix combination: could "
"you **guess** how to obtain this following transform?"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:369
msgid "The view angle is that same as in the previous example."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:381
msgid "**Answer** We obtain this by applying in this order:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:383
msgid "A scaling of factor $0.3$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:384
msgid "A translation of $0.5$ along the $x$ axis."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:385
msgid "The animated rotation R1."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:386
msgid "The view angle rotation R2."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:412
msgid ""
"Rotations always occur **around the origin** point (the one of "
"coordinates $(0,0,0)$). To rotate around a different point, combine a "
"rotation with one translation before and one after."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:418
msgid ""
"This was an important chapter, that justifies why **matrices are so "
"useful in the graphics pipeline**, and explains why we manipulate $4 "
"\\times 4$ matrices even if we are only in 3D."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:420
msgid ""
"The next chapter is still about matrices, but this time for the final "
"**perspective projection**."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:1
msgid "Hello Triangle"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:5
#: ../../basic-3d-rendering/hello-triangle.md:506
msgid ""
"*Resulting code:* [`step030`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step030)"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:9
#: ../../basic-3d-rendering/hello-triangle.md:510
msgid ""
"*Resulting code:* [`step030-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step030-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:12
msgid "In its overall outline, drawing a triangle is as simple as this:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:32
msgid ""
"What is a bit verbose is the configuration of the **render pipeline**, "
"and the creation of **shaders**. This is done only once when initializing"
" the application."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:34
msgid "Render Pipeline"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:37
msgid ""
"In order to achieve high performance real-time 3D rendering, the GPU "
"processes shapes through a predefined pipeline. The pipeline itself is "
"**always the same** (it is generally burnt into the physical architecture"
" of the hardware), but we can **configure** it in many ways. To do so, "
"WebGPU provides a *Render Pipeline* object."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:40
msgid ""
"If you are familiar with OpenGL, you can see WebGPU's render pipeline as "
"a memorized value for all the stateful functions that configure the "
"rendering pipeline."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:43
msgid ""
"The figure below illustrates the sequence of data processing **stages** "
"executed by the render pipeline. Most of them are **fixed-function** "
"stages, for which we can only customize some variables, but the most "
"powerful ones are the **programmable stages**."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:45
msgid ""
"In these programmable stages, a true program, called a **shader**, is "
"executed in a massively parallel way (across input **vertices**, or "
"across rasterized **fragments**)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:62
msgid ""
"Other graphics APIs provide access to more programmable stages (geometry "
"shader, mesh shader, task shader). These are not part of the Web "
"standard. They might be available in the future as native-only "
"extensions, but in a lot of cases one can use general purpose [compute "
"shaders](../basic-compute/index.md) to mimic their behavior."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:65
msgid "As always, we build a descriptor in order to create the render pipeline:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:84
msgid ""
"We now detail the configuration of the different stages. We start with a "
"very minimal setup where we leave a lot of features unused, they will be "
"introduce progressively in the next chapters."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:86
msgid "Vertex pipeline state"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:88
msgid ""
"Both the **vertex fetch** and **vertex shader** stages are configured "
"through the **vertex state** structure, accessible at "
"`pipelineDesc.vertex`."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:90
msgid ""
"The render pipeline first **fetches vertex attributes** from some "
"buffers. This includes usually at least a position, and might include "
"additional per-vertex information like color, normal, texture coordinate,"
" etc. In this first example, we hard-code the position of the 3 vertices "
"of the triangles in shaders so we do not even need a position buffer."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:97
msgid ""
"Then each vertex is processed by a custom **vertex shader**. A shader is "
"the combination of:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:99
msgid "A **shader module**, which contains the actual code of the shader."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:100
msgid ""
"An **entry point**, which is the name of the function in the shader "
"module that must be called for each vertex. This enables a given shader "
"module to include entry points for multiple render pipeline "
"configurations at the same time. In particular, we use the same module "
"for the vertex and fragment shaders."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:101
msgid ""
"An array of value assignments for the **constants** of the shader. We do "
"not use any for now."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:110
msgid "The `shaderModule` will be defined in [the next section](#shaders)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:112
msgid "Primitive pipeline state"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:114
msgid ""
"The **primitive state** structure found at `pipelineDesc.primitive` "
"configures the **primitive assembly** and **rasterization** stages."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:116
msgid ""
"The **rasterization** is the very heart of the 3D rendering algorithm "
"implemented by a GPU. It transforms a **primitive** (a point, a line or a"
" triangle) into a series of **fragments**, that correspond to the pixels "
"covered by the primitive. It **interpolates** any extra attribute output "
"by the vertex shader, such that each fragment receives a value for all "
"attributes."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:118
msgid ""
"The primitive assembly configuration consists in stating how the array of"
" vertices fetched earlier must be connected to for either a point cloud, "
"a wire frame or a triangle soup. We set it to its default configuration:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:163
msgid ""
"Usually we set the cull mode to `Front` to avoid wasting resources in "
"rendering the inside of objects. But for beginners it can be very "
"frustrating to see nothing on screen for hours only to discover that the "
"triangle was just facing in the wrong direction, so I advise you to set "
"it to `None` when developing."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:166
msgid "Fragment shader"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:168
msgid ""
"Once a primitive have been turned into fragments, the **fragment shader**"
" stage is invoked for each one of them. This shader receives the "
"interpolated values generated by the vertex shader, and must output on "
"its turn the **final color** of the fragment."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:171
msgid ""
"Keep in mind that all these stages are happening in a very parallel and "
"asynchronous environment. When rendering a large mesh, the fragment "
"shader for the first primitives may be invoked before the last primitives"
" have been rasterized."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:174
msgid ""
"The configuration is very similar to the configuration of the vertex "
"shader:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:200
msgid ""
"Note that the fragment stage is optional, so `pipelineDesc.fragment` is a"
" (potentially null) pointer instead of directly holding the fragment "
"state structure."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:202
msgid "Stencil/Depth state"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:204
msgid ""
"The **depth test** is used to discard fragments that are **behind** other"
" fragments associated to the same pixel. Remember that a fragment is the "
"projection of a given primitive on a given pixel, so when primitives "
"overlap each others, multiple fragments are emitted for the same pixel. "
"Fragments have a **depth** information, which is used by the depth test."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:206
msgid ""
"The stencil test is another fragment discarding mechanism, used to hide "
"fragments based on previously rendered primitives. Let's ignore the depth"
" and stencil mechanism for now, we will introduce them in the [Depth "
"buffer](3d-meshes/depth-buffer.md) chapter."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:212
msgid "Blending"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:214
msgid ""
"The blending stage takes each fragment's color and \"paints\" it onto the"
" target color attachment. If the original color in the **destination** "
"pixel is $(r_d, g_d, b_d, a_d)$ and the color of the **source** fragment "
"to paint is $(r_s, g_s, b_s, a_s)$, what should be the final color $(r, "
"g, b, a)$ of the final pixel? This is what the **blend state** specifies."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:216
msgid ""
"We must also specify what **format** (i.e., how to represent the values "
"as zeros and ones) the colors are to be stored in the final attachment."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:252
msgid ""
"The blending equation can be set independently for the rgb channels and "
"the alpha channel, in general, it takes the following form:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:254
msgid ""
"\n"
"rgb = \\texttt{srcFactor} \\times rgb_s ~~[\\texttt{operation}]~~ "
"\\texttt{dstFactor} \\times rgb_d\n"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:258
msgid ""
"The usual **alpha blending** equation is configured as $rgb = a_s \\times"
" rgb_s + (1 - a_s) \\times rgb_d$"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:276
msgid "And similarly for the alpha channel:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:278
msgid ""
"\n"
"a = \\texttt{srcFactor} \\times a_s ~~[\\texttt{operation}]~~ "
"\\texttt{dstFactor} \\times a_d\n"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:282
msgid ""
"For instance we can leave the target alpha untouched: $a = a_d = 0 "
"\\times a_s + 1 \\times a_d$"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:300
msgid "Multi-sampling"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:302
msgid ""
"I said previously that a fragment is the portion of a primitive that is "
"projected onto a specific pixel. Actually, we can split pixels into sub-"
"elements, called **samples**, and the fragment is associated to a sample."
" The value of a pixel is computed by averaging its associated samples."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:304
msgid ""
"This mechanism is called multi-sampling and is used for anti-aliasing, "
"but we'll leave it off for now by setting the number of sample per pixel "
"to 1."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:315
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:245
msgid "Shaders"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:318
msgid ""
"Both the vertex and fragment programmable stages use the same **shader "
"module**, that we must first create. This module is a kind of dynamic "
"library, like a .dll, .so or .dylib file, except that it talks the binary"
" language of your GPU rather than your CPU's."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:320
msgid ""
"Like any compiled program, the shader is first written in a **human-"
"writable programming language**, then compiled into low-level machine "
"code. However, the low-level code is highly hardware-dependent, and often"
" not publicly documented. So the application is distributed with the "
"**source code** of the shaders, which is **compiled on the fly** when "
"initializing the application."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:322
msgid "Shader code"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:324
msgid ""
"The shader language officially used by WebGPU is called "
"[WGSL](https://gpuweb.github.io/gpuweb/wgsl/), namely the *WebGPU Shading"
" Language*. Any implementation of WebGPU must support it, and the "
"JavaScript version of the API only supports WGSL, but the native header "
"`webgpu.h` also offers the possibility to provide shaders written in "
"[SPIR-V](https://www.khronos.org/spir) or "
"[GLSL](https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)) (`wgpu-"
"native` only)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:327
msgid ""
"**SPIR-V** is more of an intermediate representation, a **bytecode**, "
"than something that one would write manually. It is the shader language "
"used by the Vulkan API and a lot of tools exist to **cross-compile** code"
" from other common shader languages (HLSL, GLSL) so it is an interesting "
"choice when one needs to reuse **existing shader code bases**."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:331
msgid ""
"Also note that WGSL has been designed to be a human-editable version of "
"SPIR-V programming model, so **transpilation** from SPIR-V to WGSL is "
"efficient and lossless (use [Naga](https://github.com/gfx-rs/naga) or "
"[Tint](https://dawn.googlesource.com/tint) for this)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:334
msgid ""
"In this documentation we mostly use WGSL. Its syntax may seem a bit "
"unfamiliar if you are used to C/C++ so let us start with a very simple "
"function and its equivalent in C++:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:352
msgid ""
"Notice how the **types** are specified **after** instead of **before** "
"the argument names. The type of `z` is automatically inferred, though we "
"could have forced it using `let z: f32 = ...`. The return type is "
"specified after the arguments, using the arrow `->`."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:355
msgid ""
"The keyword `let` defines a constant, i.e., a variable that cannot be "
"reassigned. A regular variable is defined using the `var` keyword."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:358
msgid "Now here is the shader for our triangle:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:380
msgid ""
"The function names `vs_main` (resp. `fs_main`) must have the very same "
"name as what was specified as `entryPoint` in the vertex (resp. fragment)"
" state."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:383
msgid ""
"Shader languages natively support **vector and matrix types** up to size "
"4. The type `vec2f` is a vector of 2 floats, and an **alias** for the "
"*templated* type `vec2<f32>`. As another example, the type `vec4<u32>` is"
" a vector of 4 unsigned integers and has alias `vec4u`."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:386
msgid ""
"Tokens that start with an `@` are called **attributes** and decorate the "
"object that comes afterward with various information. For instance, "
"`@builtin(vertex_index)` tells that the argument `in_vertex_index`, which"
" could have any name, will be populated by the **built-in** input vertex "
"attribute that is the vertex index. We use it to set the output value of "
"the shader, which is labelled with `@builtin(position)` as something that"
" must be interpreted by the rasterizer as the vertex position."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:388
msgid ""
"For more flexibility, the shader code should be loaded from a file, but "
"for now we simply store it in a multi-line string literal in our "
"`main.cpp`:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:396
msgid "Creation of a shader module"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:398
msgid "The creation of the shader module starts as usual:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:416
msgid ""
"At first glance, this descriptor seems to have only an array of "
"compilation \"hints\" to fill, which we leave empty (and even nothing at "
"all when using Dawn):"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:425
msgid "But this time, we do **not** set `nextInChain` to `nullptr`!"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:427
msgid ""
"The `nextInChain` pointer is the entry point of WebGPU's **extension "
"mechanism**. It is either null, or pointing to a structure of type "
"`WGPUChainedStruct`. This structure is very simple. First it may "
"recursively have a `next` element (again, either null or pointing to some"
" `WGPUChainedStruct`). Second, it has a **struct type** `sType`, which is"
" an enum telling in which struct the chain element can be cast. Each "
"struct whose definition starts with a field `WGPUChainedStruct chain` has"
" an associated SType."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:429
msgid ""
"To create a shader module from WGSL code, we use the "
"`ShaderModuleWGSLDescriptor` SType. A SPIR-V shader can similarly be "
"created using the `WGPUShaderModuleSPIRVDescriptor`."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:431
msgid ""
"The field `shaderCodeDesc.chain` corresponds to the chained struct when "
"cast as a simple `WGPUChainedStruct`, which must be set to the "
"corresponding SType enum value:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:455
msgid "Finally we can setup the actual payload of the shader code descriptor:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:462
msgid ""
"The Dawn implementation of WebGPU does not include the "
"`hints`/`hintCount` in the shader module descriptor."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:465
#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:175
#: ../../basic-compute/compute-pipeline.md:171
msgid "Pipeline layout"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:467
msgid ""
"One last thing before we can run our code: the shaders might need to "
"**access input and output resources** (buffers and/or textures). These "
"resources are made available to the pipeline by configuring a memory "
"**layout**. Our first example does not use any resource:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:474
msgid ""
"Actually, setting the pipeline layout to `nullptr` does not mean that "
"there is no input/output resources. It rather asks the backend to "
"**figure out the layout** by itself by inspecting the shader (which in "
"this very case is equivalent)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:480
msgid ""
"This chapter introduced the core skeleton for rendering triangle-based "
"shapes on the GPU. For now these are 2D graphics, but once everything "
"will be in place, switching to 3D will be straightforward. We have seen "
"two very important concepts:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:482
msgid ""
"The **render pipeline**, which is based on the way the hardware actually "
"works, with some parts fixed, for the sake of efficiency, and some parts "
"are programmable."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:483
msgid ""
"The **shaders**, which are the GPU-side programs driving the programmable"
" stages of the pipeline."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:488
msgid "Our first triangle rendered using WebGPU."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:492
msgid ""
"When using Dawn, you may see different colors, because the target surface"
" use a **different color space**. More on this [later on](input-geometry"
"/loading-from-file.md#color-issue)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:495
msgid "What's next?"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:497
msgid ""
"The key algorithms and techniques of computer graphics used for 3D "
"rendering are for a large part implemented in the shaders code. What we "
"still miss at this point though is ways to **communicate** between the "
"C++ code (CPU) and the shaders (GPU)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:499
msgid ""
"The next two chapters focus on two ways to **feed input** to this render "
"pipeline: **vertex** attributes, where there is one value per vertex, and"
" **uniforms**, which define variable that are common to all vertices and "
"fragments for a given call."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:501
msgid ""
"We then take a break away from pipeline things with the switch to **3D "
"meshes**, which is in the end less about code and more about math. We "
"also introduce a bit of **interaction** with a basic **camera "
"controller**. We then introduce a 3rd way to provide input resource, "
"namely **textures**, and how to map them onto meshes."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:503
msgid ""
"Storage textures, which are used the other way around, to get data out of"
" the render pipeline, will be presented only in advanced chapters. "
"Instead, the last chapter of this section is fully dedicated to the "
"computer graphics matter of **lighting** and **material modeling**."
msgstr ""

#: ../../basic-3d-rendering/index.md:1
msgid "Basic 3D Rendering"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:1
msgid "A first Vertex Attribute"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:5
#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:388
msgid ""
"*Resulting code:* [`step032`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step032)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:9
#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:392
msgid ""
"*Resulting code:* [`step032-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step032-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:12
msgid ""
"This chapter presents a proper way to feed data as **input to the *vertex"
" shader***."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:17
msgid ""
"Remember that we do **not** control the way the `vs_main` function is "
"invoked, the fixed part of the render pipeline does. However, we can "
"**request** some input data by labeling the argument of the function with"
" **WGSL attributes**."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:19
msgid "Actually we do this already, with the `@builtin(vertex_index)` attribute:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:28
msgid ""
"This means that the argument `in_vertex_index` must be populated by the "
"vertex fetch stage with the index of the current vertex."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:31
msgid ""
"Attributes that are built-in can be found in [the WGSL "
"documentation](https://gpuweb.github.io/gpuweb/wgsl/#builtin-values)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:34
msgid ""
"Instead of using a built-in input, we can create our own. For this we "
"need to:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:36
msgid ""
"Create a **buffer** to store the value of the input for each vertex; this"
" data must be stored on the GPU side of course."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:37
msgid ""
"Tell the render pipeline how to interpret the raw buffer data when "
"fetching an entry for each vertex. This is the vertex buffer **layout**."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:38
msgid "Set vertex buffer in the render pass before the draw call."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:40
msgid "On the shader side, we replace the vertex index argument with a new one:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:49
msgid ""
"The `@location(0)` attribute means that this input variable is described "
"by the vertex attribute in the `pipelineDesc.vertex.buffers` array. The "
"type `vec2f` must comply with what we will declare in the layout. The "
"argument name `in_vertex_position` is up to you, it is only internal to "
"the shader code!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:52
msgid ""
"The term *attribute* is used for two different things. We talk about "
"**WGSL attribute** to mean tokens of the form `@something` in a WGSL "
"code, and about **vertex attribute** to mean an input of the vertex "
"shader."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:55
msgid "The vertex shader becomes really simple in the end:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:63
msgid "Device capabilities"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:66
msgid "ðŸ¤“ Hey what is the maximum number of location attributes?"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:68
msgid ""
"Glad you asked! The number of vertex attributes available for our device "
"may vary if we do not specify anything. We can check it as follows:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:103
msgid ""
"The spirit of the adapter + device abstraction provided by WebGPU is to "
"first check on the adapter that it has the capabilities we need, then we "
"**require** the minimal limits we need during the device creation and if "
"the creation succeeds we are **guarantied** to have the limits we asked "
"for."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:105
msgid ""
"And we get nothing more than required, so that if we forget to update the"
" initial check when using more vertex buffers, the program fails. With "
"this **good practice**, we limit the cases of *\"it worked for me\"* "
"where the program runs correctly on your device but not on somebody "
"else's, which can quickly become a nightmare."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:107
msgid ""
"This initial check is done by specifying a non null `requiredLimits` "
"pointer in the device descriptor:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:171
msgid ""
"Notice how I initialized the required limits object with `= Default` "
"above. This is a syntactic helper provided by the `webgpu.hpp` wrapper "
"for all structs to prevent us from manually setting default values. In "
"this case it sets all limits to 0 to mean that there is no requirement."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:174
msgid "I now get these more secure supported limits:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:181
msgid ""
"I recommend you have a look at all the fields of the `WGPULimits` "
"structure in `webgpu.h` so that you know when to add something to the "
"required limits."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:183
msgid "Vertex Buffer"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:186
msgid "For now we hard-code the value of the vertex buffer in the C++ source:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:206
msgid ""
"The GPU-side vertex buffer is created like any other buffer, as "
"introduced in the previous chapter. The main difference is that we must "
"specify `BufferUsage::Vertex` in its `usage` field."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:237
#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:88
msgid "Vertex Buffer Layout"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:240
msgid ""
"For the *vertex fetch* stage to provide data from the vertex buffer to "
"our vertex shader, we need to add a `VertexBufferLayout` to "
"`pipelineDesc.vertex.buffers`:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:265
msgid ""
"It is important to note that **the same vertex buffer** can contain "
"**multiple vertex attributes**. This is why the `maxVertexAttributes` and"
" `maxVertexBuffers` limits are different concepts. So there is yet "
"another array pointer:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:287
msgid ""
"We can now configure our vertex attribute. The value of `shaderLocation` "
"must be the same than what specifies the WGSL attribute `@location(...)` "
"in the vertex shader. The format `Float32x2` corresponds at the same time"
" to the type `vec2f` in the shader and to the sequence of 2 floats in the"
" vertex buffer data."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:313
msgid ""
"The **stride** is a common concept in buffer manipulation: it designates "
"the number of bytes between two consecutive elements. In our case, the "
"positions are **contiguous** so the stride is equal to the size of a "
"`vec2f`, but this will change when adding more attributes in the same "
"buffer."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:315
msgid ""
"Finally the `stepMode` is set to `Vertex` to mean that each vertex "
"corresponds to a different value from the buffer. The step mode is set to"
" `Instance` when each value is shared by all vertices of the same "
"instance (i.e., copy) of the shape."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:333
#: ../../getting-started/first-color.md:177
msgid "Render Pass"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:336
msgid ""
"The last change we need to apply is to \"connect\" the vertex buffer to "
"the pipeline's vertex buffer layout when encoding the render pass:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:362
msgid ""
"And we get... exactly the same triangle as before. Except now we can very"
" easily add some geometry:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:382
msgid "Triangles rendered using a vertex attribute"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:385
msgid ""
"We have seen in this chapter how to use **GPU buffers** to feed data as "
"**input** to the vertex shader, and thus to the whole rasterization "
"pipeline. We will refine this in the next chapter by adding **additional "
"attributes**."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index.md:1
msgid "Input Geometry"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:1
msgid "Index Buffer"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:5
#: ../../basic-3d-rendering/input-geometry/index-buffer.md:193
msgid ""
"*Resulting code:* [`step034`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step034)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:9
#: ../../basic-3d-rendering/input-geometry/index-buffer.md:197
msgid ""
"*Resulting code:* [`step034-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step034-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:12
msgid ""
"The index buffer is used to separate the list of vertex attributes from "
"the actual order in which they are connected. To illustrate its interest,"
" let us draw a square, which is made of 2 triangles."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:24
msgid "Index data"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:27
msgid "A straightforward way of doing this is as follows:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:43
msgid ""
"But as you can see some **data is duplicated**. And this duplication "
"could be much worst on larger shapes with connected triangles."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:45
msgid ""
"A more compact way of expressing the square's geometry is to separate the"
" **position** from the **connectivity**:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:65
msgid ""
"The index data must have type `uint16_t` or `uint32_t`. The former is "
"more compact but limited to $2^{16} = 65 536$ vertices."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:68
msgid ""
"I also keep the interleaved color attribute in this example, my vertex "
"data is:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:80
msgid ""
"Using the index buffer adds an overhead of `6 * sizeof(uint16_t)` = 12 "
"bytes but also saves `2 * 5 * sizeof(float)` = 40 bytes, so even on this "
"very simple example it is worth using."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:83
msgid "Terminology"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:84
msgid ""
"I usually replace the name **vertex** data with **point** data when "
"referring to the de-duplicated attribute buffer. In other terms, "
"`vertex[i] = points[index[i]]`. The name *vertex* is used to mean a "
"**corner** of triangle, i.e. a pair of a point and a triangle that uses "
"it."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:87
msgid "Buffer creation"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:90
msgid ""
"Of course the index data must be stored in a GPU-side buffer. This buffer"
" needs a usage of `BufferUsage::Index`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:117
msgid ""
"A `writeBuffer` operation must copy a number of bytes that is a multiple "
"of 4. To ensure so we can switch `bufferDesc.size` for `(bufferDesc.size "
"+ 3) & ~3`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:120
msgid "Render pass"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:123
msgid ""
"To draw with an index buffer, there are two changes in the render pass "
"encoding:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:125
msgid "Set the active index buffer with `renderPass.setIndexBuffer`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:126
msgid "Replace `draw()` with `drawIndexed()`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:159
msgid "The square is deformed."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:162
msgid "Ratio correction"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:165
msgid ""
"The square we obtained is deformed because its coordinates are expressed "
"**relative to the window's dimensions**. This can be fixed by multiplying"
" one of the coordinates by the ratio of the window $640/480$."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:167
msgid ""
"We could do this either in the initial vertex data vector, but this will "
"require is to update these values whenever the window dimension changes. "
"A more interesting option is to use the **power of the vertex shader**:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:175
msgid ""
"Although basic, this is a first step towards what will be the key use of "
"the vertex shader when introducing **3D transforms**."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:178
msgid ""
"It might feel a little unsatisfying to hard-code the window resolution in"
" the shader like this, but we will quickly see how to make this more "
"flexible thanks to uniforms."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:184
msgid "The expected square"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:190
msgid ""
"Using an index buffer is a rather simple concept in the end, and can save"
" a lot of VRAM. Additionally, it corresponds to the way traditional "
"formats usually encode 3D meshes."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:5
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:494
msgid ""
"*Resulting code:* [`step037`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step037)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:9
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:498
msgid ""
"*Resulting code:* [`step037-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step037-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:13
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:502
msgid ""
"*Resulting code:* [`step037-dawn`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step037-dawn)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:16
msgid ""
"Now that we are familiar with the representation of geometric data that "
"the GPU expect, we can load it from a file instead of hard-coding it in "
"the source code. This is the occasion to introduce some basic **resource "
"management** to our project (although this is not specific to WebGPU)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:18
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:487
msgid "File format"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:21
#: ../../basic-compute/compute-pipeline.md:369
msgid "Example"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:23
msgid ""
"The file format I introduce here is not standard, but it is simple enough"
" to parse. Here is the content of `webgpu.txt`, which I put in a "
"`resources/` directory:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:57
msgid ""
"It is basically the content of the `pointData` and `indexData` defined "
"previously as C++ vectors, introduced by a line of the form `[section "
"name]`. Lines that are empty or starting with a `#` are ignored."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:60
msgid "We can already bump up the maximum buffer size limit:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:67
msgid "Parser"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:69
msgid ""
"I am not going to detail the parser. I believe it is rather simple to "
"understand, and it is not the core topic of this lecture."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:71
msgid ""
"Plus once we'll start using 3D data we will switch to a more standard "
"format anyways."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:138
msgid "Loading resources from disc"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:141
msgid "Basic approach"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:143
msgid ""
"We can replace the definition of the `pointData` and `indexData` vectors "
"by a call to our new `loadGeometry` function."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:156
msgid ""
"A problem we have with this hard-coded relative path is that its "
"interpretation depends on the directory from which you run your "
"executable:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:166
msgid ""
"In the second case, your program tries to open "
"`my_project/build/resources/webgpu.txt`, which does not exist. There are "
"a few options to address this:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:168
msgid ""
"**Option A** Don't care, just call your program from the right directory."
" It could be annoying, and the problem is that IDEs usually run the "
"executable from `build/` or even a subdirectory of `build/`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:169
msgid ""
"**Option B** Use an absolute path. This will only work on your machine, "
"which is quite of a limitation."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:170
msgid ""
"**Option C** Use an absolute path that is automatically generated thanks "
"to CMake. This is what we'll do."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:171
msgid ""
"**Option D** Use a command line argument to tell the program where to "
"find the resource directory. This is an interesting option, which can be "
"used in combination with *Option C*, but requires a bit more work."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:172
msgid ""
"**Option E** Automatically copy the resources in the directory from which"
" your IDE launches the program. This will be a problem once we try to "
"modify resources while the program is running (which is quite handy when "
"writing shaders)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:174
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:486
msgid "Resource path resolution"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:176
msgid "We will do something like this:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:183
msgid ""
"Except that the `#define RESOURCE_DIR` will be added by CMake rather than"
" being explicitly written in our source code!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:186
msgid ""
"When putting two *string literals* next to each others in a C or C++ "
"source code, like in `loadGeometry(\"resource\" \"/webgpu.txt\"`, ...), "
"they are automatically concatenated. This is precisely meant for our use "
"case to work!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:189
msgid ""
"To define `RESOURCE_DIR` in the `CMakeLists.txt` you can add this after "
"creating the `App` target:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:197
msgid ""
"The expression `${CMAKE_CURRENT_SOURCE_DIR}` is replaced by the content "
"of CMake's variable "
"[`CMAKE_CURRENT_SOURCE_DIR`](https://cmake.org/cmake/help/latest/variable/CMAKE_CURRENT_SOURCE_DIR.html),"
" which is a built-in variable containing the full path to the "
"`CMakeLists.txt` file that you are editing."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:200
msgid ""
"When writing a CMake *function*, the `CMAKE_CURRENT_SOURCE_DIR` variable "
"contains the directory of the `CMakeLists.txt` that is currently calling "
"the function. If you want to refer to the directory of the "
"`CMakeLists.txt` that defines the function, use "
"[`CMAKE_CURRENT_LIST_DIR`](https://cmake.org/cmake/help/latest/variable/CMAKE_CURRENT_LIST_DIR.html)"
" instead."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:203
msgid "Portability"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:205
msgid ""
"ðŸ˜’ Hey but in the end our executable uses an **absolute path**, so we have"
" this **portability issue** when trying to share it, right?"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:207
msgid ""
"Yes indeed, but we can easily add an option to globally change the "
"resource directory when building a release that we want to be able to "
"distribute:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:230
msgid ""
"You can then have 2 different builds of your project in two different "
"directories:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:237
msgid ""
"The first one for comfort of development, the second one for the "
"portability of a release."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:240
msgid ""
"The `CMAKE_BUILD_TYPE` option is a built-in option of CMake that is very "
"commonly used. Set it to `Debug` to compile your program with **debugging"
" symbols* (see [debugging](/appendices/debugging.md)), at the expense of "
"a slower and heavier executable. Set it to `Release` to have a fast and "
"lightweight executable with no debugging safe-guard."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:242
msgid ""
"When using some CMake generators, like the Visual Studio one, this is "
"ignored because the generated solution can switch from Debug to Release "
"mode directly in the IDE instead of asking CMake."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:247
msgid ""
"Now that we have a basic resource path resolution mechanism, I strongly "
"suggest we use to load our shader code, instead of hard-coding it in the "
"C++ source as we have been doing from the beginning. We can even include "
"the whole shader module creation call:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:302
msgid ""
"Move the original content of the shaderSource variable into "
"`resources/shader.wgsl` and replace the module creation step by:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:310
msgid ""
"This way, you **no longer need to rebuild** the application when you only"
" want to change the shader!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:312
msgid "Adjustments"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:323
msgid "If you run the program now you should get something like this:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:328
msgid "Our loaded shape is a bit off, we should move it to better center it!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:331
msgid ""
"So how do we \"move\" the object? Similarly to how we fixed the ratio "
"issue in the previous chapter, we can do it in the **vertex shader**, by "
"adding something to the `x` and `y` coordinates:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:339
msgid ""
"It is important to apply the scene transform **before** the viewport "
"transform (the ratio). We will get back on this more in detail when "
"adding the 3D to 2D projection transform needed for [drawing 3D meshes"
"](/basic-3d-rendering/3d-meshes/index.md)!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:345
msgid "The WebGPU Logo loaded from the file, with wrong colors."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:348
msgid "Color issue"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:350
msgid ""
"You are not just being picky, there is indeed **something wrong** with "
"the colors! Compare to the logo in the left panel, the colors in the "
"window seem lighter, and even have a different tint."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:353
msgid ""
"This behavior depends on your device, so you may actually see correct "
"colors. I recommend you read the following anyways though!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:356
msgid "ðŸ™„ Hum maybe you made a mistake when writing the file you provided."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:358
msgid ""
"Nice try, but nope. To convince you let's take a look at the color of the"
" first 3 lines of the file, which correspond to the biggest triangle:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:364
msgid ""
"These are *red*, *green* and *blue* values expressed in the range $(0,1)$"
" but let's **remap** them to the integer range $[0,255]$ (8-bit per "
"channel) which is what your screen most likely displays (and hence what "
"usual image file format store):"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:370
msgid "Now we can check on a screen capture the color of the big triangle:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:375
msgid ""
"Color picking the big triangle in a screenshot of our windows shows a "
"color of $(0, 160, 205)$."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:378
msgid ""
"Oh oh, it does not match. What is happening? We have a **color space** "
"issue, meaning that we are expressing colors in a given space, but they "
"end up being interpreted differently. This may happen in a lot of "
"contexts, so it is quite useful to be aware of the basics (although color"
" science is a non-trivial matter in general)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:380
msgid "Our problem here comes from the `swapChainFormat`. Let us print it:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:386
msgid ""
"This gives *Swapchain format: 24*. The \"24\" must be compared to the "
"values of the `WGPUTextureFormat` enum in `webgpu.h`. Be aware that "
"values there are expressed in base 16 (number literals start with `0x`), "
"so we are looking for `24 = 1 * 16 + 8 = 0x18`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:389
msgid ""
"To avoid the need to manually handle enum values, I recommend to have a "
"look at "
"[magic_enum](https://github.com/Neargye/magic_enum/blob/master/include/magic_enum.hpp)."
" After you copy this file to your source tree you can simply do the "
"following:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:399
msgid ""
"Thanks to advanced C++ template mechanism, this library is able to output"
" *Swapchain format: WGPUTextureFormat_BGRA8UnormSrgb*!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:403
msgid ""
"Since the Dawn implementation only supports the format `BGRA8Unorm` for "
"the surface, you should directly see correct colors in that case."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:406
msgid "In my setup, the preferred format is `BGRA8UnormSrgb`:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:408
msgid ""
"The `BGRA` part means that colors are encoded with the blue channel "
"first, then the green one, then red and alpha."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:409
msgid ""
"The `8` means that each channel is encoded using 8 bits (256 possible "
"values)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:410
msgid ""
"The `Unorm` part means that it is exposed as an unsigned normalized "
"value, so we manipulate floats (well, fixed-point reals actually, not "
"floating-point) in the range $(0,1)$ even if the underlying "
"representation only uses 8-bits. `Snorm` would be in range $(-1,1)$, "
"`Uint` in integer range $[0,255]$, etc."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:411
msgid ""
"And finally, the `Srgb` part tells that values use the "
"[sRGB](https://en.wikipedia.org/wiki/SRGB) scale."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:413
msgid "The sRGB color space"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:415
msgid ""
"The idea of a color space is to answer the following problem: We have a "
"budget of 256 possible values to represent a color channel, how should "
"these 256 **discrete** values (index $i$) be distributed along the "
"**continuous** range of light intensity $x$?"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:427
msgid ""
"The most intuitive approach, the **linear** one, consists in regularly "
"distributing the 256 indices across the range of intensities. But we may "
"need more precision in some parts of the range and less in others. Also, "
"the **physical response** of your screen is typically not linear! **Even "
"your eyes** don't have a linear response when translating physical "
"stimuli into psychological **perception** (and it depends on the "
"surrounding lighting)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:430
msgid ""
"The sRGB color space has been designed specifically to address the non-"
"linearity of the display. On [CRT](https://en.wikipedia.org/wiki/Cathode-"
"ray_tube) displays, this was in line with the spontaneous response "
"behavior of the physical device. Now we have switched to LCD or OLED "
"display so the physical device has a different behavior, but screen "
"manufacturer artificially reproduce the CRT response curve to ensure "
"backward compatibility."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:434
msgid ""
"The sRGB color space is so much the standard that it is the one used by "
"all common image file formats, like PNG and JPG. As a consequence, when "
"not doing any color conversion, everything we do, including the color "
"picking tool, is in sRGB."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:436
msgid ""
"**However**, WebGPU assumes that the colors output by the fragment shader"
" are linear, so when setting the surface format to `BGRA8UnormSrgb` it "
"performs a *linear to sRGB* conversion. **This is what causes our colors "
"to be wrong!**"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:439
msgid "Gamma correction"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:441
msgid "An easy-fix is to force a non-sRGB texture format:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:447
msgid ""
"But ignoring the preferred format of the target surface may result in "
"performance issues (the driver would need to convert formats all the "
"time). Instead, we will handle the **color space conversion in the "
"fragment shader**. A good approximation of the rRGB conversion is "
"$R_{\\text{linear}} = R_{\\text{sRGB}}^{2.2}$:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:460
msgid "The WebGPU Logo with gamma-corrected colors."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:463
msgid ""
"Perfect! We fixed the problem, and we can even check with the color "
"picker:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:468
msgid ""
"Now color picking shows the right value (almost, our gamma curve is an "
"approximation)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:471
msgid ""
"This conversion from linear to non-linear color scale (or the other way "
"around) is called **gamma correction** or **tone mapping**. Here it was "
"for rather technical consideration, but it is common to add an "
"artistically driven tone mapping operation at the end of a 3D rendering "
"pipeline. And the fragment shader is the right place to do so."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:474
msgid ""
"In general a color space is characterized by a **gamut** and a **gamma**."
" The gamma is this non-linearity of the discrete scale of values, and the"
" gamut is the range of intensities that we want to cover (the vertical "
"axis above, generalized to 3 colors). The gamut is often given by 3 "
"*primaries*."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:478
msgid ""
"There is more generally a lot to get lost about with color spaces, don't "
"try to learn it all at once but I personally find it fascinating!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:484
msgid ""
"Loading geometric data from a file was an apparently simple change, but "
"it was actually a good way to introduce multiple concerns that can easily"
" become a nightmare if we don't pay attention to them:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:488
msgid "Color space and more generally data encoding"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:489
msgid "Transform (ratio, position)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:491
msgid ""
"We are going to come back on these from time to time to refine them. We "
"are now ready to move on to a way to avoid hard-coded values in the "
"shader and add a lot of flexibility, namely **uniforms**."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:1
msgid "Multiple Attributes"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:5
#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:358
msgid ""
"*Resulting code:* [`step033`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step033)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:9
#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:362
msgid ""
"*Resulting code:* [`step033-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step033-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:12
msgid ""
"Vertices can contain more than just a position. A typical example is to "
"**add a color attribute** to each vertex. This will also show us how the "
"rasterizer automatically interpolate vertex attributes across triangles."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:17
msgid ""
"You may have guessed that we can simply add a second argument to the "
"vertex shader entry point `vs_main`, with a different `@location` WGSL "
"attribute:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:26
msgid ""
"This works, but you might prefer when the number of input attribute grows"
" to instead take a single argument whose type is a custom struct labeled "
"with locations:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:44
msgid ""
"ðŸ˜ But I don't need the color in the vertex shader, I want it in the "
"fragment shader, can I do `fn fs_main(@location(1) color: vec3f)`?"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:46
msgid ""
"Nope. The vertex attributes are only provided to the vertex shader. "
"However, **the fragment shader can receive what the vertex shader "
"returns!** This is where the structure-based approach becomes handy:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:82
msgid ""
"There is a limit on the number of components that can be forwarded from "
"vertex to fragment shader. In our case, we ask for 3 (float) components:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:91
msgid ""
"There are different ways of feeding multiple attributes to the vertex "
"fetch stage. The choice usually depends on the way your input data is "
"organized, which varies with the context, so I am going to present two "
"different ways."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:93
msgid "Option A: Interleaved attributes"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:95
msgid ""
"Before anything, do not forget to increase the vertex attribute limit of "
"your device:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:101
msgid ""
"Interleaved attributes means that we put in a single buffer the values "
"for all the attributes of the first vertex, then all values for the "
"second vertex, etc:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:121
msgid ""
"The first thing we can remark is that now the **stride** of our position "
"attribute has changed from `2 * sizeof(float)` to `5 * sizeof(float)`:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:128
msgid "We thus need to update the buffer size and stride limits:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:135
msgid ""
"This stride is the same for both attributes, so it is not a problem that "
"the stride is set at the level of the while buffer layout. The main "
"difference between our two attributes actually is the offset at which "
"they start in the buffer: the color starts after 2 floats."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:137
msgid ""
"We now need to provide 2 elements in the `vertexBufferLayout.attributes` "
"array. So instead of passing the address `&vertexAttrib` of a single "
"entry, we use a `std::vector`:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:179
msgid "Option B: Multiple buffers"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:181
msgid ""
"Another possible data layout is to have two different buffers for the two"
" attributes. Make sure to change the device limit to support this:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:187
msgid "We thus have 2 input vectors:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:215
msgid "This time, the maximum buffer size/stride can be lower:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:223
msgid "Which lead to two GPU buffers:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:260
msgid ""
"This time it is not the `VertexAttribute` struct but the "
"`VertexBufferLayout` that is replaced with a vector:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:326
msgid ""
"And finally we also have 2 calls to `renderPass.setVertexBuffer`. The "
"first argument (`slot`) corresponds to the index of the buffer layout in "
"the `pipelineDesc.vertex.buffers` array."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:350
msgid "Triangles with a color attribute (same result for both options)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:354
msgid ""
"I changed the background color (`clearValue`) to `Color{ 0.05, 0.05, "
"0.05, 1.0 }` to better appreciate the colors of the triangles."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:1
msgid "Playing with buffers"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:5
#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:335
msgid ""
"*Resulting code:* [`step031`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step031)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:9
#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:339
msgid ""
"*Resulting code:* [`step031-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step031-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:12
msgid ""
"Before feeding vertex data to the render pipeline, we need to get "
"familiar with the notion of **buffer**. A buffer is \"just\" a chunk of "
"memory allocated in the VRAM (the GPU's memory). Think of it as some kind"
" of `new` or `malloc` for the GPU."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:14
msgid ""
"One notable difference is that we must state some hint about our use of "
"this memory upon its creation. For instance, if we are going to use it "
"only to write it from the CPU but never to read it back, we set its "
"`CopyDst` flag on but not the `CopySrc` flag. This not fully agnostic "
"memory management helps the device figure out the best memory layout."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:17
msgid ""
"Note that textures are a special kind of memory (because of the way we "
"usually sample them) that they live in a different kind of object."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:20
msgid "Creating a buffer"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:23
msgid "The overall structure of the buffer creation will surprise no one now:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:49
msgid ""
"A GPU buffer is *mapped* when it is connected to a specific part of the "
"CPU-side RAM. The driver then automatically synchronizes its content, "
"either for reading or for writing. We will not use it here."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:52
msgid ""
"For our little exercise, create a second buffer, called `buffer2`. We "
"will load data in the first buffer, issue a copy command so that the GPU "
"copies data from one to another, then read the destination buffer back."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:54
msgid "Also, don't forget to free your buffers once you no longer use them:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:76
msgid "Note that there are two different operations here:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:78
msgid ""
"**Destroy** frees the GPU memory that was allocated for the buffer, but "
"the buffer object itself, which lives on the driver/backend side, still "
"exists."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:79
msgid ""
"**Release** frees the driver/backend side object (or rather decreases its"
" reference pointer and frees it if nobody else uses it)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:81
msgid "Writing to a buffer"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:84
msgid ""
"Let us simply use the `queue.writeBuffer` function (or the C-style "
"`wgpuQueueWriteBuffer`), to which we give a memory address and size from "
"which data is copied:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:109
msgid ""
"Uploading data from the CPU-side memory (RAM) to the GPU-side memory "
"(VRAM) **takes time**. When the function `writeBuffer()` returns, data "
"transfer may not have finished yet but it is **guaranteed** that:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:111
msgid ""
"You can **free up the memory** from the address you just passed, because "
"the backend maintains its own CPU-side copy of the buffer during "
"transfer."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:113
msgid ""
"Commands that are **submitted in the queue after** the `writeBuffer()` "
"operation will not be executed before the data transfer is finished."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:115
msgid ""
"And don't forget that commands sent through the **command encoder** are "
"only submitted when calling `queue.submit()` with the encoded command "
"buffer returned by `encoder.finish()`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:118
msgid ""
"We can thus submit a buffer-buffer copy operation to the command queue, "
"after having created a command encoder:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:133
msgid ""
"Make sure that command encoding operations are called before "
"`encoder.finish()` or `wgpuCommandEncoderFinish()`!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:136
msgid "Reading from a buffer"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:139
msgid ""
"We cannot just use the command queue to read memory back from the GPU, "
"because this is a \"fire and forget\" queue: functions do not return a "
"value since they are run on a different timeline."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:141
msgid ""
"Instead, we use an **asynchronous operation**, namely `buffer.mapAsync` "
"(or `wgpuBufferMapAsync`). This operation maps the GPU buffer into CPU "
"memory, and then whenever it is ready it executes the callback function "
"it was provided."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:143
msgid ""
"This asynchronicity makes the programming workflow more complicated than "
"synchronous operations, but once again it is important to minimize "
"wasteful processor idling."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:145
msgid "Mapping"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:147
msgid ""
"Let us first change the `usage` of the second buffer by adding the "
"`BufferUsage::MapRead` flag, so that the buffer can be mapped for "
"reading:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:162
msgid ""
"The `BufferUsage::MapRead` flag is not compatible with "
"`BufferUsage::CopySrc` one, so make sure not to have both at the same "
"time."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:165
msgid "We can now call the buffer mapping with a simple callback."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:168
msgid ""
"I intentionally use the C-style procedure for now, it helps understanding"
" what is happening under the hood when using the simpler API provided by "
"the C++ wrapper."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:190
msgid ""
"The function `onBuffer2Mapped` is defined here as a [lambda "
"expression](https://en.cppreference.com/w/cpp/language/lambda) but it "
"could also be a regular function declared before `main()`, provided it "
"has the same signature:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:199
msgid "Asynchronous polling"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:201
msgid ""
"If you run the program at this point, you might be surprised (and "
"disappointed) to see that the callback is **never executed**!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:203
msgid ""
"This is because there is no hidden process executed by the WebGPU library"
" to check that the async operation is ready. Instead, the backend checks "
"for ongoing async operations only when we call another operation, so we "
"will add in the main loop a simple operation that does nothing."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:205
msgid ""
"Unfortunately, this mechanism has no standard solution, so we write it "
"differently for Dawn and `wgpu-native`:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:246
msgid ""
"Make sure the calls to `buffer.destroy` are issued *after* the main loop,"
" otherwise the callback will be called with status "
"`BufferMapAsyncStatus::DestroyedBeforeCallback`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:249
msgid ""
"You should now see `Buffer 2 mapped with status 0` (0 being the value of "
"`BufferMapAsyncStatus::Success`) when running your program."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:251
msgid "Mapping context"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:253
msgid ""
"Now, we need to get more than a status when running this callback, we "
"need to access the buffer's content. But the `onBuffer2Mapped` function "
"cannot access the `buffer2` variable so far."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:256
msgid ""
"When using a regular function, it is clear that `buffer2` is not "
"accessible. When using a lambda expression, one could be tempted to add "
"`buffer2` in the **capture list** (the brackets before function "
"arguments). But this **does not work** because capturing lambdas have a "
"different type, that cannot be used as a regular callback. The C++ "
"wrapper fixes this."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:259
msgid ""
"We thus use the `void *userdata` pointer communicated from the original "
"call to `wgpuBufferMapAsync` to the callback, like we did in [the adapter"
" request](../../getting-started/the-adapter.md) or [the device request"
"](../../getting-started/the-device.md):"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:314
msgid ""
"For instance we can just display the content of the buffer and check that"
" it corresponds to our initially fed buffer data:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:326
msgid ""
"In such a simple example, we could spare ourselves the need to define a "
"`Context struct` and just pass the address of the `buffer` object as the "
"value of `pUserData` (or even the `buffer` object itself, as it is a "
"pointer already)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:332
msgid ""
"Congratulations! We were able to create a GPU-side memory buffer, upload "
"data into it, copy it remotely (operation triggered from the CPU, but "
"executed on the GPU) using the command queue and download data back from "
"the GPU. We can now use a buffer to specify vertex attributes, in "
"particular vertex positions!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:1
msgid "Cube Maps (ðŸš§WIP)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:5
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:209
msgid ""
"*Resulting code:* [`step117`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step117)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:9
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:213
msgid ""
"*Resulting code:* [`step117-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step117-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:12
msgid ""
"The computation of the `ibl_uv` coordinates at which we sampled the "
"environment lighting in the previous chapter is a bit costly, due to the "
"`acos` and `atan2` operations. A more efficient way to store the "
"environment map is as a **cube map**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:18
msgid "Cube maps are more efficient to sample and hardware accelerated."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:21
msgid "Multi-layer textures"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:24
msgid ""
"We will see in the [Cubemap Conversion](../../basic-compute/image-"
"processing/cubemap-conversion.md) chapter how to convert an "
"equirectangular environment map into a cubemap and vice versa."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:26
msgid ""
"All we need to know for now is that **a cubemap is a special type of "
"texture**. It is stored as a **2D array texture** with **6 layers**, "
"which means that when creating the texture, with specify a dimension of "
"`2D` but the `size` has 3 dimensions:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:35
msgid ""
"**By convention**, the face of the cube are stored in the following "
"**order**:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "Layer"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "Cube Map Face"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "S"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "T"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "0"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Positive X`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`-Z`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`-Y`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "1"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Negative X`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`+Z`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "2"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Positive Y`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`+X`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "3"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Negative Y`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "4"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Positive Z`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "5"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Negative Z`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`-X`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:46
msgid ""
"As you can see, the convention also specifies the world-space direction "
"to which the local texture axes `S` and `T` correspond."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:62
msgid ""
"In practice, we **load the faces one by one**, from individual files. The"
" computations of **MIP levels** is also done face by face. The texture "
"sampler will take care of mixing faces together appropriately."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:87
msgid ""
"Images appear upside down because the convention was designed by people "
"who use $Y$ as the vertical axis, and in this guide we use $Z$ as the "
"vertical. Anyways even when using $Y$-up it is better to stick to the "
"convention table above than to try to intuitively guess the correct S and"
" T texture axes."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:97
msgid ""
"Unzip [`autumn_park_4k.zip`](../../data/autumn_park_4k.zip) in your "
"`resource` directory."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:179
msgid ""
"Note that we also add a new extra argument to `writeMipMaps` to specify "
"which layer to upload to:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:1
msgid "Image-Based Lighting (ðŸš§WIP)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:5
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:124
msgid ""
"*Resulting code:* [`step115`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step115)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:9
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:128
msgid ""
"*Resulting code:* [`step115-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step115-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:15
#: ../../basic-compute/image-processing/cubemap-conversion.md:16
msgid ""
"An environment map is a 360Â° image in high-dynamic range that we use as "
"an omnidirectional light source."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:20
msgid ""
"For each camera ray (i.e., each pixel) we compute the direction reflected"
" by the surface's normal to sample the part of the environment map that "
"contributes the most to the lighting."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:23
msgid "IBL Sampling"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:28
msgid ""
"Add the environment map "
"[`autumn_park_4k.jpg`](../../data/autumn_park_4k.jpg) to the list of "
"loaded textures:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:36
msgid ""
"You can find plenty more examples of environment maps on "
"[PolyHaven](https://polyhaven.com/hdris) and "
"[ambientCG](https://ambientcg.com/list?type=HDRI). These are CC0 "
"licensed, allowing you to use them in any context!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:39
msgid ""
"We test on a simpler model than the boat: "
"[`suzanne.obj`](../../data/suzanne.obj)."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:78
msgid "IBL Prefiltering"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:81
msgid ""
"We can give more roughness to the object by sampling a different MIP "
"level:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:94
msgid ""
"In fact, instead of letting the GPU guess which MIP level we want as done"
" for a regular texture, we specify manually the level we want depending "
"on the desired roughness of each surface element."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:96
msgid "For instance we can create alternating rough and glossy stripes:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:113
msgid "Our approach so far has 3 problems:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:115
msgid ""
"By manually setting the MIP level, we lose the \"smart\" choice that the "
"GPU is doing based on screen-space gradients to avoid aliasing. To get "
"both manual control and this behavior, we can use  `textureSampleBias`."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:117
msgid ""
"The MIP levels are generated as if the texture represented a signal "
"regularly sampled along a grid, but the environment map is sampled along "
"directions, which induces distortion that the mip generation should take "
"into account."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:119
msgid ""
"To be able to represent at the same time the sun and color details in "
"indirectly lit areas, the environment texture usually uses **high-dynamic"
" range** (HDR) image formats like .hdr or .exr."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:121
msgid ""
"We see in the next chapter a more efficient way to sample the environment"
" with a special type of textures, namely **cube maps**. In the [HDR "
"Textures](../../advanced-techniques/hdr-textures.md) chapter we will see "
"how to load HDR textures."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/index.md:1
msgid "Lighting and Material"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:1
msgid "Normal mapping (ðŸš§WIP)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:5
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:466
msgid ""
"*Resulting code:* [`step110`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step110)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:9
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:470
msgid ""
"*Resulting code:* [`step110-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step110-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:12
msgid "ðŸš§ WIP"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:13
msgid ""
"From this chapter on, the guide is not as up to date. I am currently "
"refreshing it chapter by chapter and this is where I am currently "
"working!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:16
msgid ""
"We have seen that the **normal** of a surface (i.e., the direction "
"perpendicular to it) plays a key role in the way the light bounces on it."
" **Normal mapping** consists in locally perturbing this normal depending "
"on an input map (texture file) to **model the effect of very small "
"geometric details**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:19
msgid ""
"These **micro details** could in theory be represented by subdividing the"
" mesh a lot and slightly moving some vertices, but for the scale that "
"normal maps model, this approach is really not tractable."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:36
msgid "Normal map"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:39
msgid "There are different ways to provide the perturbed normals:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:41
msgid ""
"Specify a perturbed normal **at each vertex**, and interpolate across the"
" face. This is used to **smooth out** the boundaries between faces and "
"thus create smooth surfaces, and we already have this."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:43
msgid ""
"Provide a **texture** that gives the perturbed normal. This is heavier "
"but can bring a lot more details. This texture is called the **normal "
"map**, and is what this chapter is about!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:45
msgid ""
"In a normal map, **the color of each vertex represents a little vector** "
"of length 1. Values of red, green and blue are interpreted as components "
"X, Y and Z and **encode values in range $(-1, 1)$**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:47
msgid ""
"The very meaning of these X, Y and Z axes depends on the **convention**; "
"what matters is to be consistent between your files and your shader code:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:64
msgid ""
"The conventions \"DirectX\" and \"OpenGL\" are no longer constraints from"
" the graphics API because we will write ourselves in the shader how "
"normal map pixels must be interpreted. These names comes from before we "
"could write shaders."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:66
msgid "For the rest of this document, **we will follow the OpenGL convention.**"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:69
msgid "In practice in order to use such a normal map, we need to:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:71
msgid "**Load** the file as a texture and bind it to the shader."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:72
msgid "**Sample** the texel and decode it into a normal vector"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:73
msgid "**Transform** this normal with respect to the orientation of the face"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:75
msgid "On a plane"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:78
msgid ""
"Let us first focus on steps 1. **Load** and 2. **Sample** by using a "
"simple plane (so that there is no need for step 3. **Transform** for "
"now)."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:80
msgid "Loading the normal map"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:82
msgid "Switch the loaded object to the [`plane.obj`](../../data/plane.obj) mesh:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:88
msgid ""
"For this example we use the `cobblestone_floor_08` material from "
"[PolyHaven](https://polyhaven.com/a/cobblestone_floor_08) (a nice source "
"of materials that can be freely used by the way). We only look at the "
"[diffuse](../../images/cobblestone_floor_08_diff_2k.jpg) and "
"[normal](../../images/cobblestone_floor_08_nor_gl_2k.png) maps for now, "
"and load them as textures."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:90
msgid ""
"Since we have more than one texture, we add attributes to our "
"`Application` class:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:118
msgid ""
"We can now update `initTexture()` (which I rename `initTextures()` then),"
" as well as `terminateTextures()`:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:126
msgid ""
"We add this new texture to our bindings, both on the C++ side and the "
"shader side (I chose to insert it next to the base color one):"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:139
msgid "Update `initBindGroup()` and `initBindGroupLayout()` accordingly."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:199
msgid "Lastly, this new texture requires to update our device limits:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:206
msgid ""
"Increase the specular hardness and play with the view point so that you "
"can highlight the problem with this texture:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:211
msgid ""
"Without normal mapping, the cobblestone texture feels completely flat, "
"which is odd for this material."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:214
msgid "Sampling normals"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:216
msgid ""
"The key moment where normal mapping intervenes is when evaluating the "
"normal `N` in the **fragment shader**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:222
msgid ""
"Instead of using the input normal, we sample the normal from the normal "
"map:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:230
msgid ""
"For each channel $r$, $g$ and $b$, the sampled value lies in range "
"$(0,1)$, and we need to map it to range $(-x,x)$ to **decode** it. The "
"value of $x$ does not really matter since we then normalize the vector."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:233
msgid ""
"If you are using the **DirectX** convention, you also need to **flip** "
"the $Y$ value (multiply by -1 after decoding)."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:239
msgid ""
"With normal mapping, the cobblestone material looks like it has a much "
"more realistic relief."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:242
msgid ""
"Normal mapping is **a powerful trick**, but of course it is not fully "
"equivalent to refining geometry. In particular, it **cannot change the "
"silhouette** of the shape, so the illusion fails at grazing angles:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:247
msgid ""
"At **grazing angles**, the normal mapping is not enough to give the "
"feeling of relief to the material. More complex methods like **relief "
"mapping** are needed here."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:251
msgid ""
"If you want to dim down the influence of the normal map, you can mix it "
"with the original normal:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:259
msgid "On a mesh"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:262
msgid "The problem"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:264
msgid ""
"The orientation contained in the normal map is given **relatively** to "
"the global normal of the face."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:266
msgid ""
"In the case of the plane, we could completely ignore the original normal "
"`in.normal` because it matched the Z axis of the normal map. But for any "
"non-horizontal face, we need to **rotate the sampled normal**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:268
msgid ""
"You can for instance test with this "
"[`cylinder.obj`](../../data/cylinder.obj) model:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:273
msgid ""
"Wrong normals: When sampling normals from texture (right), the overall "
"lighting is off and very different from the effect of the input normal "
"(left)."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:276
msgid "The problem becomes even clearer when we display the computed normals:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:286
msgid ""
"Wrong normals: The direction sampled from the normal map (right) should "
"be rotated to be centered around the original surface normal (left)."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:289
msgid "Local frame"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:291
msgid ""
"To fix this, we need to properly define the **local frame** (i.e., a "
"local $X$, $Y$ and $Z$ axes) in which normal maps expresses normal "
"perturbations."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:293
msgid ""
"Our key requirement for the rotation is that when the sampled normal is "
"$(0,0,1)$, it should mean \"no perturbation\". In other words, the end "
"normal vector $N$ must corresponds to `in.normal` in that case."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:295
msgid ""
"We thus know what the $Z$ axis of the normal space is, but still need to "
"define a $X$ and a $Y$ to fully get a rotation. These axes are called "
"respectively **tangent** and **bitangent** directions."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:297
msgid "Tangents and bitangents"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:301
msgid "Vertex attributes"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:305
msgid "We add vertex attributes:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:349
msgid "Don't forget to bump up the limits:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:356
#: ../../basic-compute/image-processing/mipmap-generation.md:265
msgid "Computation"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:360
msgid ""
"We compute these tangent and bitangent vectors when loading the mesh, in "
"a new `computeTextureFrameAttributes` private method of the "
"`ResourceManager`:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:375
msgid ""
"The exact procedure is once again a matter of **convention**, to be "
"aligned to what authoring tools export."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:405
#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:352
#: ../../basic-3d-rendering/some-interaction/simple-gui.md:76
msgid "Usage"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:417
msgid "In the vertex shader:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:425
msgid "In the fragment shader:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:443
msgid "Fixed normal maps."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:446
msgid ""
"You can try with the fourareen boat using "
"[`fourareen2K_normals.png`](../../data/fourareen2K_normals.png):"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:451
msgid "The Fourareen boat with normal mapping."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:454
msgid "(TODO: investigate why we still see some cracks and fireflies)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:459
msgid "To recap when normal mapping is about:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:461
msgid ""
"We **perturbate** normals to **emulate micro details** without paying the"
" cost of finer meshes."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:462
msgid "We **sample** this perturbation from a **normal map**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:463
msgid ""
"We need to **combine** this perturbation with the original normal by "
"rotating the sampled value."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:1
msgid "Physically-Based Materials (ðŸš§WIP)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:5
#: ../../basic-3d-rendering/lighting-and-material/pbr.md:72
msgid ""
"*Resulting code:* [`step125`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step125)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:9
#: ../../basic-3d-rendering/lighting-and-material/pbr.md:76
msgid ""
"*Resulting code:* [`step125-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step125-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:14
msgid ""
"The diffuse + specular material model that we have seen so far is an "
"important for step for educational purpose, but it lacks proper physical "
"ground."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:16
msgid ""
"There are two main categories of materials, which corresponds to two very"
" different ways that the light has to bounce on a surface:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:18
msgid ""
"**Metallic** objects conduct electro-magnetic waves and are thus are "
"basically **mirrors**: at the microscopic level the light really bounces "
"on them and leaves along the reflected direction."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:20
msgid ""
"**Dielectric** objects are literally the opposite: they **absorb** the "
"electro-magnetic waves' energy in a thin layer underneath their surface, "
"only to re-emit it in all directions, making them mostly diffuse. The "
"specular part of their shading comes from a part of the light that never "
"gets absorbed due to Snell's law."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:22
msgid "Some rules of thumb that derive from this:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:23
msgid "Metallic surfaces do not have any sort of diffuse lighting."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:24
msgid "Specular highlights on dielectric surfaces cannot be colored."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:25
msgid "Dielectric surfaces only have specular highlights at grazing angles."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:26
msgid "A surface is either metallic or dielectric, there is no in-between."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:28
msgid ""
"It results that we typically use the following parameters to describe a "
"material:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:30
msgid "`metallic`: 1.0 for a metallic surface, 0.0 for a dielectric one."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:31
msgid ""
"`baseColor`: For a dielectric object, this is the diffuse color; for a "
"metallic object, this is the specular color."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:32
msgid ""
"`reflectance`: For dielectrics only, we need to specify the strength of "
"the (non-colored) specular contribution."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:34
msgid ""
"There is no need for two different color maps since a surface is never "
"metallic and dielectric at the same time."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:36
msgid "We also have some geometric information:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:38
msgid ""
"`normal`: Of course you remember a previous chapter where we indicate the"
" local normal."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:39
msgid ""
"`roughness`: This expresses the standard deviation of micro-normals "
"around the mean one (given by the normal map). This goes on a scale from "
"0.0 to 1.0 that is more intuitive to manipulate than the specular's "
"\"hardness\" used previously."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:41
msgid ""
"The normal and roughness information are a statistical representation of "
"the \"Normal Distribution Function\" (NDF), i.e., the probability law "
"telling how microscopic facets are oriented within a texel."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:43
msgid "Test bench"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:46
msgid "We will focus our tests by using a simple sphere."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:51
msgid ""
"The same dielectric object with a roughness varrying from $0.41$ to "
"$0.79$."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:57
msgid "The same metallic object with a roughness varrying from $0.15$ to $0.83$."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:63
msgid ""
"Row 1: Varying from rough to glossy on a dielectric material. Row 2: "
"Varying from dielectric to metallic (one should not use in-between "
"though). Row 3: Varying from rough to glossy on a metallic material."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:69
msgid ""
"I recommend reading the [design "
"document](https://google.github.io/filament/Filament.html) from the "
"Filament render engine, which gives very insightful and ready-to-use "
"information."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:1
msgid "Specularity"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:5
#: ../../basic-3d-rendering/lighting-and-material/specular.md:308
msgid ""
"*Resulting code:* [`step105`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step105)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:9
#: ../../basic-3d-rendering/lighting-and-material/specular.md:312
msgid ""
"*Resulting code:* [`step105-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step105-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:12
#, python-format
msgid ""
"A first thing that our material model lacks is **specular highlight**. "
"This is a visual effect that can be seen on any shiny object, namely any "
"object that is not 100% rough:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:17
msgid "The white highlights on the pawn are a typical specular effect."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:20
msgid ""
"A key difference between diffuse and specular lighting, is that the "
"latter **depends on the view point**!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:22
msgid ""
"Look around, locate any glossy/reflective object, and move your head. You"
" should notice that the specular highlights move as well, while **neither"
" the object nor the light source changed**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:24
msgid ""
"Physically, this is due to the fact that a single point on a surface "
"emits **a different light intensity in different directions**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:40
msgid "Phong model"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:43
msgid ""
"In theory, any surface element reflects to some extent the light that it "
"received from all the directions. But when doing real time rendering, we "
"cannot afford to compute this exactly, we need an **approximation model**"
" that can be efficiently computed."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:45
msgid ""
"The [Phong model](https://en.wikipedia.org/wiki/Phong_reflection_model) "
"considers only the light coming from the direction of the light (it does "
"not account for inter-object reflection). It is one of the oldest "
"reflection models but it is still a good start."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:47
msgid ""
"What we have used so far is called the `diffuse` term, which does not "
"depend on the view point. We now add a `specular` term:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:57
msgid ""
"The Phong model also includes an ambient term that is a constant value "
"coming from the environment. We ignore it because we will soon replace "
"the Phong model altogether to a more physically accurate model."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:60
msgid ""
"In the remainder of this chapter, we focus on the `specular` term, so we "
"set the `diffuse` part to 0."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:62
msgid "Reflected direction"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:64
msgid ""
"We start from an extreme case: **if the surface is a perfect mirror** "
"then the impact of a light source located in direction $L$ is only "
"visible on the surface when looking from the **reflected direction** $R$ "
"(see figure below). And the surface appear black from everywhere else!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:80
msgid ""
"This reflected direction is the **symmetric of the light direction** $L$ "
"with respect to the normal $N$. Since this is a very common operation, it"
" is natively supported by WGSL (and other shading languages):"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:89
msgid ""
"The `reflect` function assumes that the direction we give is the "
"direction coming **from** the light, but for the rest of the code we "
"define *L* as being the direction **towards** the light."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:92
msgid ""
"For a perfect mirror, we would have something like `specular = (R == V)`,"
" but this is never perfectly equal, and **nothing is a perfect mirror "
"anyways**. Instead we use the angle between the view direction V and the "
"reflected direction R, or rather its cosine because it is easier to "
"compute:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:103
msgid "View direction"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:105
msgid "ðŸ¤” How do I get the direction $V$ exactly?"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:107
msgid ""
"It's not obvious indeed. First of all, we are going to compute it in the "
"**vertex shader** and let the rasterizer interpolate it for each "
"fragment:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:123
msgid ""
"As usual, when adding more values transiting from the vertex to the "
"fragment shader, we need to update the following limit to the new size of"
" `VertexOutput` in the shader:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:131
msgid ""
"We normalize `V` **in the fragment shader** because even if all "
"`out.viewDirection` are normalized, their interpolation after the "
"rasterization is in general no longer perfectly normalized."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:134
msgid ""
"So how do we compute the `viewDirection` in the vertex exactly? We can "
"split the line that populates `out.position` in order to get the **world "
"space coordinates** of the current vertex, prior to projecting it:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:146
msgid ""
"We are working in **world space coordinates** because this is the space "
"in which we express our light directions. We could do differently and "
"manipulate only values in camera space for instance, what matters is to "
"**be consistent**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:149
msgid ""
"The information of camera position is somehow contained in the "
"`viewMatrix`, but extracting it requires to compute a matrix inverse, "
"which is costly. It is thus not advised to perform this in the shader: "
"computing it for each vertex is **wasteful** since it is the same for all"
" vertices."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:152
msgid ""
"When doing GPU programming, it may happen that re-computing multiple "
"times the same quantity is more efficient than storing it in memory: some"
" pipelines are indeed **memory bound**, meaning that the GPU spends more "
"time waiting for memory accesses than for computation. See the "
"[Debugging](../../appendices/debugging.md) chapter for more details."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:155
msgid ""
"In our case it is clearly better to provide the camera position as a "
"uniform:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:172
msgid ""
"Keep in mind to sort fields from the largest one to the smallest one "
"(matrices first, floats at the end), and **also add this in the C++ "
"counterpart** of this struct."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:174
msgid ""
"Now every time we update the view matrix, we can also update this new "
"uniform field:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:209
msgid ""
"Alternatively, you can do the whole shading in **view space**. The camera"
" position in view space is always `vec3f(0.0)` and all you need to do is "
"to transform the light direction like we did for the vertex normal, "
"except using the view matrix:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:216
msgid "Phong specular"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:218
msgid ""
"Now that we can compute `R` and `V`, let us test to set `shading += "
"specular;` (ignore the diffuse term) in the loop over light sources in "
"the shader:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:229
msgid ""
"Using a hard threshold (0.99) on the cosine angle is a bit too strong. A "
"nicer model consists in applying a `pow` to the cosine in order to "
"**remap** it to something that is still condensed around 1.0 but "
"decreases more smoothly when we get away."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:231
msgid ""
"The larger the power exponent, the closest we are from the behavior of a "
"glossy mirror. The Phong model thus calls this power **hardness**:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:249
msgid ""
"The hardness parameter controls the extent of the specular highlight: the"
" higher it is the smallest the highlight."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:260
msgid "Consolidating"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:263
msgid ""
"We can now put back together the diffuse and specular contributions of "
"the lighting. We can slightly reorganize the code so that **only the "
"diffuse term** is multiplied by the base color. This is because for non-"
"metals, specular highlights are always white (we'll refine this in the "
"chapter about [physically-based materials](pbr.md)). We also add "
"constants to balance the diffuse and specular effects:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:288
msgid ""
"The constants `kd` and `ks` are properties of the material telling "
"whether it is more or less glossy. I suggest you expose these in the GUI "
"so that you can play with them!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:299
msgid "The material properties exposed in the Lighting GUI."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:305
msgid ""
"We have acquired in this chapter a **good intuition** of how to model the"
" specular highlight of material. The next chapters refine this by first "
"modifying the **local normal** against which the light bounces and second"
" by introducing a more **physically grounded** model of materials."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:1
msgid "A first uniform"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:5
#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:402
msgid ""
"*Resulting code:* [`step039`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step039)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:9
#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:406
msgid ""
"*Resulting code:* [`step039-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step039-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:12
#: ../../introduction.md:1
msgid "Introduction"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:15
#: ../../basic-compute/procedural-geometry/deformation.md:14
msgid "Motivation"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:17
msgid "If we look at our current shader, we see some hard-coded constants:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:24
msgid ""
"This is not very satisfying, what happens when we want to move the object"
" during the execution of the application? Or change the ratio because the"
" user resized the window?"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:26
msgid ""
"â˜ï¸ We could dynamically change the shader code and rebuild a new shader "
"module!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:28
msgid ""
"It would work, but **building a shader module takes time**. A lot of time"
" if we compare it to the budget for rendering a single frame (typically a"
" 60th of a second). Imagine we want to **animate** our scene and thus "
"change the `offset` at each frame!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:30
msgid "This is why a proper solution is to use a **uniform variable**."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:34
msgid ""
"A uniform is a global variable in a shader whose value is loaded from a "
"GPU buffer. We say that it is **bound** to the buffer."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:36
msgid ""
"Its value is **uniform** across the different vertices and fragment of "
"**a given call** to `draw`, but it change from one call to another one by"
" **updating** the value of the buffer it is *bound* to."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:38
msgid "To use a uniform, we need to:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:40
msgid "Declare the uniform in the *shader*."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:41
msgid "Create the *buffer* it is bound to."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:42
msgid "Configure the properties of the *binding* (a.k.a. the binding's *layout*)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:43
msgid "Create a *bind group*."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:45
#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:60
#: ../../basic-compute/compute-pipeline.md:406
msgid "Device limits"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:47
msgid ""
"In this chapter, we will require the following limits to be set up for "
"our device:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:58
#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:26
msgid "Shader side"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:61
msgid ""
"In order to animate our scene, we create a uniform called `uTime` that we"
" update at each frame with the current time, expressed in second (as "
"provided by `glfwGetTime()`)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:64
msgid ""
"I usually prefix uniform variables with a 'u' so that it is easy to "
"figure out when reading a long shader when a variable is a uniform rather"
" than a local variable."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:67
msgid ""
"As I said, a uniform is a global variable, so we can declare it in the "
"first line of our shader. A simple variable declaration in WGSL looks as "
"follows:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:74
msgid ""
"The `var` keyword can be labeled with an **address space**, which "
"controls how the variable is stored in the GPU (see [Memory "
"Model](/appendices/memory-model.md)). Here we state that the variable is "
"stored in the *uniform* address space:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:81
msgid ""
"Now we need to tell to which **buffer** the uniform is **bound**. This is"
" done by specifying a **binding index** with the `@binding(...)` WGSL "
"attribute."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:88
msgid ""
"We will then define in the C++ code which buffer is attached to the "
"binding #0. And actually, bindings are organized in **bind groups**, so "
"the binding of a uniform is specified by also providing an `@group(...)` "
"attribute:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:95
msgid ""
"We are now done with the declaration of the uniform variable, we can use "
"it like any other variable in our shader:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:109
msgid ""
"If you are not familiar with the [trigonometric "
"functions](https://en.wikipedia.org/wiki/Trigonometric_functions) like "
"`cos` and `sin`, be aware that the position $(\\cos(a), \\sin(a))$ is the"
" point on the circle of radius $1$ at angle $a$ (expressed in radians). "
"Thus, this formula makes the triangle move along a circle over time. It "
"is multiplied by $0.3$ in order to decrease the radius of this circle."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:112
msgid "Uniform buffer"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:115
msgid ""
"The uniform buffer is created like any other buffer, except we must "
"specify `BufferUsage::Uniform` in its `usage` field. We only need it to "
"contain 1 float for now."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:150
msgid "Then use `Queue::writeBuffer` to upload a value:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:166
msgid "Binding configuration"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:169
msgid ""
"There are two steps in the actual connection of the buffer to the "
"uniform. One is to **declare in the pipeline** that we want a binding, "
"and how exactly. This is the binding layout. And the second one is to "
"create the bind group and enable it (see next section)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:172
msgid ""
"This follows the same spirit than the distinction between the *vertex "
"buffer* and the *vertex buffer layout*."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:177
msgid ""
"The binding layout is specified through the `PipelineLayout` part of the "
"pipeline descriptor. The pipeline layout describes how all the "
"**resources** used by the render pipeline must be bound. A resource is "
"either a texture or a buffer, and its layout specifies to which index it "
"is bound to and properties like whether it is accessed as read-only or "
"write-only, etc."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:179
msgid ""
"A pipeline layout contains multiple **bind groups**, and a bind group "
"contains multiple **bindings**:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:219
#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:72
#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:174
#: ../../basic-3d-rendering/texturing/a-first-texture.md:255
msgid "Binding layout"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:221
msgid ""
"The `BindGroupLayoutEntry` could have been called `BindingLayout` imho. "
"The first setting is the binding index, as used in the shader's "
"`@binding` attribute. Then the `visibility` field tells which stage "
"requires access to this resource, so that it is not needlessly provided "
"to all stages."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:273
msgid ""
"The remaining of the binding layout depends on the type of resource. We "
"fill either the `buffer` field or the `sampler` and `texture` fields or "
"the `storageTexture` field. In our case it is a buffer:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:290
msgid ""
"Notice how I initialized the binding layout object with `= Default` "
"above. It is important because it sets in particular the `buffer`, "
"`sampler`, `texture` and `storageTexture` uses to `Undefined` so that "
"only the resource type we set up is used."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:293
#: ../../basic-compute/image-processing/mipmap-generation.md:435
msgid "Bind group"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:296
#: ../../getting-started/first-color.md:44
msgid "Creation"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:298
msgid ""
"A bind group contains the actual bindings. The structure of a bind group "
"mirrors the bind group layout prescribed in the render pipeline and "
"actually connects it to resources. This way, the same pipeline can be "
"reused as is in multiple draw calls depending on different variants of "
"the resources."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:334
msgid "The content of the binding itself is quite straightforward:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:349
msgid ""
"The fields `binding.sampler` and `binding.textureView` are only needed "
"when the binding layout uses them."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:354
msgid ""
"Okay we are now ready to connect the dots! It is as simple as setting the"
" bind group to use before the draw call:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:374
msgid ""
"It should be working already, though not moving because the content of "
"the buffer does not change yet. So simply add anywhere in the main loop "
"this:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:1
msgid "Dynamic uniforms"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:5
#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:270
msgid ""
"*Resulting code:* [`step044`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step044)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:9
#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:274
msgid ""
"*Resulting code:* [`step044-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step044-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:12
msgid ""
"Imagine we want to issue **two calls** to the `draw` method of our render"
" pipeline **with different values** of the uniforms, in order to draw two"
" WebGPU logos with different colors. Naively we could try this:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:56
msgid ""
"It is legal, but **will not do** what you expect. Remember that commands "
"are executed **asynchronously**! When we call methods of the `renderPass`"
" object, we do not really trigger operations, we rather build a command "
"buffer, that **is sent all at once** at the end. So the calls to "
"`writeBuffer` **do not** get interleaved between the draw calls as we "
"would like."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:58
msgid ""
"Instead, we need to use **dynamic uniform buffers**. This is a simple "
"option to turn on in the binding layout, but requires to be careful with "
"the buffer's **stride** (see below)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:63
msgid ""
"As always, we checkout first that the features we use are somewhere in "
"the `WGPULimits` struct and add our requirements to the device creation "
"code:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:70
msgid ""
"Another related limit is `minUniformBufferOffsetAlignment`, which we "
"already set as the minimum value supported by the adapter (see below)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:75
msgid ""
"When declaring the bind group layout, we can **set the buffer as "
"dynamically offset**:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:98
msgid ""
"The value of this dynamic offset will be later passed to "
"`renderPass.setBindGroup`."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:100
msgid "Buffer data"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:103
msgid ""
"The basic idea is to have a buffer that is **twice the size** of "
"`MyUniforms`. For the first draw call, we set the dynamic offset to 0 so "
"that it uses the first set of values, then we issue a second draw call "
"with an offset of `sizeof(MyUniforms)` to point to the second half of the"
" buffer."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:105
msgid ""
"There is **one thing to keep in mind** though: the value of the offset is"
" constrained to be **a multiple of** the "
"`minUniformBufferOffsetAlignment` limit of the device."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:115
msgid ""
"This means that the **stride** of the uniform buffer, i.e., the number of"
" bytes between the first `r` and the second `r` above, must be rounded up"
" to the closest multiple of `minUniformBufferOffsetAlignment`:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:147
msgid "Where the utility function is given by:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:159
msgid "We can now create the buffer and upload 2 different set of values:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:207
msgid "Drawing"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:210
msgid ""
"In the previous chapters we did not use the last two arguments of "
"`renderPass.setBindGroup`, namely `dynamicOffsetCount` and "
"`dynamicOffsets` array. They are the way to provide an offset that is "
"different for different calls. To change the offset, we re-bind the bind "
"group only with a different offset."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:212
msgid ""
"If we would have multiple dynamic uniforms, we would need to point to an "
"array, but since we only have one, we can just give the address of a "
"`dynamicOffset` variable:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:255
msgid ""
"Another solution could have been to create 2 different bind groups, "
"pointing to 2 different buffers. But the dynamic offset approach **scales"
" better** when issuing a large number of draw calls with varying "
"uniforms."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:261
msgid ""
"We are now quite comfortable with uniforms, we are ready to move on to "
"actual 3D shapes!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:266
msgid "We draw the scene twice with different values of the **dynamic uniforms**."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/index.md:1
msgid "Shader Uniforms"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:1
msgid "More uniforms"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:5
#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:256
msgid ""
"*Resulting code:* [`step043`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step043)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:9
#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:260
msgid ""
"*Resulting code:* [`step043-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step043-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:12
msgid ""
"In order to illustrate the flexibility of the uniform binding process, "
"let us add a second uniform variable, this time controlling the overall "
"color of our scene."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:14
msgid "There are multiple ways to add a second uniform:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:16
msgid "In a different bind group."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:17
msgid "In the same bind group but different binding."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:18
msgid ""
"In the same binding, by replacing the type of the uniform with a custom "
"struct."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:20
msgid ""
"The interest of using different bindings is to set a different "
"`visibility` depending on the binding. In our case, the time is only used"
" in the Vertex shader, while the color is only needed by the Fragment "
"shader, so this could be beneficial. However, we may decide to use the "
"time in the Fragment shader eventually, so we'll use the same binding."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:23
msgid ""
"Another reason is that different bindings should either point to "
"different buffers, or point in the same buffer at **an offset that is at "
"least** `deviceLimits.minUniformBufferOffsetAlignment`. By default, this "
"value is set to 256 bytes for me, and the minimum supported by my adapter"
" is 64. This would be a bit of a waste to add that much padding."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:29
msgid "Let us replace the `f32` uniform with a struct:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:57
msgid ""
"Of course depending on your use case you will find a name more relevant "
"than \"MyUniforms\", but let's stick to this for now."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:59
msgid "Buffer"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:62
msgid "On the CPU side, we define the very same struct:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:76
msgid "The initial buffer upload thus becomes:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:98
msgid ""
"More generally, you should replace all instances of `sizeof(float)` by "
"`sizeof(MyUniforms)` (when setting `bufferDesc.size`, "
"`bindingLayout.buffer.minBindingSize` and `binding.size`)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:100
msgid "Updating the value of the buffer now looks like this:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:118
msgid ""
"And actually we can be more subtle, to only upload the bytes related to "
"the `time` field:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:134
msgid "Similarly we can update only the color bytes:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:154
msgid ""
"Better yet, if we forget the offset, or want to be flexible to the "
"addition of new fields, we can use the built-in `offsetof` macro:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:177
msgid "The only thing to change in the binding layout is the visibility:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:183
msgid "Memory Layout Constraints"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:186
msgid "Alignment"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:188
msgid ""
"There is one thing I have omitted until now: the architecture of the GPU "
"imposes some constraints on the way we can organize fields in a uniform "
"buffer."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:190
msgid ""
"If we look at [the uniform layout "
"constraints](https://gpuweb.github.io/gpuweb/wgsl/#address-space-layout-"
"constraints), we can see that **the offset** (as returned by `offsetof`) "
"of a field of type `vec4f` **must be a multiple** of the size of `vec4f`,"
" namely 16 bytes. We say that the field is **aligned** to 16 bytes."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:192
msgid ""
"In our current `MyUniforms` struct, this property is **not verified** "
"because `color` as an offset of 4 bytes (`sizeof(float)`), which is "
"obviously not a multiple of 16 bytes! An easy fix is simply to swap the "
"`color` and `time` fields:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:214
msgid ""
"And **don't forget** to apply the same change to the struct defined in "
"the shader code!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:217
msgid ""
"If you used the `offsetof` macro to perform partial update of the uniform"
" buffer, you are good to go. But if you did not, make sure to reflect "
"this reordering of the fields of `MyUniforms` everywhere you relied on "
"it!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:220
msgid "Padding"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:222
msgid ""
"Another constraint on uniform types is that they must be [host-"
"shareable](https://gpuweb.github.io/gpuweb/wgsl/#host-shareable), which "
"comes with [a constraint on the total structure "
"size](https://gpuweb.github.io/gpuweb/wgsl/#alignment-and-size)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:224
msgid ""
"Basically, the total size must be **a multiple of the alignment size of "
"its largest field**. In our case, this means it must be a multiple of 16 "
"bytes (the size of `vec4f`)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:226
msgid ""
"Thus we add **padding** to our structure, namely an unused attribute at "
"the end that fills in extra bytes:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:238
msgid "And this finally works!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:243
msgid "The WebGPU logo, tinted with our new uniform color."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:249
msgid ""
"We have seen here that providing multiple uniforms is commonly done by "
"actually providing a single uniform that is a structure of multiple "
"fields. Importantly these fields have memory alignment constraints."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:252
msgid ""
"I started writing [an online utility tool](https://eliemichel.github.io"
"/WebGPU-AutoLayout) to automatically derive a C++ struct that matches a "
"WGSL struct. Note that it uses the type `vec3` from the GLM library "
"instead of `std::array<float,3>` but it is easy to replace."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:1
msgid "Camera control"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:5
#: ../../basic-3d-rendering/some-interaction/camera-control.md:276
msgid ""
"*Resulting code:* [`step090`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step090)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:9
#: ../../basic-3d-rendering/some-interaction/camera-control.md:280
msgid ""
"*Resulting code:* [`step090-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step090-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:12
msgid ""
"The very first kind of interaction we usually need with a 3D scene is to "
"**change the point of view**. There are many different types of camera "
"control, depending on the use case, here are a few examples:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:14
msgid ""
"**First person:** The camera position is fixed, and its orientation "
"follows the mouse cursor. This is what is used in first-person video "
"games like shooters."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:15
msgid ""
"**Turntable:** This is what modeling tools typically use: the camera "
"**orbits** around a focus point that it remains centered on."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:16
msgid ""
"**Trackball:** Unlike the turntable, the trackball does not give a "
"particular meaning to the \"up\" axis. This enables one to orbit around "
"an object without any form of [gimbal "
"lock](https://en.wikipedia.org/wiki/Gimbal_lock)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:19
msgid ""
"There are different flavors of *turntable* control depending on how the "
"center of rotation is chosen: it may be fixed, or set as the point of the"
" 3D surface that was clicked at the beginning of each interaction."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:22
msgid ""
"We focus here on the case of the **turntable** model, which I find the "
"most confortable one for a 3D object viewer. Imho most real-life objects "
"have a notion of \"up\" and \"down\", which justifies that the view "
"controller does as well."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:24
msgid "Event handlers"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:27
msgid ""
"Similarly to what we did for the resize, we wire up 3 new GLFW window "
"events:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:57
msgid "Camera state"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:60
msgid ""
"Instead of manipulating the camera view directly as a matrix made of 16 "
"coefficients, we store a camera state that is **closer to what user input"
" affects**:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:73
msgid "We add such a state to our `Application` class."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:81
msgid ""
"We then create a (private) method that converts this state into an actual"
" matrix. We call this any time the camera state is modified:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:123
msgid ""
"You may invoke `updateViewMatrix()` at the end of `initUniforms()` to "
"ensure that the original view matrix is consistent with the camera state."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:126
msgid "Controller"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:129
msgid ""
"An interaction with the camera controller consists in the following "
"sequence of events:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:131
msgid "The mouse is **pressed**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:132
#: ../../basic-3d-rendering/some-interaction/camera-control.md:133
#: ../../basic-3d-rendering/some-interaction/camera-control.md:135
msgid "The mouse is **moved**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:134
msgid "[...]"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:136
msgid "The mouse is **released**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:138
msgid ""
"When the mouse is pressed, we save some information about the current "
"state, that we will need to update the view at each subsequent move. We "
"call this the `DragState`."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:140
msgid ""
"When the mouse is released, we forget about this information to prevent "
"new moves from affecting the view point."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:190
msgid "We also add a simple interaction when the use scrolls, to zoom in/out:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:200
msgid "Bonus: Inertia"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:203
msgid ""
"A nice addition to the **look & feel** of your viewer is to add some "
"**momentum** to the interaction, to fade out the user's gesture."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:205
msgid ""
"For this we add to the drag state the current **velocity** of the angle "
"rotation, and add a little bit of it to the rotation at the next frame."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:230
msgid ""
"We need to define a `updateDragInertia()` that is called at each frame, "
"not just when the user moves the mouse:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:269
msgid ""
"The camera controller is an important step needed before moving on to "
"lighting, because we will need to inspect our model in details."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:271
msgid ""
"Of course feel free to adapt this to your own camera model. With this "
"example you can already do a lot and you should be able to easily add "
"some keyboard interaction on your own using "
"[`glfwSetKeyCallback`](https://www.glfw.org/docs/3.0/group__input.html#ga7e496507126f35ea72f01b2e6ef6d155)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:273
msgid ""
"Next we see the last bit of general purpose code, to get the base for a "
"**user interface**, after which we'll move back to 3D-specific stuff!"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/index.md:1
msgid "Some interaction"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:1
msgid "Lighting control"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:5
#: ../../basic-3d-rendering/some-interaction/lighting-control.md:394
msgid ""
"*Resulting code:* [`step100`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step100)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:9
#: ../../basic-3d-rendering/some-interaction/lighting-control.md:398
msgid ""
"*Resulting code:* [`step100-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step100-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:12
msgid ""
"Now that we have elements of GUI, we can use them to expose for instance "
"the **lighting settings** to the user. We want them to be able to **live "
"tweak** the direction and color of our light sources."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:14
msgid "Recap on basic shading"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:17
msgid ""
"Let's first recap what we have seen in the [Basic shading](../3d-meshes"
"/basic-shading.md) chapter."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:19
msgid "The shaded look of a surface element depends on its **normal**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:20
msgid ""
"This look also depends on **light sources**, and in particular on their "
"direction."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:21
msgid ""
"The most basic shading we tested with is `shading = max(0.0, "
"dot(lightDirection, normal))`. This is a (lambertian) **diffuse** "
"shading."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:24
msgid ""
"For more details about the rational behind this simple diffuse model, you"
" can consult this nice introduction on Scratchpixel: [Diffuse and "
"Lambertian Shading](https://www.scratchapixel.com/lessons/3d-basic-"
"rendering/introduction-to-shading/diffuse-lambertian-shading.html)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:27
msgid ""
"We can plug this with the texture sampling, by using the texture as the "
"base color before applying the shading:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:55
msgid "I renamed what was called `gradientTexture` into `baseColorTexture`."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:61
msgid "The boat model with some basic lighting."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:64
msgid "Lighting uniforms"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:67
msgid ""
"To facilitate the further testing of lighting and materials in the next "
"chatpers, let's **make the light sources dynamic** and connect them to "
"our GUI."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:69
msgid ""
"Instead of hardcoding the light settings, we would like to pass them "
"through a uniform:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:105
msgid "For this, we need to:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:107
msgid "Create a new **uniform buffer**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:108
msgid "Create a new **binding** in the bind group for this uniform."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:109
msgid "Add this binding to the **bind group layout**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:111
#: ../../basic-compute/image-processing/convolution-filters.md:150
msgid "Uniforms"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:113
msgid ""
"Before anything, we replicate the `LightingUniforms` struct in the C++ "
"code:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:127
msgid ""
"Note how I turned the direction and color to `vec4` instead of `vec3`. "
"This is because of [alignment rules](https://www.w3.org/TR/WGSL"
"/#alignment-and-size): a `vec3` is aligned as if it was a `vec4`."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:130
msgid ""
"We then use this structure to create an attribute, and define its GPU-"
"side counterpart:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:146
msgid "And we create 3 methods to manage this new uniform buffer:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:155
msgid "These are very similar to our other uniforms:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:221
msgid ""
"We will see later when to call `updateLightingUniforms()`, but before "
"that we need to add bindings for this new uniform buffer."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:223
#: ../../basic-compute/image-processing/mipmap-generation.md:206
msgid "Bindings"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:225
msgid "In `initBindGroup`, add the new binding:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:253
msgid ""
"Of course we must also add this to the bind group **layout**! Since is is"
" very common to change both the bind group and its layout, I like to "
"create a `initBindGroupLayout()` method that sits next to the "
"`initBindGroup()` in the code, althrough it is not called exactly before:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:268
msgid ""
"Extract this from `initRenderPipeline()`, then add our new lighting "
"uniform buffer:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:289
msgid ""
"Since we are adding a new uniform buffer, don't forget to update the "
"required limits:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:296
#: ../../basic-compute/image-processing/convolution-filters.md:84
msgid "GUI"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:298
msgid ""
"Let us now connect the GUI by replacing the \"Hello, world\" panel in "
"`updateGui()`:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:311
msgid ""
"The `glm::value_ptr` function returns a pointer to where the glm object's"
" raw data is stored, which is what ImGui needs to operate. In practice "
"for vectors it is equivalent to using the address of the vector object "
"itself."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:314
msgid ""
"This changes the value of `m_lightingUniforms` when the user tweaks "
"sliders. In order to reflect these changes in the GPU-side uniforms, we "
"copy at each frame the values that the GUI manipulates to the GPU-side "
"buffer."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:326
msgid "The UI is connected to the lighting uniforms."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:329
msgid "Complement"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:332
msgid "Custom GUI input"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:334
msgid ""
"This `ImGui::DragFloat3` input is not ideal for a direction. It is not so"
" intuitive, and does not ensure that the direction vector always has a "
"length of 1. We can easily create our own input `ImGui::DragDirection` to"
" expose the direction as 2 polar angles:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:349
msgid "It can be used as follows:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:355
msgid "Slight optimization"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:357
msgid ""
"Instead of uploading the lighting uniform buffer at each frame even when "
"nothing changes, we can get from ImGui the information of whether the "
"fields changed:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:385
msgid "In this chapter we have:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:387
msgid "Connected diffuse shading with textures,"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:388
msgid "Connected lighting with GUI."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:389
msgid "Created a custom GUI."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:391
msgid "Okey, we are now ready to dive into material models for real!"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:1
msgid "Refactoring"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:5
#: ../../basic-3d-rendering/some-interaction/refactoring.md:276
msgid ""
"*Resulting code:* [`step080`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step080)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:9
#: ../../basic-3d-rendering/some-interaction/refactoring.md:280
msgid ""
"*Resulting code:* [`step080-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step080-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:12
msgid ""
"The goal of this chapter is to **add some interactivity** to our viewer. "
"From a WebGPU standpoint, we know everything we need for this. For "
"instance enabling the user to turn around the object using the mouse is "
"only about **updating the view matrix**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:14
msgid ""
"However, it is also the occasion to **organize a bit our code base**, "
"which we have not been discussing much until now. It was not the primary "
"topic, and the size of the code was still manageable as mostly a big main"
" function, but this never holds for bigger applications."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:16
msgid "An application structure"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:19
msgid "Main class"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:21
msgid ""
"I am going to **avoid over-engineering** things since each use case is "
"different, so you will customize the details for your needs. Nevertheless"
" it always starts with a class (or struct) that holds all the global "
"state of the application."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:23
msgid ""
"We implement this in two new files `Application.h` and `Application.cpp`,"
" where the behavior of the application is distributed across **event "
"handlers**. To make this logic clear, handles start with \"on\", like "
"`onFrame`. We can already think of three events: init, frame and finish."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:50
msgid ""
"I prefix private attribute names with `m_` to better distinguish them "
"from local variables when reading the code. This is a common practice "
"(some people also prefer using only `_foo`, or full caml case `mFoo`)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:54
msgid ""
"When using the C++ wrapper, it is important to initialize WebGPU handles "
"to null (e.g., `m_instance = nullptr`) because they have no default "
"constructor. Otherwise you will experience this kind of error:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:61
msgid ""
"Before actually implementing these methods, we can already try draft how "
"this will be used in our `main` function:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:80
msgid ""
"We hence see that we also need to add a `isRunning` method, that simply "
"calls `glfwWindowShouldClose` behinds the hoods but without exposing the "
"GLFW window to the \"client\" code (namely the main function)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:119
msgid ""
"Do not forget to add these file (most importantly the .cpp) to the source"
" files listed in `CMakeLists.txt`:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:129
msgid "Initialization steps"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:131
msgid ""
"The part of our code that is the **most monolithic** is by far the "
"initialization step. We thus split it into various (private) methods:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:147
msgid ""
"And each `initSomething` step comes with a `terminateSomething` that is "
"called at the end in reverse order:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:162
msgid ""
"This way, it is easier to keep track of what must be released at the end "
"of the application. You can also group the attributes by step when "
"declaring them in `Application.h`."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:164
msgid ""
"I let you **move the largest chunks of code by yourself**, otherwise this"
" chapter would look like a big listing. Most parts of the old `main.cpp` "
"should end up in `Application.cpp`; you can check it against [the "
"reference code](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step080) from this chapter of course."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:166
msgid ""
"The next sections present some **additional design choices** I made on "
"the course of refactoring the code. You may or may not follow them."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:168
msgid "Design choices"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:171
msgid "Resource manager"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:173
msgid ""
"Our three procedure for loading external resources can be moved into a "
"separate namespace or class with only static members."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:175
msgid ""
"We create a `ResourceManager.h` and `ResourceManager.cpp` files, add them"
" to the CMakeLists and move resource loaders there."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:213
msgid "Library implementation"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:215
msgid ""
"As we start including our libraries in multiple files, we must remember "
"that the `#define FOO_IMPLEMENTATION` that some of them require **must "
"appear in only one** C++ file, and the include must be placed before any "
"other one that may recursively include it."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:217
msgid ""
"To avoid some unexpected complication, I recommend to create a file "
"`implementations.cpp` to be the place for this and only this:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:231
msgid "Callback handles"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:234
msgid ""
"This section is **specific to the WebGPU C++ wrapper** I provide. When "
"using the raw C API, the callback cannot be a lambda function and must "
"rather be defined in the global scope."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:237
msgid ""
"In order to prevent the uncaptured error callback from being freed too "
"early, we need to store the handle returned by "
"`device.setUncapturedErrorCallback`. So far this was just done by "
"defining a variable `h` that lives for the whole main function:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:248
msgid ""
"Since we no longer define this in the main function directly but rather "
"in the `Application`'s init, we must store the `h` handle as a class "
"member:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:266
msgid ""
"This way, the callback is released only when the Application object is "
"destroyed."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:271
msgid ""
"We now have a much more mature code base, that will be way easier to "
"extend as we introduce new features in the next chapters!"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:273
msgid ""
"Remember that any time you add something in an `init` step, you should "
"likely release it in the matching `terminate` method."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:1
msgid "Resizing the window"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:5
#: ../../basic-3d-rendering/some-interaction/resizing-window.md:208
msgid ""
"*Resulting code:* [`step085`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step085)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:9
#: ../../basic-3d-rendering/some-interaction/resizing-window.md:212
msgid ""
"*Resulting code:* [`step085-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step085-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:12
msgid ""
"When we introduced the swap chain, **we prevented the window from "
"resizing** by setting the `GLFW_RESIZABLE` window \"hint\" to false, "
"because the swap chained is tied to a specific size."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:14
msgid ""
"Now that our code is better organized, it becomes easy to **get rid of "
"this limitation**: in this chapter, we restore the possibility to resize "
"the window:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:20
msgid ""
"To do so, we add a `onResize` handler that we call when the window is "
"resized, and **rebuild the swap chain** with the new resolution. And we "
"also need to resize the **depth buffer** by the way."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:22
msgid "Callback setup"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:25
msgid "Let us first add the `onResize()` method:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:35
msgid ""
"GLFW provides a mechanism for setting a callback to be invoked each time "
"the window size changes: "
"[`glfwSetFramebufferSizeCallback`](https://www.glfw.org/docs/3.0/group__window.html#ga3203461a5303bf289f2e05f854b2f7cf)."
" Naively, we could consider the following:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:49
msgid ""
"**This cannot work** because a non-static class method like "
"`Application::onResize` needs a value of `this` when it is called, so it "
"cannot be used as a function pointer (which "
"`glfwSetFramebufferSizeCallback` expects)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:51
msgid ""
"The usual trick here is to define a simple callback function that does "
"nothing but to call the `onResize()` method."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:53
msgid "ðŸ¤” But how do I specify \"this\"? Should I use a global variable?"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:55
msgid ""
"It is precisely for this pattern that GLFW provides a **user pointer**, "
"namely an arbitrary value that can be associated to a window. Since the "
"callback receives the window as first argument, we can get the user "
"pointer back and use it:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:82
msgid ""
"If we want to make this more compact and avoid creating a dedicated "
"function, we can use a **lambda** when calling "
"`glfwSetFramebufferSizeCallback`:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:101
msgid ""
"I did not show the lambda version right away because it is slightly "
"misleading: **it is tempting** to use the **capturing context** of the "
"lambda (the `[]` before the lambda's arguments) to provide `this` to the "
"callback."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:103
msgid ""
"However, **only non-capturing lambdas** may be casted to the raw function"
" pointer that GLFW expects for a callback. This remark goes for any C API"
" by the way."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:106
msgid "Resize event handler"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:109
msgid "Swap Chain and Depth Buffer"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:111
msgid "With our new design, the content of `onResize()` is pretty simple:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:126
msgid ""
"On this simple example, **managing the lifetime** of WebGPU objects "
"(e.g., destroying before rebuild them, releasing at the end of the "
"application, etc.) can be done manually. But since this is in general "
"quite **error-prone**, the [RAII](../../advanced-techniques/raii) chapter"
" presents a common C++ **design pattern** that makes this easier."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:129
msgid ""
"However, we need to **update** `initSwapChain()` and `initDepthBuffer()` "
"to take into account **the actual size of the window**, rather than the "
"hardcoded $(640,480)$."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:154
msgid "Camera Projection"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:156
msgid ""
"If you look for \"640\" in your code to ensure nothing relies any more on"
" the original window size, you'll find that **we use the size when "
"defining the camera projection**. Thus the `onResize` function must also "
"update the projection matrix uniform:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:165
msgid "Where `updateProjectionMatrix` is a new private method:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:205
msgid ""
"This pattern that we used to connect the raw GLFW resize event to our C++"
" idiomatic object-oriented application skeleton is **a commonly used "
"pattern**: we will do the same for all the other interaction callbacks we"
" need. We see in the next chapter the case of mouse button and mouse move"
" callbacks to get the **camera controller**!"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:1
msgid "Simple GUI"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:5
#: ../../basic-3d-rendering/some-interaction/simple-gui.md:262
msgid ""
"*Resulting code:* [`step095`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step095)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:9
#: ../../basic-3d-rendering/some-interaction/simple-gui.md:266
msgid ""
"*Resulting code:* [`step095-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step095-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:13
#: ../../basic-3d-rendering/some-interaction/simple-gui.md:270
msgid ""
"*Resulting code:* [`step095-dawn`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step095-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:16
msgid ""
"Multiple solutions exist for writing *graphical user interfaces* (GUI), "
"i.e., buttons, text inputs, value sliders and so on."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:18
msgid ""
"For applications that are mostly about these inputs, it is common to use "
"**a whole *framework*** as a base, like [Qt](https://www.qt.io/), "
"[GTK](https://www.gtk.org/), [wxWidgets](https://www.wxwidgets.org/), "
"[WinUI](https://microsoft.github.io/microsoft-ui-xaml/), etc. These "
"usually manage the main application loop by themselves and are heavy "
"dependencies."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:20
msgid ""
"But in the case of video games or prototypes like ours, one usually turns"
" towards **more lightweights solutions**, among which [Dear "
"ImGui](https://github.com/ocornut/imgui) is a very popular choice."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:23
msgid ""
"ImGui does not try to give a OS-native look to your app. Instead, it "
"focuses on being very **easy to integrate** to any existing project, and "
"**easy to program with**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:25
msgid ""
"This also comes at the price of redrawing the whole GUI from scratch at "
"each frame while frameworks usually only update what is needed."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:28
msgid "Setting up ImGui"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:31
msgid ""
"ImGui fully supports using WebGPU as a backend with both wgpu-native and "
"Dawn since its [version "
"1.89.8](https://github.com/ocornut/imgui/archive/refs/tags/v1.89.8.zip). "
"Unzip it as a `imgui/` directory, remove `examples`, `doc` and `.github` "
"(or keep them but we don't need them)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:33
msgid ""
"ImGui does not provide a `CMakeLists.txt` but it is straightforward to "
"write it ourselves (still in the `imgui/` directory):"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:66
msgid "Then in your root `CMakeLists.txt`, as usual:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:79
msgid "Overview"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:81
msgid ""
"ImGui interface is redrawn at each frame, following a very imperative "
"style:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:103
msgid ""
"Available functions can be found in "
"[`imgui.h`](https://github.com/ocornut/imgui/blob/master/imgui.h), and "
"additional help is given in [their "
"wiki](https://github.com/ocornut/imgui/wiki)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:107
msgid ""
"We however **need to set-up some boilerplate**, both when starting the "
"application and before/after defining the GUI at each frame."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:109
msgid ""
"To make things clearer, we isolate GUI-related code into specific methods"
" (note that we need to access the render pass in `updateGui`):"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:146
msgid ""
"Here comes the boilerplate itself. For each step (global init, frame "
"init, frame render) there is usually the \"pure\" ImGui function as well "
"as the backend functions. Things are decoupled this way because ImGui can"
" be used together with other libraries than GLFW and WebGPU."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:188
msgid "Example of GUI"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:190
msgid "This ImGui's basic example, that shows some **typical use cases**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:192
msgid ""
"Note that variables are defined as **static** here, so that they are "
"initialized only once and then **\"remembered\"** across frames."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:221
msgid "Capabilities"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:223
msgid "Using ImGUI requires `maxBindGroups` to be at least 2."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:230
#: ../../basic-3d-rendering/texturing/a-first-texture.md:116
#: ../../getting-started/first-color.md:243
msgid "Misc"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:233
msgid ""
"You may have noticed when playing with sliders that while ImGui is "
"reacting to your mouse, **the camera controller also receives the "
"events**, which is a bit annoying."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:235
msgid ""
"To prevent this, we can use the `io.WantCaptureMouse` variable that ImGui"
" turns to true when it detected that the user interacts with the widgets."
" When so, we ignore mouse clicks in the camera controller:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:253
msgid "A basic GUI with ImGUI"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:259
msgid ""
"Congratulations, we now have all the tools we need to easily test various"
" parameters and interact with the 3D scene, we can then move on to the "
"lighting and materials!"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:1
msgid "A first texture"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:5
#: ../../basic-3d-rendering/texturing/a-first-texture.md:483
msgid ""
"*Resulting code:* [`step060`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step060)"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:9
#: ../../basic-3d-rendering/texturing/a-first-texture.md:487
msgid ""
"*Resulting code:* [`step060-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step060-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:12
msgid ""
"Textures play **a very important role** in a rendering pipeline, both for"
" 2D or 3D graphics."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:14
msgid ""
"**Theoretically**, a GPU buffer could be used to store the texture data, "
"and the shader would compute at which offset within this buffer a given "
"pixel belongs. But this would be **inefficient** (and maybe not even "
"supported on some devices). Texture access is actually handled by "
"**dedicated fixed units** of the GPU."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:16
msgid ""
"This is why although all types of **resources** live in the VRAM, "
"**buffers**, **textures** and **storage textures** are different objects "
"in the WebGPU API (as well as in all other graphics APIs)."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:18
msgid "Texture creation"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:21
msgid ""
"Let us get back to the texture that we had to create for the depth "
"buffer, and **copy it** to create a new texture in the initialization of "
"the app:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:40
msgid "And add right away the texture destruction at the end of the app:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:56
msgid "Size"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:58
msgid ""
"A simple setting is the size of the texture (which I arbitrarily set to a"
" power of 2 because it usually helps the GPU in aligning memory):"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:76
msgid ""
"A texture can have $1$, $2$ or $3$ dimensions. Meaning it is either a 1D "
"color gradient, a 2D image of a 3D grid of voxels."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:78
msgid "ðŸ¤” When should I use a 1D texture rather than a simple buffer?"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:80
msgid ""
"A texture allows to **sample** values **continuously**. For instance even"
" if your 1D texture has only 10 texels (a **texel** is a pixel of a "
"texture), you may sample its value at a **non-integer coordinate** $4.5 /"
" 10$ and you would automatically get a mix of texels 4 and 5."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:82
msgid ""
"Another powerful feature of textures is the possibility to sample the "
"**average** value over a neighborhood of a texel, thanks to **mip-maps**."
" These make a texture **contain multiple images** (also called "
"*subresources*). So the texture size is not only the `size` field but "
"also the number of mip-maps given by `mipLevelCount`."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:84
msgid ""
"We'll get to why this is useful **later on**, for now we set the mip "
"level count to the minimum value $1$ to deactivate this feature:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:90
msgid ""
"Textures are also able to store **more than one color per texel**, thanks"
" to **multisampling**. This is typically used for handling anti-aliasing "
"([MSAA](https://en.wikipedia.org/wiki/Multisample_anti-aliasing)). Again,"
" we do not use this for our texture:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:96
msgid ""
"Both the mip level count and the sample count have an **impact on the "
"memory size** of the texture, so when not using these features, setting "
"them to $1$ (the minimum) saves memory."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:98
msgid "Format"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:100
msgid ""
"The texture format indicates at the same time the **number of channels** "
"in the texture (R, RG, RGB, RGBA), **their order** (RGBA, BGRA, etc.), "
"and **the way each channel is encoded**, including the number of bits and"
" the scale."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:102
msgid ""
"For instance, `RGBA8Unorm` means 4 channels (RGBA), with 8 bits per "
"channel which represent unsigned values (U) normalized (norm) so that "
"they are manipulated as real numbers in the range $(0,1)$ (instead of "
"integers in $(0,255)$ for instance)."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:118
msgid ""
"Like buffers, textures must **declare their intended usage**, so that "
"they can be places in more appropriate parts of the memory by the GPU's "
"memory allocator."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:120
msgid ""
"In order to be able to **copy pixel data from C++**, the texture needs "
"the `CopyDst` usage. And we will then use the texture by **sampling it "
"from a shader**, so it must be declared with the `TextureBinding` usage:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:134
msgid "Lastly, we initialize the texture view settings to 0 (more on this later):"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:141
msgid "Uploading texture data"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:144
msgid ""
"We created a texture, which allocated memory in VRAM (i.e., on the GPU). "
"But this remains an **uninitialized chunk of memory**, to which we must "
"set data. This is typically done by **uploading** it from the CPU."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:146
msgid "Test data"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:148
msgid ""
"Our first texture will be **a simple gradient**, which we can define in "
"our C++ code as follows:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:167
msgid "The test texture that we generate in our C++ code."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:170
msgid "Write texture"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:172
msgid ""
"Uploading this pixel data to the texture uses `Queue::writeTexture`, to "
"be called once both the texture and its data are created. But a call to "
"`Queue::writeTexture` is a bit more complicated than "
"`Queue::writeBuffer`: since write texture has a lot of arguments, they "
"are grouped in substructures:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:204
msgid "Destination"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:206
msgid ""
"The `writeTexture` procedure writes **only one image** (subresource of "
"the texture) at a time. The argument `destination.mipLevel` tells which "
"one we target, and in our case we have only **one mip level**."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:208
msgid ""
"The `destination.origin` is the equivalent of the **offset** argument of "
"`Queue::writeBuffer`. Together with the `writeSize` argument, it tells "
"**which part of the image** gets updated, so that we may update only a "
"small part of it. Finally, the aspect is not relevant for color textures."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:228
msgid "Source"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:230
msgid ""
"The `source` layout tells how to read from the buffer. The `offset` tells"
" where the data starts after the CPU data pointer we provide in "
"`writeTexture`."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:232
msgid ""
"The `bytesPerRow` tells the stride, i.e., the number of bytes between two"
" consecutive rows in the CPU data."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:234
msgid ""
"And the `rowsPerImage` is the the height of an image, it is important "
"when uploading multiple images at once (only possible when uploading a "
"*texture array*, which we do not use here)."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:236
msgid "In our case, the data is contiguous, so we set this as follows:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:245
msgid ""
"When loading data from an image file, rows might be aligned to a round "
"number of bytes, hence `source.bytesPerRow` would be slightly bigger than"
" `4 * textureDesc.size.width`. This is also needed when uploading very "
"small images because there is **a minimum value** for `bytesPerRow` that "
"is set to 256 by the API."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:248
msgid "Texture drawing"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:251
msgid ""
"Great, we have loaded a texture to the GPU memory... But what can we do "
"with it? How can we check that it was correctly uploaded?"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:253
msgid ""
"Unfortunately, there is no quick way to copy a texture to the texture "
"view `nextTexture` returned by the swap chain. Instead, we **bind our "
"texture to the render pipeline** and sample it from our shader."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:257
msgid ""
"This binding is close to the uniform buffer binding. We first need to add"
" it to the bind group **layout**. We also slightly reorganize our code to"
" handle multiple bindings:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:314
msgid "We can now specifically setup our texture binding layout:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:336
msgid ""
"The visibility is set to the **fragment shader only**, we will not sample"
" this texture in the vertex shader."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:338
msgid ""
"The texture **sample type** tells which variable type will be returned in"
" the shader code when sampling the texture. Since our texture uses a "
"normalized format (`RGBAUnorm`), its values are represented as floats."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:340
msgid "Binding"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:342
msgid ""
"Once both the pipeline layout and the texture itself are created, we can "
"alter the bind group to add the texture binding (and again slightly "
"reorganize):"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:387
msgid ""
"As you can see, we are not allowed to directly pass a texture to the "
"binding, we rather need to create a **texture view**. Create it right "
"after the creation of the texture itself:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:419
msgid ""
"We can now declare a global variable of type `texture_2d<f32>` in our "
"shader, attached to binding 1 in bind group 0. The function `textureLoad`"
" returns the raw texel value at a given coordinate, and the "
"`@builtin(position)` input of the frament shader is the pixel screen "
"coordinate:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:430
msgid ""
"Sampling from a texture in a shader requires to set a new device limit, "
"to be increased each time you add a texture:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:437
msgid ""
"In order to better see the result, we make sure that there is a fragment "
"for each pixel by drawing a plane that covers the whole screen. Load the "
"file [plane.obj](../../data/plane.obj) and set your matrices to:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:452
msgid "Our first texture displayed by drawing a full-screen quad."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:455
msgid "Feel free to play with other formulas to create the texture data:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:474
msgid "Changing the pixel array indeed changes the displayed image."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:480
msgid ""
"We have seen **how to create** a texture and **how to access** its pixels"
" from a shader. In the next chapter we will see **how to map a texture "
"onto a 3D mesh**. And we will realize that we miss a very important "
"ingredient: to fully benefit from the power of a texture, it must be "
"accessed through a **sampler**."
msgstr ""

#: ../../basic-3d-rendering/texturing/index.md:1
msgid "Texturing"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:5
#: ../../basic-3d-rendering/texturing/loading-from-file.md:524
msgid ""
"*Resulting code:* [`step075`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step075)"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:9
#: ../../basic-3d-rendering/texturing/loading-from-file.md:528
msgid ""
"*Resulting code:* [`step075-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step075-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:12
msgid ""
"The goal of this chapter is to **summarize everything we have done** to "
"write a utility function `loadTexture` that creates a texture from a "
"file."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:30
msgid "The stb_image library"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:32
msgid ""
"Once again, to **load standard file format**, we better use existing code"
" than study the specifications ourselves. We use here the `stb_image` "
"single-header library, from the very handy "
"[stb](https://github.com/nothings/stb) set of libraries. It supports all "
"basic image types (png, jpg, bmp, ...)."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:34
msgid ""
"Save "
"[stb_image.h](https://raw.githubusercontent.com/nothings/stb/master/stb_image.h)"
" in your source tree and include it in your main file:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:41
msgid ""
"This provides two functions: `stbi_load` and `stbi_image_free`, to be "
"used as follows:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:56
msgid ""
"The stb_image library triggers a few warnings, that need to be "
"deactivated if you want to treat warnings as errors."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:65
msgid ""
"Note that this disables the warning for your files as well. A solution to"
" only disable warnings for stb_image would be to have the file with "
"`STB_IMAGE_IMPLEMENTATION` isolated in its own CMake target."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:68
msgid "loadTexture"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:70
msgid ""
"With the dimensions of the texture in hand, we can create the texture "
"object."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:129
msgid ""
"We still need to write the `writeMipMaps` auxiliary function. The first "
"mip level is easy, it can directly use the `data` vector:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:187
msgid "Texture view"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:189
msgid ""
"Before dealing with mip maps, we'd like to test our `loadTexture` for mip"
" level 0. But for this we still miss one part: the **texture view**."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:191
msgid ""
"To create the texture view that is used by the sampler, we need the **mip"
" level count** and **format**. We can modify the `loadTexture` either to "
"return these information, or as I do here to create an appropriate "
"texture view and return it."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:193
msgid ""
"This is made **optional** by passing the returned view by a pointer, that"
" is ignored if null."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:239
msgid "We can thus load our texture as follows:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:267
msgid ""
"Copy any image ([example](../../images/cobblestone_floor_08_diff_2k.jpg))"
" to `resources/texture.jpg` and you should see it loaded on the 3D plane!"
" You may have to increase the maximum image size in the **device "
"limits**:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:276
msgid ""
"Here the texture view pointer passed to `loadTexture` is `&textureView`, "
"namely the address of the variable `textureView`. Even if the variable "
"itself is initialized to null, **its address**, called `pTextureView` in "
"the function, **is not null**, and thus a view is created and returned."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:279
msgid "Generating mip-maps"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:281
msgid ""
"Let us now come back on the `writeMipMaps` function. We can import in "
"here the loop of `writeTexture` we implemented to load mip levels in the "
"previous chapter:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:423
msgid ""
"Lastly, we **automatically infer the mip level count** from the texture "
"size, as noted in the previous chapter:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:466
msgid "A textured loaded from a file, with proper mip-mapping."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:469
msgid "Textured model"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:471
msgid ""
"Let us finish this chapter with a nice textured 3D model. Unzip "
"[fourareen.zip](../../data/fourareen.zip) in your resource directory "
"(special thanks to Scottish Maritime Museum for [sharing this "
"model](https://sketchfab.com/3d-models/venus-a-shetland-fourareen-"
"ce4d6915e1d041459e08f2d8da521e86)!) and change the two loading lines:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:489
msgid ""
"If you try this, you'll see that the texture is not correctly projected "
"onto the geometry. A first thing is to make sure you removed the UV "
"multiplication we added in the previous chapter to explore the effect of "
"the sampler:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:495
msgid ""
"We also need to increase again the vertex buffer size limit, because this"
" mesh has almost 150k vertices:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:501
msgid "And finally here is a suggestion of view point:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:513
msgid "A textured 3D model rendered in our WebGPU viewer."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:519
msgid ""
"Even if the lighting model is quite basic, we are now able to load and "
"display **complex 3D models with texture**!"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:521
msgid ""
"The next part will help us **organize a bit our code base**, as it is "
"getting too long to be left as a monolithic main. Once this is done, "
"we'll proceed to the last part of building a basic real-time 3D renderer,"
" namely **lighting**."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:1
msgid "Sampler"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:5
#: ../../basic-3d-rendering/texturing/sampler.md:586
msgid ""
"*Resulting code:* [`step070`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step070)"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:9
#: ../../basic-3d-rendering/texturing/sampler.md:590
msgid ""
"*Resulting code:* [`step070-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step070-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:12
msgid ""
"The `textureLoad` function, that we used in our shader accesses the "
"texture data, acts almost as if a texture was a basic buffer. It **does "
"not benefit** from the interpolation and mip level selection features "
"that the GPU is capable of."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:14
msgid ""
"To **sample** values from a texture with all these capabilities, we "
"define another resource called a **sampler**. We see below why this "
"proper way of fetching texture data is important to **avoid aliasing "
"artifacts**."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:16
msgid "Sampler setup"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:19
msgid "Sampler creation"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:21
msgid ""
"I am going to detail the sampler settings in the second part of this "
"chapter, once everything is wired up. For now just copy it, so that we "
"can start experimenting right away."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:66
msgid "We also need to raise the following device limit:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:72
msgid "Sampler binding"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:74
msgid "Adding a new binding should feel rather straightforward by now:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:118
msgid "Sampler usage"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:120
msgid ""
"In the **shaders**, the sampler simply uses the `sampler` type. Once "
"bound, we can use `textureSample(t, s, uv)` to sample the texture `t` at "
"UV `uv` using the sampler `s`:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:137
msgid "The cube, textured using a filtering sampler."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:141
msgid ""
"We can already see the effect of using a sampler: since our texture has a"
" low resolution, the sampler **interpolates** neighbor texels when asked "
"to sample at a **non-integer texel coordinate**, hence this **less "
"pixelated** result."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:144
msgid "Addressing"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:147
msgid ""
"The first part of the sampler settings is rather easy to understand. The "
"address modes (`addressModeU`, ...) tell for each axis of the coordinate "
"space (U, V, and W for 3D textures) how to handle values that are **out "
"of the range** $(0,1)$."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:149
msgid ""
"To illustrate this, we go back to our plane example and edit the **vertex"
" shader** to scale and offset the UVs."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:158
msgid ""
"With the ClampToEdge mode, UVs out of the $(0,1)$ range are clamped to "
"$0$ or $1$."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:161
msgid ""
"Note that if we switch back to raw texture loading, out of bounds texels "
"return a null color:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:172
msgid "Raw texture loading returns a null color when out of bounds."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:175
msgid ""
"Back to a sampled texture, let us now try a different value for the U "
"address mode:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:192
msgid "The Repeat mode set on U repeats the texture infinitly."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:195
msgid ""
"The last address mode, which we can try on the V axis, repeats with a "
"mirroring effect:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:212
msgid "The Repeat mode set on V repeats the texture with mirroring."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:215
msgid "Filtering"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:218
msgid ""
"The next sampler settings are about **filtering**, which is the **most "
"powerful** part of the sampler. There are **two types of filtering**."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:220
msgid "Magnifying filtering"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:222
msgid ""
"Magnifying filtering consists in interpolating (i.e., mixing) the value "
"of two neighboring pixels when a fragment samples a location that falls "
"**between two round texel coordinates**."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:224
msgid "We can compare the two possible filters:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:256
msgid ""
"The `Nearest` mode corresponds to **rounding** to the closest integer "
"texel coordinate, which corresponds roughly to what we had with raw texel"
" loading (not exactly because we were truncating coordinates rather than "
"rounding)."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:258
msgid ""
"The `Linear` mode, **commonly used**, corresponds to mixing coordinates "
"from `floor(u * width)` and `floor((u + 1) * width)` with factor `fract(u"
" * width)`."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:260
msgid "Minifying filtering"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:262
msgid "Aliasing"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:264
msgid ""
"This other filter is deactivated in our current setup (because we have "
"only 1 mip level), and we can highlight the issue that minifying "
"filtering addresses by moving the camera over the plane:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:308
msgid ""
"This is **terrible**, and appears any time a large texture is applied on "
"an **object that appears small** (e.g., because it is far from the "
"viewer)."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:310
msgid ""
"The key problem is that **when a screen pixel covers a lot of texels**, a"
" naive sampling procedure takes the color of one of the texels only, "
"whereas the pixel should be colored with the **average** color of all the"
" texels it covers."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:327
msgid "Mip-mapping"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:329
msgid ""
"It takes **too much time** to measure the average of all texels in the "
"pixel footprint (imagine when the object is textured with a 4K map but "
"appears on a 100 pixel area)."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:331
msgid ""
"What can we do? We **precompute** many possible averages, store them into"
" extra images called **mip maps**. The minifying filtering is thus more "
"commonly called **mip-mapping**. This takes more memory, but not that "
"much (twice the initial texture memory) compared to how it speeds things "
"up."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:333
msgid ""
"We can already change the description of our texture, and of the texture "
"view provided to the sampler, to allocate room for **storing the extra "
"mip levels**:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:371
msgid ""
"After allocating these mip levels, we can see that the sampler uses our "
"texture data only for the closest part of the plane. Beyond this, it "
"samples black color because we left the **extra mip levels "
"uninitialized**:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:376
msgid ""
"Closest points are sampled from the mip level 0, which contains our "
"texture. Other mip levels are filled with black pixels."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:380
msgid ""
"The size of each mip level is half the size of the previous one, until "
"one of the dimensions reaches 1 and is no longer divisible. The following"
" code snippet defines the **maximum number of mip levels** (as specified "
"[here](https://www.w3.org/TR/webgpu/#abstract-opdef-maximum-miplevel-"
"count)):"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:393
msgid "Mip-level data"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:395
msgid ""
"Now we need to **compute the data** of these other mip levels. Then for "
"each level, we issue a `queue.writeTexture` call to load the data for "
"that level."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:398
msgid ""
"In a later part of this tutorial, we will use **compute shaders** to fill"
" in the mip levels given the level 0 directly on the GPU, as this is more"
" efficient."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:401
msgid ""
"Let us enclose the texture data uploading (our call to "
"`queue.writeTexture`) in a loop over each mip level:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:471
msgid ""
"If the level is 0, `pixels` is filled as previously. For extra levels, "
"let us start with some plain color for debugging:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:495
msgid ""
"You should now see a **gradient** depending on the distance of the points"
" to the camera. Each color of the gradient corresponds to texels sampled "
"from a different mip level."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:497
msgid ""
"Again, **the sampler automatically figures out** which level to sample. "
"It does so based on the difference of UV coordinate between two neighbor "
"pixels."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:513
msgid ""
"Note that the sampler actually blends from multiple mip levels for an "
"even more continuous visual response. This can be deactivated by changing"
" the `mipmapFilter`:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:530
msgid "The debugging mip levels with Nearest mip-map filter mode."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:533
msgid ""
"We can now fill in the mip levels with the **actual filtered data**: each"
" texel of level $i$ is the average of 4 texels from level $i - 1$."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:560
msgid ""
"For the sake of simplicity, I assumed here that we were using a texture "
"whose dimensions is **a power of 2** so that it is always possible to "
"divide the size by 2. When it is not the case, one must take care of "
"borders."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:563
msgid ""
"Our sampler is thus able to provide texture samples that produce **way "
"less aliasing artifacts**! (Don't forget to switch back the "
"`mipmapFilter` to `Linear`):"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:574
msgid ""
"We can still see a little bit of aliasing at grazing angles. This is due "
"to the fact that the MIP pyramid precomputes **isotropic** averages, "
"which footprint is a regular square, but at grazing angle a pixel's "
"footprint is an elongated trapezoid."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:576
msgid ""
"This **anisotropy** is partially taken into account by the sampler "
"(through the `maxAnisotropy` option), but not perfectly. Nevertheless, "
"this is much more acceptable that the initial aliasing that we had!"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:581
msgid "We can now **properly use textures** in our scenes!"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:583
msgid ""
"We have seen how to **fill-in mip maps**, which can be computed in any "
"way you want. Even though they very often contain averages, **filtering "
"is a complex topic**, and other operations can be used. For mip-mapping "
"depth buffers, one would use a max (and the `compare` option that I did "
"not detail). For normal and roughness data (which we'll discover in the "
"[Lighting and Material](../lighting-and-material/index.md) chapter), "
"other techniques must be found because an average is not physically "
"correct."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:1
msgid "Texture mapping"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:5
#: ../../basic-3d-rendering/texturing/texture-mapping.md:209
msgid ""
"*Resulting code:* [`step065`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step065)"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:9
#: ../../basic-3d-rendering/texturing/texture-mapping.md:213
msgid ""
"*Resulting code:* [`step065-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step065-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:12
msgid ""
"In the previous chapter we used the **screen pixel coordinate** "
"(`in.position`) to decide which texel from the image to load."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:14
msgid ""
"If our geometry is no longer a full screen quad, this is **not really "
"what we want**. Let us switch back to a perspective projection, and use "
"the handy `glm::lookAt` function to get an interesting point of view:"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:25
msgid "The texture does not \"follow\" the geometry."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:28
msgid "Texel coordinates"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:31
msgid ""
"How to address this? By computing **texel coordinates** in the vertex "
"shader and letting the rasterizer interpolate it for each fragment."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:55
msgid ""
"It is important that the conversion to integers (`vec2i`) is done in the "
"fragment shader rather than in the vertex shader, because integer vertex "
"output do not get interpolated by the rasterizer."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:59
msgid ""
"Since we increase the size of attributes that transit from the vertex to "
"the fragment shader, we need to **update a device limit**:"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:70
msgid "A much better texture mapping, consistent when the viewpoint changes."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:73
msgid "UV coordinates"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:76
msgid ""
"The texture coordinates are in practice expressed in the range $(0,1)$, "
"so that they **do not depend on the resolution** of the texture, instead "
"of explicitly giving texel indices. We call these normalized coordinates "
"the **UV coordinates**."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:78
msgid ""
"We can make our code independent on the texture size using the "
"`textureDimensions` function:"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:105
msgid ""
"UV coordinates are a very common thing, and **there are UVs in the OBJ "
"file** I have been sharing with you, including this plane. We can add a "
"**new attribute** like we did with normals to provide the UVs from the "
"OBJ file up to the shader:"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:137
msgid ""
"Note that when loading UV coordinates from the file, we need to do **a "
"little conversion** on the V axis."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:166
msgid "And in the shader:"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:193
msgid ""
"For the plane this should not change anything, but if you try with "
"[cube.obj](../../data/cube.obj) for instance it also works nicely!"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:198
msgid "A textured cube, seen from location $(-2, -3, 2)$."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:204
msgid ""
"We are now able to load textures coordinates to map textures onto 3D "
"meshes, but as you might have noticed, there is **a lot of aliasing** in "
"the way we are getting texel data in the fragment shader."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:206
msgid "The next chapter hence presents **the proper way of sampling** textures!"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:1
msgid "Compute Pipeline"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:4
#: ../../basic-compute/compute-pipeline.md:523
msgid ""
"*Resulting code:* [`step201`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step201)"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:6
msgid ""
"Rendering 3D data is the original use of GPUs, but it is far from being "
"the only one nowadays. And even for 3D application, we sometimes use the "
"GPU for non-rendering things, such as simulation, image processing, etc."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:8
msgid ""
"When using the GPU for **general purpose** computation (GPGPU), we "
"usually **do not need to call the 3D-specific fixed parts** of the render"
" pipeline, like the rasterization."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:10
msgid ""
"This chapter introduces the skeleton for running **compute shaders**, "
"which are shaders run outside of the fixed-function pipeline."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:13
msgid ""
"We do not expect you to have read the whole 3D rendering part of the "
"guide, but at least up to the end of the [Shader Uniforms](../basic-3d-"
"rendering/shader-uniforms/index.md) part."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:16
msgid "Set-up"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:21
msgid ""
"Let us start with a very **simple problem**: we have a GPU-side buffer "
"and want to evaluate a simple function `f` for each element of this "
"buffer:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:30
msgid ""
"A **naive solution** would be to copy this buffer back to the CPU, "
"evaluate the function here, and upload the result to the GPU again. But "
"this is **very inefficient** for two reasons:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:32
msgid "The CPU-GPU **copies** are expansive, especially for large buffers."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:33
msgid ""
"Since `f` is applied independently to each values, the problem is very "
"**parallel**, and the GPU is much better than the CPU at this type of "
"*Single Instruction Multiple Data* (SIMD) parallelism."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:35
msgid ""
"So we set up a compute shader that evaluates `f` directly on the GPU, and"
" save the result in a second buffer."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:37
msgid "Architecture"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:39
msgid ""
"For the sake of the examples throughout this chapter, we create a "
"`onCompute` function that we call once after `onInit`. You may also "
"remove the main loop is `main.cpp` because we won't need the interactive "
"part."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:41
msgid "We reuse the same outline as when submitting our render pass on `onFrame`:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:65
msgid ""
"In the initialization method, we mostly keep the initialization of the "
"device and create (private) methods to organize the different steps:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:78
msgid ""
"Each `initSomething` step comes with a `terminateSomething` that is "
"called at the end in reverse order:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:90
msgid "Compute Pass"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:93
msgid ""
"Remember how we drew [our first color](../getting-started/first-"
"color.md)? We submitted to the command queue a particular render-specific"
" sequence of instructions called a `RenderPass`. The approach to run "
"compute-only shaders is similar, and uses a `ComputePass` instead."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:95
msgid ""
"The creation of the compute pass is **much simpler** than the one of the "
"render pass, because since we do **not use any fixed-function stage**, "
"there is almost nothing to configure! The only option if the timestamp "
"writes that will be described in the benchmarking chapter."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:115
msgid "Compute pipeline"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:118
msgid ""
"Once created, the use of the compute pass looks a lot like the use of the"
" render pass. The main difference is that `draw` is replaced by "
"`dispatchWorkgroups`, which calls our compute shader, and there is no "
"such thing as a vertex buffer."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:127
msgid "The compute pipeline first defines the shader to be used:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:142
msgid ""
"The file `compute-shader.wsl` defines a function named like the entry "
"point `computeStuff` and signal that it is a `@compute`. It must also "
"indicate a **workgroup size**, more on this soon!"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:152
msgid ""
"We can totally use the same shader module and file as for the other "
"shaders, I just avoid mixing unrelated parts of code."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:155
msgid ""
"At this point, it is possible to invoke our shader as long as we have no "
"bind group:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:164
msgid ""
"Yey! Except... it does virtually nothing, because without accessing any "
"resource, the compute shader cannot communicate any output."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:169
msgid ""
"For our shader to actually communicate with an input and output buffer, "
"we need to setup a **pipeline layout** that tells how the shader "
"resources should be bound, and a **bind group** that actually connects "
"the resources for a given shader invocation."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:173
msgid ""
"We add in the compute shader the two buffer bindings as variables defined"
" in the `storage`address space. It is important to specify the **access "
"mode**, which is `read` for the input and `read_write` for the output "
"(there is no \"write only\" mode):"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:181
msgid ""
"The [`array`](https://gpuweb.github.io/gpuweb/wgsl/#array-types) type of "
"WGSL is very similar to the "
"[`std::array`](https://en.cppreference.com/w/cpp/container/array) type of"
" C++."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:184
msgid ""
"And we create on the C++ side a **bind group layout** that matches these "
"bindings:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:208
msgid ""
"In `initComputePipeline()` we simply assign this to the compute pipeline "
"through the **pipeline layout**:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:220
msgid ""
"The objects `m_bindGroupLayout` and `m_pipelineLayout` are attributes of "
"the `Application` class (hence the `m_` prefix) so that they can be used "
"in different methods. Do not forget to destroy them in the terminate "
"functions by the way."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:223
msgid "Buffers"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:225
msgid ""
"Before binding the buffers, we must of course create them (in "
"`initBuffers`). An important point is to mark their usage with the "
"`Storage` flag, so that we can read/write them from shaders:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:244
msgid ""
"Buffers that have the `Storage` usage are confronted to specific device "
"limits:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:255
msgid "We can already fill in the input buffer with some values:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:266
msgid "Bind Group"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:268
msgid ""
"Remember: the bind group **layout** was telling *how* to bind resources "
"to the shader. Once we effectively have created these resources (the "
"buffers), we can define a **bind group** to tell *what* to bind:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:295
msgid ""
"Once the bind group is created, it can be bound to the pipeline in "
"`onCompute()`:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:304
msgid "Invocation"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:307
msgid "Concurrent calls"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:309
msgid ""
"Now that the the `dispatchWorkgroups` call actually does something, let "
"us explain a little more what it does."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:311
msgid ""
"A compute shader (and more generally a GPU) is **good at doing the same "
"thing multiple times in parallel**, so built in this *dispatch* operation"
" is the possibility to call the shader's entry point multiple times."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:313
msgid ""
"Instead of providing a single number of concurrent calls, we express this"
" number as a **grid** (a.k.a. **dispatch**) of $x \\times y \\times z$ "
"**workgroups**:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:319
msgid ""
"Beware that this launches $x \\times y \\times z$ **workgroups**, i.e., "
"groups of calls. Each workgroup is itself a little block of $w \\times h "
"\\times d$ **threads**, each of which runs the entry point. The workgroup"
" size is set by the shader's entry point:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:330
msgid "The workgroup sizes must be constant expressions."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:333
msgid "Workgroup size vs count"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:335
msgid ""
"ðŸ˜Ÿ Okey, that makes a lot of variables just to set a number of jobs that "
"is just the product of them in the end, doesn't it?"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:337
msgid ""
"The thing is: **all combinations are not equivalent**, even if they "
"multiply to the same number of threads."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:339
msgid ""
"The jobs are **not really all launched at once**: under the hood a "
"scheduler organizes the execution of individual workgroups. What we can "
"now is that the jobs from the **same workgroup** are launched together, "
"but two **different workgroup** might get executed at significantly "
"different times."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:341
msgid ""
"The appropriate size for a workgroup **depends a lot on the task** that "
"threads run. Here are some rules of thumb about the **workgroup size "
"versus workgroup count**:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:343
msgid ""
"The number $w \\times h \\times d$ of threads per workgroup should be a "
"multiple of 32, because within a workgroup threads are launched by "
"**warps** of (usually a multiple of) 32 threads."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:345
msgid ""
"The total resource usage of a workgroup should be kept to a **minimum**, "
"so that the scheduler has more freedom in organizing things."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:347
msgid ""
"When threads **share memory** with each others, it is cheaper if they are"
" in the same workgroup (and even cheaper if they are in the same warp)."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:349
msgid ""
"Group threads that are likely to have the **same branching path**. "
"Threads from the same warp share the same instruction pointer, so threads"
" are idling when one of their neighbors follows a different branch of an "
"`if` or loop condition."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:351
msgid "Try to have workgroup sizes be powers of two."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:354
msgid ""
"These rules are somehow contradictory. Only a benchmark on your specific "
"use case can tell you what the best trade-off is."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:357
msgid "Workgroup dimensions"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:359
msgid ""
"ðŸ˜Ÿ Ok I see better now, but what about the different axes $w$, $h$ and "
"$d$? Is a workgroup size of $2 \\times 2 \\times 4$ different from $16 "
"\\times 1 \\times 1$?"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:361
msgid ""
"It is different indeed, because this size **give hints to the hardware** "
"about the potential **consistency of memory access** across threads."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:363
msgid ""
"Both the CPU and the GPU try in general to guess patterns in the way "
"consecutive and/or concurrent operations use memory, in order for "
"instance to [prefetch](https://en.wikipedia.org/wiki/Cache_prefetching) "
"memory in caches or to group (a.k.a. \"coalesce\") concurrent read/writes"
" into a single memory access."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:365
msgid ""
"Since a very common task of the GPU is to process **data organized as a "
"2D or 3D grid**, a graphics API provides grid-based data storage "
"(**textures**) and grid-based concurrency model. When neighbor threads "
"access neighbor pixels/voxels in a similar way, the hardware can better "
"anticipate what is happening."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:367
msgid ""
"So the main rule of thumb here is that although the $x$, $y$ and $z$ axes"
" are at first glance abstract values that are \"just\" multiplied "
"together, you should really use them as the $x$, $y$ and $z$ axes of your"
" data grid."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:371
msgid ""
"In our simple example, we process data laid out in 1D buffers, so our "
"dispatch is also a one dimensional series of workgroups: $(x, y, z) = (x,"
" 1, 1)$ and $(w, h, d) = (w, 1, 1)$."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:373
msgid ""
"The workgroup size $w$ should be at least 32, and there is no apparent "
"reason for it to be more than that. So in the end, we dispatch workgroups"
" of `32 * 1 * 1` threads:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:382
msgid "And we infer the number of workgroups from the expected invocation calls:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:393
msgid ""
"Be careful about ceiling the `invocationCount / workgroupSize` division "
"instead of flooring it, otherwise when `workgroupSize` does not exactly "
"divide `invocationCount` the last threads will be missing."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:396
msgid ""
"All we need now is to now in which thread of which workgroup we are, to "
"figure out which index of the buffer we need to process. This is given by"
" [built-in shader inputs](https://gpuweb.github.io/gpuweb/wgsl/#built-in-"
"values-global_invocation_id), and in particular the **invocation id** "
"provided as the `global_invocation_id` built-in:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:408
msgid ""
"There are a bunch of device limits associated to the choice of workgroup "
"size/count:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:424
msgid "Read-back"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:427
msgid ""
"After dispatching all parallel compute threads, the output buffer is "
"populated with the result. So naturally now we want to **read this output"
" buffer** back."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:430
msgid ""
"One of the point of computing things on the GPU is to avoid CPU-GPU "
"copies, because maybe the output buffer is only used in a subsequent "
"operation on the GPU. But in our example case we still want to check that"
" the computation went well."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:433
msgid "Map Buffer"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:435
msgid ""
"We have seen already how to use the Buffer's `mapAsync` method to read a "
"buffer back, but this won't work directly:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:442
msgid ""
"Why not? This requires the output buffer to be created with the `MapRead`"
" usage flag. But unfortunately **this flag is incompatible** with "
"`Storage`, that is needed for the shader to be allowed to write in the "
"output."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:444
msgid ""
"The solution is to **create a 3rd buffer**, responsible for the transport"
" back on CPU. In the `initBuffers()` method we create this new \"map "
"buffer\" and add the `CopySrc` usage to the output:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:457
msgid ""
"After the `computePass.end()`, and before `encoder.finish(...)`, we add a"
" copy command:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:465
msgid "Callback"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:467
msgid ""
"We are now ready to read from the map buffer on the CPU, through a "
"callback provided to `mapAsync`:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:484
msgid ""
"Do not forget to call `Instance::processEvents` in the loop that waits "
"that the map is done afterwards:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:494
msgid ""
"As of April 23, 2023, `wgpu-native` does not implement `processEvent` "
"yet, but its behavior can be mimicked by submitting an empty queue:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:505
msgid "And you should finally see something like this in the output console:"
msgstr ""

#: ../../basic-compute/compute-pipeline.md:519
msgid ""
"Some parts of this chapters were reminders of what has been done with the"
" render pass, the **most important news** here is the "
"dispatch/workgroup/thread hierarchy. Make sure to come back to the list "
"of rules regularly to check that the choice of workgroup size is relevant"
" (and benchmark whenever possible)."
msgstr ""

#: ../../basic-compute/compute-pipeline.md:521
msgid ""
"We are now ready to focus on the content of the compute shader itself, "
"and the different ways it can manipulate resources and memory!"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:1
msgid "Convolution Filters"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:4
#: ../../basic-compute/image-processing/convolution-filters.md:305
msgid ""
"*Resulting code:* [`step215`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step215)"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:6
msgid ""
"Many **image processing algorithms** are based on convolution filter "
"operations somewhere in their pipeline."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:8
msgid ""
"The concept is simple: the new value of each pixel is computed by looking"
" at a **sliding window** centered around the pixel, multiplying it by a "
"fixed **kernel** and summing up."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:24
msgid ""
"The **kernel** defines the way each neighbor of the pixel of interest "
"influences its output value. In particular, a kernel that is $1$ in its "
"center and $0$ everywhere else defines a filter that does nothing."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:26
msgid ""
"By changing the kernel, we can create a wide variety of filters. Some of "
"them are **well known**, like the **Sobel** filter in the figure above or"
" the **Gaussian blur** filter. Some others are **algorithmically "
"discovered**, like the layers of [Convolutional Neural "
"Networks](https://en.wikipedia.org/wiki/Convolutional_neural_network)."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:28
msgid "Sobel filter"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:31
msgid ""
"We can start with the Sobel filter from the figure above. A Sobel filter "
"is meant to **detect edges**, either vertical ones or horizontal ones "
"depending on how we orient the kernel. For vertical edges, the kernel is:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:33
msgid ""
"\n"
"K =\n"
"\\left[\\begin{array}{ccc}\n"
"-1 & 0 & +1 \\\\\n"
"-2 & 0 & +2 \\\\\n"
"-1 & 0 & +1 \\\\\n"
"\\end{array}\\right]\n"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:42
msgid "Let us write the shader first, and then connect the dots:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:62
msgid ""
"Simple, right? All we need is the input and output textures. **I leave it"
" as an exercise**, as it is very similar to the setup of the first part "
"of the [Mipmap Generation](mipmap-generation.md) chapter, except that the"
" output is a view of a different texture instead of being a different MIP"
" level of the same one."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:65
msgid "Don't forget to change the entry point of the compute pipeline:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:72
msgid ""
"On [this input image](../../images/pexels-petr-ganaj-4121222.jpg), you "
"should get the following result:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:77
msgid "The result of our vertical Sobel filter"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:81
msgid ""
"It is interesting to apply this filter to the different MIP levels "
"independently, to detect edges at different scales."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:87
msgid "Optional section"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:88
msgid ""
"If you are only interested in the convolution filters themselves and that"
" making a non-interactive command line tool is fine, you may skip this "
"section."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:93
msgid ""
"In order to quickly experiment with our filters, we reuse the GUI "
"elements from the [Simple GUI](../../basic-3d-rendering/some-interaction"
"/simple-gui.md) chapter."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:95
msgid "In a nutshell, we must:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:97
msgid ""
"Add the `glfw`, `glfw3webgpu` and `imgui` library as dependencies (don't "
"forget to add a CMakeLists in the `imgui` directory)."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:98
msgid ""
"Add an `initWindow`, `initSwapChain` and `initGui` init steps (and "
"matching teminate steps)."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:99
msgid "Add a main application loop."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:101
msgid ""
"I also add a `m_shouldCompute` boolean to instruct the main loop to call "
"onCompute only when needed (i.e., when an input parameter changes):"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:114
msgid "Displaying textures"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:116
msgid ""
"To **avoid building our own render pipeline**, we can use ImGui to draw "
"texture views, by manually adding instructions to the `ImDrawList`:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:135
msgid ""
"The red rectangle and the image are drawn by ImGui, no need for us to "
"care about a render pipeline!"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:138
msgid "In the end our render pass in `onFrame` is simple:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:147
msgid ""
"What ImGui calls `ImTextureID` depends on the drawing backend. In the "
"case of our WebGPU-based backend, it must correspond to a valid "
"`TextureView` object. Using a `Texture` instead leads to crashes."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:152
msgid ""
"We can add uniforms in order to drive the behavior of the filter from the"
" UI."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:154
msgid ""
"Note that all ImGui functions return a boolean telling whether the value "
"they represent has been modified, we can use it to update our "
"`m_shouldCompute` and **run the compute shader only when needed**:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:165
msgid ""
"You can then add a uniform for the **kernel**. Be careful with [alignment"
" rules](https://gpuweb.github.io/gpuweb/wgsl/#structure-member-layout) "
"when using a `mat3x3`, because padding is needed between columns of the "
"matrix:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:189
msgid ""
"To assist you with this tedious alignment, I have started writing [a "
"little online tool](https://eliemichel.github.io/WebGPU-AutoLayout)!"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:192
msgid ""
"You can now dynamically play with the filter! Try for instance the Sobel "
"filter on a different axis:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:197
msgid ""
"The kernel is exposed as a uniform in the UI. Here we show an horizontal "
"Sobel filter (left: input, right: output)."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:200
msgid "Blur filters"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:203
msgid "Box blur"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:205
msgid "If we set all the weights of the kernel to $1/9$, we get a blur effect."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:207
msgid ""
"\n"
"K = \\frac{1}{9}\n"
"\\left[\\begin{array}{ccc}\n"
"1 & 1 & 1 \\\\\n"
"1 & 1 & 1 \\\\\n"
"1 & 1 & 1 \\\\\n"
"\\end{array}\\right]\n"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:219
msgid "A **box blur** is obtained by convolving with a **uniform kernel**."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:223
msgid ""
"When the kernel is all non-negative, it is common to need to "
"**normalize** its weights, i.e., to divide them by the total sum of "
"weights. You may want to add **a checkbox in the UI** to do so."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:226
msgid "Separability"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:228
msgid ""
"If we want a **stronger blur**, we can simply use a **larger kernel**. "
"However, this quickly reaches an unreasonable number of old texel fetch "
"per new texel."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:230
msgid ""
"Fortunately, the box filter is **separable**: it can be applied on **one "
"axis first**, and on the second axis then, using non-square kernel of "
"size $r \\times 1$ and $1 \\times r$. This requires $2r$ operations "
"instead of $r^2$, huge savings! For instance for $r = 5$:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:232
msgid ""
"\n"
"K_1 = \\frac{1}{5}\n"
"\\left[\\begin{array}{c}\n"
"1 \\\\\n"
"1 \\\\\n"
"1 \\\\\n"
"1 \\\\\n"
"1 \\\\\n"
"\\end{array}\\right]\n"
"\\quad\n"
"\\text{then}\n"
"\\quad\n"
"K_2 = \\frac{1}{5}\n"
"\\left[\\begin{array}{ccccc}\n"
"1 & 1 & 1 & 1 & 1 \\\\\n"
"\\end{array}\\right]\n"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:250
msgid ""
"The box blur is fine, but if you apply it with large kernels you will "
"quickly see **why it is called \"box\" blur**. It transforms spikes in "
"the signal into very noticeable squares."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:252
msgid "Gaussian blur"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:254
msgid ""
"The Gaussian blur is the most natural type of blur (a.k.a. low-pass "
"filter), it is found in a lot of different contexts and you have likely "
"seen at least once its 1D kernel:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:259
msgid ""
"Single-dimensional Gaussian kernels (a.k.a. normal distributions) of "
"standard deviation $\\sigma = 1.0$ (red), $\\sigma = 0.5$ (green) and "
"$\\sigma = 0.25$ (blue)."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:262
msgid ""
"In theory a Gaussian blur requires an **infinite kernel**. But the "
"influence of neighbors decreases exponentially, so we can quickly round "
"weight to 0 and thus **bound the size** of the kernel. Here is a simple "
"approximation of a 2D Gaussian kernel:"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:264
msgid ""
"\n"
"K = \\frac{1}{16}\n"
"\\left[\\begin{array}{ccc}\n"
"1 & 2 & 1 \\\\\n"
"2 & 4 & 2 \\\\\n"
"1 & 2 & 1 \\\\\n"
"\\end{array}\\right]\n"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:273
msgid ""
"And **good news**: the Gaussian blur is also separable! It is actually "
"the only blur that is **both separable and circularly symmetric** "
"([proof](https://www.sciencedirect.com/science/article/pii/089396599090151Z))."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:275
msgid ""
"To calculate the coefficients of a Gaussian blur (separated) kernel, you "
"can use [this blur coefficients "
"generator](https://lisyarus.github.io/blog/graphics/2023/02/24/blur-"
"coefficients-generator.html): the `WEIGHTS` array it creates can directly"
" be used in `writeBuffer` to communicate it to the compute shader."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:278
msgid ""
"In order to save some texture reads, this generator assumes that you are "
"using a linear **sampler** to get values from the input texture. In other"
" terms, use `textureSample` rather than `textureLoad`."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:281
msgid "Morphological filters"
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:284
msgid ""
"Morphological filters are also based on a **sliding window**, except that"
" after multiplying by the kernel, **instead of summing** the different "
"neighbors, we collect the **maximum** or **minimum** (or yet another non-"
"linear operations)."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:286
msgid ""
"A maximum tends to **dilate** the bright areas and inversely a minimum "
"**erodes** the white pixels."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:288
msgid ""
"The kernel is generally defined by a binary mask called the **structuring"
" element** of the morphological operation. When the structuring element "
"is a **rectangle**, the filter is **separable**."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:293
msgid "Morphological filters applied to an RGB image."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:297
msgid ""
"It is common to use morphological filters on black and white masks, for "
"instance to filter out imperfection on contour detection."
msgstr ""

#: ../../basic-compute/image-processing/convolution-filters.md:303
msgid ""
"Convolution filters are a good example of use of compute shaders (even "
"though they can easily be emulated by drawing a full screen triangle and "
"then using a fragment shader). They are also a building block for a lot "
"of image processing tools."
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:1
msgid "Cubemap Conversion (ðŸš§WIP)"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:4
#: ../../basic-compute/image-processing/cubemap-conversion.md:114
msgid ""
"*Resulting code:* [`step220`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step220)"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:6
#: ../../basic-compute/image-processing/cubemap-prefiltering.md:6
msgid "Problem"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:9
msgid ""
"Remember the cube maps from the [Image-Based Lighting](../../basic-3d-"
"rendering/lighting-and-material/ibl.md) chapter? We can actually build "
"them from the equirectangular environment maps found for instance on "
"[PolyHaven](https://polyhaven.com/hdris) or "
"[ambientCG](https://ambientcg.com/list?type=HDRI)."
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:11
msgid "**Input:**"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:19
msgid "**Parameterization:**"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:23
msgid ""
"The equirectangular map is parameterized with a latitude and longitude "
"graduation, like the Earth."
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:26
msgid "**Output:**"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:30
msgid ""
"A cubemap is made of 6 squared textures, or rather 1 texture with 6 "
"layers. Each layer corresponds to one face of a cube that wraps the "
"scene."
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:33
msgid ""
"Since it is easier to find equirectangular images, but a cubemap is "
"faster to query (because it is accelerated by the hardware), our goal is "
"to convert an equirectangular image to a cubemap."
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:76
msgid "In the bind group layout, we switch the texture dimension to `2DArray`:"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:83
msgid "In the shader, we must change the type or `outputTexture`:"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:90
msgid ""
"The call to `textureStore` then takes a new argument, the layer in which "
"we write:"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-conversion.md:97
msgid "We launch `4 * 4 * 6 = 96 = 3 * 32` threads:"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-prefiltering.md:1
msgid "Cubemap Prefiltering (ðŸš§WIP)"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-prefiltering.md:4
#: ../../basic-compute/image-processing/cubemap-prefiltering.md:201
msgid ""
"*Resulting code:* [`step222`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step222)"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-prefiltering.md:9
msgid ""
"In the [Physically-Based Materials](../../basic-3d-rendering/lighting-"
"and-material/pbr.md) chapter, we loaded a **prefiltered** cube map, where"
" **MIP levels** correspond to radiance pre-integrated for **different "
"roughness** rather than being a simple average."
msgstr ""

#: ../../basic-compute/image-processing/cubemap-prefiltering.md:11
msgid "We see in this section how to generate these MIP levels."
msgstr ""

#: ../../basic-compute/image-processing/cubemap-prefiltering.md:13
msgid "Multiple MIP levels"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-prefiltering.md:81
msgid "Multiple Dispatches"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-prefiltering.md:86
msgid ""
"Create one bind group per MIP level. Bind group #0 is the one we used to "
"have, and others are used to compute the prefiltered version of MIP level"
" 0 at different levels."
msgstr ""

#: ../../basic-compute/image-processing/cubemap-prefiltering.md:128
msgid "We need to define `m_prefilteringBindGroupLayout`:"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-prefiltering.md:153
msgid "In `onCompute`, after dispatching the first work group:"
msgstr ""

#: ../../basic-compute/image-processing/cubemap-prefiltering.md:172
msgid ""
"We also need to define this `m_prefilteringPipeline`. It uses the same "
"shader, but a different entry point."
msgstr ""

#: ../../basic-compute/image-processing/index.md:1
msgid "Image Processing"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:1
msgid "Mipmap Generation"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:4
#: ../../basic-compute/image-processing/mipmap-generation.md:498
msgid ""
"*Resulting code:* [`step211`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step211)"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:6
msgid ""
"A first application that I suggest for our newly learnt compute shaders "
"is the **generation of mipmaps**. In the chapter about [Texture Sampling"
"](../../basic-3d-rendering/texturing/sampler.md#filtering) we saw that "
"before applying a texture on a 3D mesh, we pre-compute different "
"downsampled versions of it."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:22
msgid ""
"At the time, **we were building the pyramid on the CPU**, prior to "
"uploading the texture data to the GPU texture object. But this problem is"
" actually **a very good fit for compute shaders**!"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:24
msgid "A very parallel problem"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:27
msgid ""
"The problem of MIP level generation boils down to the following: given a "
"MIP level $n - 1$, we compute a texel $(i,j)$ of the MIP level $n$ by "
"averaging the for texels from MIP level $n - 1$ with coordinates $(2 i + "
"u,2j + v)$, where $u$ and $v$ span in $\\{0,1\\}$."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:29
msgid ""
"A **good property** of this problem is that processing is **very local**:"
" a given texel of MIP level $n$ only depend on a small fixed number of "
"texels from the previous level $n - 1$, and only contributes to one texel"
" of next level $n + 1$."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:31
msgid ""
"There might seem to be two ways of treating this problem as a dispatch of"
" parallel jobs:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:33
msgid ""
"**Option A** One thread per pixel of level $n$, each texel $(i,j)$ of "
"this level fetches 4 texels from the MIP level $n - 1$ and averages them."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:35
msgid ""
"**Option B** One thread per pixel of level $n - 1$, each texel $(i',j')$ "
"of this level is divided by $4$ (total number of averaged texels) and "
"accumulated in the texel $(i'/2, j'/2)$ of the MIP level $n$."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:37
msgid ""
"Option A has 4 times less threads, but each thread does 4 texture reads "
"instead of 1 for Option B. Both options do 1 write per thread."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:40
msgid ""
"The limiting factor in the case of such a simple mathematical operation "
"is memory access, we do not really care about the computation of the "
"average itself."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:43
msgid ""
"**Spoiler alert:** Option A is the best one in this case, for multiple "
"reasons:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:45
msgid ""
"Option B requires an **extra pass to initialize** all texels of the the "
"output 0."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:46
msgid ""
"Option B leads to **race conditions** because accumulating values "
"requires to read the current average, then write the updated one, and if "
"multiple threads do the same the **parallel write operations will "
"conflict**."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:47
msgid ""
"Actually, it is **not even possible to read and write from the same "
"texture** in a single compute shader dispatch."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:49
msgid "For all these reasons, we will implement **Option A**."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:51
msgid "Input/Output"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:54
msgid ""
"We first need to load an input texture and save the output to check that "
"the process worked well. For our test, we use **a single texture with 2 "
"MIP levels**: MIP level 0 is the input image, MIP level 1 is the output "
"of the compute shader."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:58
msgid ""
"As an example, we are going to load the following "
"[`input.jpg`](../../images/mipmap-generation/input.jpg):"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:63
msgid "Our example input image."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:66
msgid ""
"Add new init steps and texture-related attributes to the `Application` "
"class:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:84
msgid ""
"The `initTexture()` method starts like [our texture loading procedure"
"](../../basic-3d-rendering/texturing/loading-from-file.md), only we do "
"not include the mipmap generation:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:125
msgid ""
"We use the "
"[`stb_image.h`](https://raw.githubusercontent.com/nothings/stb/master/stb_image.h)"
" file to load the image. DO not forget to include it and add in "
"`implementations.cpp` the following:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:133
msgid "Once we have the texture, we only populate the MIP level 0:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:155
msgid ""
"The `initTextureViews()` is pretty straightforward, the only difference "
"between the input and output view is the MIP level:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:179
msgid "Saving"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:181
msgid ""
"To save the output image, we use "
"[`stb_image_write.h`](https://raw.githubusercontent.com/nothings/stb/master/stb_image_write.h),"
" the companion of `stb_image.h` for writing files, and add to "
"`implementations.cpp` the following:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:189
msgid ""
"The high-level process for reading a texture back to the CPU is the "
"following:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:191
msgid ""
"Create a GPU buffer with the same byte size as the MIP level you want to "
"save."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:192
msgid "Copy the texture to this buffer using `encoder.copyTextureToBuffer(...)`."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:193
msgid "Map this buffer like we did with the `mapBuffer` in the previous chapter."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:194
msgid "In the map callback, use `stbi_write_png` to write the image to disk."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:196
msgid ""
"I leave the details as an exercise, you may simply include this "
"[`save_texture.h "
"`](https://gist.github.com/eliemichel/0a94203fd518c70f3c528f3b2c7f73c8) "
"file into your project, and at the end of `onCompute()`:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:203
msgid "Everything related to the buffers of the previous chapter can be removed."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:208
msgid ""
"In `initBindGroupLayout` and `initBindGroup`, we replace the buffer "
"bindings with bindings for our texture views."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:210
msgid ""
"The layout for **input binding** is similar to texture bindings used in "
"3D rendering, the only difference being the `visibility`:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:221
msgid "Define a corresponding binding in the **shader**:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:227
msgid ""
"The **output binding** is different, because a `texture` binding is "
"always ready-only. What we need here is a **storage texture** binding:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:239
msgid "This corresponds in the **shader** to the following variable declaration:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:245
msgid ""
"A texture storage has **more detailed format information** than a "
"texture: the `rgba8unorm` means that the underlying format of the texture"
" is 4 channels of 8 bits, and that we manipulate texels in the shader as "
"\"unsigned normalized\" values, i.e., floats in range $(0, 1)$."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:248
msgid ""
"Only the `write` access is allowed for `texture_storage_2d`. Other "
"accesses may be introduced in later versions of WebGPU."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:251
msgid "In `initBindGroup`, the entries are very simple:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:263
msgid ""
"Great, everything is in place here, we can now focus on the actual "
"compute shader."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:268
msgid "Dispatch"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:270
msgid ""
"I suggest we use a workgroup size of $8 \\times 8$: this treats both $X$ "
"and $Y$ axes symmetrically and sums up to 64 threads, which is a "
"reasonable multiple of a typical warp size."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:276
msgid ""
"We then need to compute the number of workgroup to dispatch. This depends"
" on the expected number of thread. In our so called Option A, we launch "
"**1 thread per texel** of the **output** MIP level:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:292
msgid ""
"The input image I provided above has a size that is a **power of 2**, "
"which always makes things easier as there is no wasted thread."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:297
msgid ""
"For each texel, we use `textureLoad` 4 times to average corresponding "
"texels from the previous MIP level, then `textureStore` to write in the "
"new MIP level:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:314
msgid ""
"The last argument of `textureLoad` is a MIP level **relative to the "
"texture view** that we bound. So in both cases here we look at the first "
"(and only) MIP level available in the view."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:317
msgid ""
"And this is it! Most of the work was about binding inputs/outputs, the "
"compute shader itself is very simple."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:319
msgid "Result"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:321
msgid ""
"We can inspect the result to check that it matches a "
"[reference](../../images/mipmap-generation/reference.png), downsampled "
"with a regular image editing tool like GIMP or Photoshop:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:337
msgid ""
"*Intermediary resulting code:* [`step210`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step210)"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:339
msgid "Application to all MIP levels"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:342
msgid "Loop over MIP levels"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:344
msgid ""
"We know how to compute the MIP level $1$, given the MIP level $0$. "
"Generalizing this to be called in a loop is rather straightforward. We "
"move our dispatch into a loop over all MIP levels:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:361
msgid ""
"The loop starts at level 1, because more generally it is responsible for "
"computing level `nextLevel` given level `nextLevel - 1`."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:364
msgid ""
"The `getMaxMipLevels()` utility function is the same one we were using "
"for texture loading when computing mipmaps on CPU:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:378
msgid "We also use this function when creating the texture by the way:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:385
msgid "One view per MIP level"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:387
msgid "Two things differ from one iteration of dispatch to another:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:389
msgid "The number of thread (i.e., the number of texels for the next MIP level)"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:390
msgid "The bind group"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:392
msgid ""
"In order to build a different bind group at each iteration, we create in "
"`initTextureViews` not just 2 views but one per MIP level. We also "
"compute at the same time the size of each such level."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:421
msgid ""
"The views bound as writable storage and as readable texture must not "
"share any MIP level!"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:424
msgid ""
"We also make sure to initialize the size `m_textureMipSizes[0]` for the "
"first level:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:437
msgid ""
"Finally we can add a MIP level parameter to the `initBindGroup()` method "
"and call it the compute loop. Don't forget to also call "
"`terminateBindGroup()` at the end of each iteration."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:453
msgid "The main dispatch loop thus becomes:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:475
msgid ""
"After the commands are submitted, we can save the texture's MIP levels in"
" individual files:"
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:488
msgid "The resulting MIP levels, computed directly on GPU."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:494
msgid ""
"In this chapter we have seen how to play with textures in compute shader,"
" and in particular how reading and writing require different bindings, "
"which **must not overlap**. We are going to keep on playing with this in "
"the next chapter."
msgstr ""

#: ../../basic-compute/image-processing/mipmap-generation.md:496
msgid ""
"Also, remember how we had two options A and B at the beginning? It is "
"common that **multiple parallelization schemes seem possible**, but that "
"in practice one of them is a much better idea! So **think twice** before "
"implementing the first idea that comes to your mind."
msgstr ""

#: ../../basic-compute/index.md:1
msgid "Basic Compute"
msgstr ""

#: ../../basic-compute/neural-networks.md:1
msgid "Neural Networks (ðŸ›‘TODO)"
msgstr ""

#: ../../basic-compute/neural-networks.md:5
msgid ""
"[WONNX](https://github.com/webonnx/wonnx) and [ONNX "
"Runtime](https://github.com/microsoft/onnxruntime) support the Web "
"through WebGPU."
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:1
msgid "Deformation (ðŸš§WIP)"
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:4
#: ../../basic-compute/procedural-geometry/deformation.md:48
msgid ""
"*Resulting code:* [`step240`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step240)"
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:6
msgid ""
"**Procedural geometry** plays is a very important role in 3D modeling "
"tools. They usually take the form of a **stack of post-effects** and/or "
"**a graph of nodes** where procedural operations are connected to each "
"others. For instance Blender calls these respectively *Modifiers* and "
"*Geometry Nodes*:"
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:11
msgid ""
"Modifiers and Geometry Nodes are two examples of procedural (a.k.a. non-"
"destructive) mesh effects in Blender."
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:17
msgid ""
"These effects are powerful, but can only be used during the creation of "
"3D models, **not at runtime** during a game or application. We thus need "
"to program ourselves the procedural effects that we intend to run live."
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:20
msgid ""
"The impossibility to exchange procedural effects (also known as \"non-"
"destructive effects\") is something that I have been trying to address "
"for some time with [OpenMfx](https://openmfx.org/). This \"standard\" is "
"not really adopted by anybody yet but I still believe we need such an "
"API, and would be happy to discuss about it if you are interested!"
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:23
msgid ""
"We could reproduce mesh effects on CPU, but since this guide is about GPU"
" programming, **let's try to write them in shaders**! Not all effects are"
" a good fit for GPU programming, but a lot of them are. Furthermore, some"
" operations are much easier to parallelize on a GPU than others."
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:25
msgid ""
"The **simplest case** of procedural geometry effect consists in "
"**deforming an existing mesh**, by just moving the existing vertices, not"
" affecting the connectivity."
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:27
msgid ""
"First of all, if you just need to **move vertices**, you might be able to"
" do it **in the vertex shader**! But there may be multiple reasons for "
"which you should rather use a compute shader:"
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:29
msgid ""
"If the deformation process is a **heavy task** that you don't want to run"
" at each frame."
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:30
msgid "If you want to **read the deformed mesh back** to the CPU."
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:31
msgid ""
"If you need to **access connectivity** information such as the neighbors'"
" vertices/faces of a vertex when processing a mesh."
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:32
msgid "If you want to **share information across vertices**."
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:34
msgid "Example case"
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:37
msgid ""
"Our first example is a \"squarification\" effect, that takes a quad mesh "
"as input and try to make its faces be as square as possible by "
"iteratively moving vertices."
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:41
msgid "Our input mesh is made solely of quads, but they are quite distorted."
msgstr ""

#: ../../basic-compute/procedural-geometry/deformation.md:44
msgid "Input file: [`quad-input.obj`](../../data/procgen/quad-input.obj)"
msgstr ""

#: ../../basic-compute/procedural-geometry/index.md:1
msgid "Procedural Geometry"
msgstr ""

#: ../../getting-started/cpp-idioms.md:1
msgid "C++ wrapper"
msgstr ""

#: ../../getting-started/cpp-idioms.md:4
#: ../../getting-started/cpp-idioms.md:176
msgid ""
"*Resulting code:* [`step025`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step025)"
msgstr ""

#: ../../getting-started/cpp-idioms.md:6
msgid ""
"So far we have used the raw WebGPU API, which is a C API, and this "
"prevented us from using some nice productive features of C++. This "
"chapter first gives imaginary examples of how this could be improved, "
"before linking to a little library that implement all this little "
"features."
msgstr ""

#: ../../getting-started/cpp-idioms.md:9
msgid ""
"All the changes presented here only affect the coding time, but our "
"shallow C++ wrapper leads to the very same runtime binaries."
msgstr ""

#: ../../getting-started/cpp-idioms.md:13
msgid ""
"This chapter is not as up to date as [the readme of "
"WebGPU-C++](https://github.com/eliemichel/WebGPU-Cpp). I recommend you "
"read that instead for now."
msgstr ""

#: ../../getting-started/cpp-idioms.md:16
msgid "Default descriptor values"
msgstr ""

#: ../../getting-started/cpp-idioms.md:19
msgid ""
"Sometimes we just need to build a descriptor by default. More generally, "
"we rarely need to have all the fields of the descriptor deviate from the "
"default, so we could benefit from the possibility to have a default "
"constructor for descriptors."
msgstr ""

#: ../../getting-started/cpp-idioms.md:21
msgid "Namespace"
msgstr ""

#: ../../getting-started/cpp-idioms.md:24
msgid ""
"The C interface could not make use of namespaces, since they only exist "
"in C++, so you may have noticed that every single function starts with "
"`wgpu` and every single structure starts with `WGPU`. A more C++ "
"idiomatic way of doing this is to enclose all these functions into a "
"namespace."
msgstr ""

#: ../../getting-started/cpp-idioms.md:32
msgid "becomes with namespaces:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:40
msgid ""
"And of course you can start your source file with `using namespace wgpu;`"
" to avoid spelling out `wgpu::` everywhere. Coupled with default "
"descriptor, this leads to simply:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:47
msgid "Objects"
msgstr ""

#: ../../getting-started/cpp-idioms.md:50
msgid ""
"Beyond namespace, most functions are also prefixed by the name of their "
"first argument, e.g.:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:61
msgid ""
"These functions are conceptually *methods* of the object constituted by "
"their first argument, so in the wrapper they are exposed as such:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:83
msgid ""
"The `const` qualifier is specified for some methods. This is extra "
"information provided by the wrapper to reduce the potential programming "
"mistakes."
msgstr ""

#: ../../getting-started/cpp-idioms.md:86
msgid "Capturing closures"
msgstr ""

#: ../../getting-started/cpp-idioms.md:89
msgid ""
"Many asynchronous operations use callbacks. In order to provide some "
"context to the callback's body, there is always a `void *userdata` "
"argument passed around. This can be alleviated in C++ by using capturing "
"closures."
msgstr ""

#: ../../getting-started/cpp-idioms.md:92
msgid ""
"This only alleviates the notations, but technically mechanism very "
"similar to the user data pointer is automatically implemented when "
"creating a capturing lambda."
msgstr ""

#: ../../getting-started/cpp-idioms.md:111
msgid "becomes"
msgstr ""

#: ../../getting-started/cpp-idioms.md:123
msgid "Scoped enumerations"
msgstr ""

#: ../../getting-started/cpp-idioms.md:126
msgid ""
"Because enums are *unscoped* by default, the WebGPU API is forced to "
"prefix all values that an enum can take with the name of the enum, "
"leading to quite long names:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:138
msgid ""
"It is possible in C++ to define *scoped* enums, which are strongly typed "
"and can only be accessed through the name, for instance this scoped enum:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:150
msgid "This can be used as follows:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:157
msgid ""
"The actual implementation use a little trickery so that enum names are "
"scoped, but implicitly converted to and from the original WebGPU enum "
"values."
msgstr ""

#: ../../getting-started/cpp-idioms.md:160
msgid "Library"
msgstr ""

#: ../../getting-started/cpp-idioms.md:163
msgid ""
"The library providing these C++ idioms is "
"[`webgpu.hpp`](../data/webgpu.hpp). It is made of a single header file, "
"which you just have to copy in your source tree. Exactly one of your "
"source files must define `WEBGPU_CPP_IMPLEMENTATION` before `#include "
"\"webgpu.hpp\"`:"
msgstr ""

#: ../../getting-started/cpp-idioms.md:171
msgid "This header is actually included in the WebGPU zip I provided you earlier."
msgstr ""

#: ../../getting-started/cpp-idioms.md:174
msgid ""
"More information can be found in [the webgpu-cpp "
"repository](https://github.com/eliemichel/WebGPU-Cpp)."
msgstr ""

#: ../../getting-started/first-color.md:1
msgid "First Color"
msgstr ""

#: ../../getting-started/first-color.md:13
#: ../../getting-started/first-color.md:286
msgid ""
"*Resulting code:* [`step020`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step020)"
msgstr ""

#: ../../getting-started/first-color.md:15
msgid ""
"The goal of this chapter is to **draw a solid color** all over our "
"window. This will be the occasion to introduce 3 new concepts of WebGPU:"
msgstr ""

#: ../../getting-started/first-color.md:17
msgid "Swap Chains"
msgstr ""

#: ../../getting-started/first-color.md:18
msgid "Texture Views"
msgstr ""

#: ../../getting-started/first-color.md:19
msgid "Render Passes"
msgstr ""

#: ../../getting-started/first-color.md:24
msgid "Drawing process"
msgstr ""

#: ../../getting-started/first-color.md:26
msgid ""
"To understand the notion of **Swap Chain**, we need to know a little more"
" about how the window's surface is drawn."
msgstr ""

#: ../../getting-started/first-color.md:28
msgid ""
"First, the render pipeline **does not draw directly on the texture that "
"is currently displayed**, otherwise we would see pixels change all the "
"time. A typical pipeline draws to an off-screen texture, which replaces "
"the currently displayed one only once it is complete. We then say that "
"the texture is **presented** to the surface."
msgstr ""

#: ../../getting-started/first-color.md:30
msgid ""
"Second, drawing takes a **different time** than the frame rate required "
"by your application, so the GPU may have to wait until the next frame is "
"needed. There might be more than one off-screen texture waiting in the "
"queue to be presented, so that fluctuations in the render time get "
"amortized."
msgstr ""

#: ../../getting-started/first-color.md:32
msgid ""
"Last, **these off-screen textures are reused** as much as possible. As "
"soon as a new texture is presented, the previous one can be reused as a "
"target for the next frame. This whole texture swapping mechanism is "
"implemented by the **Swap Chain** object."
msgstr ""

#: ../../getting-started/first-color.md:35
msgid ""
"Remember that the GPU process runs at its own pace and that our CPU-"
"issued commands are only asynchronously executed. Implementing the swap "
"chain process manually would hence require a lot of boilerplate, so we "
"are glad it is provided by the API!"
msgstr ""

#: ../../getting-started/first-color.md:42
msgid ""
"*Left: The render process draws on an off-screen texture. Middle: "
"Rendered textures wait in a queue. Right: At a regular frame rate, "
"rendered textures are presented to the window's surface.*"
msgstr ""

#: ../../getting-started/first-color.md:46
msgid ""
"As always, we pass swap chain creation option through a descriptor. A "
"first obvious option is the size of all the textures that are "
"manipulated:"
msgstr ""

#: ../../getting-started/first-color.md:56
msgid ""
"As you can guess, we will have to take care of creating a new swap chain "
"**when the window is resized**. In the meantime, do not try to resize it."
" You may add `glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);` before "
"creating the window to instruct GLFW to disable resizing."
msgstr ""

#: ../../getting-started/first-color.md:59
msgid ""
"For the swap chain to **allocate textures**, we also need to specify "
"their **format**. The format is a combination of a number of channels (a "
"subset of red, green, blue, alpha), a size per channel (8, 16 or 32 bits)"
" and a channel type (float, integer, signed or not), a compression "
"scheme, a normalization mode, etc."
msgstr ""

#: ../../getting-started/first-color.md:61
msgid ""
"All available combinations are listed in the `WGPUTextureFormat` enum, "
"but since our swap chain targets an existing surface, we can just use "
"whichever format the surface uses:"
msgstr ""

#: ../../getting-started/first-color.md:73
msgid ""
"When using the Dawn implementation of WebGPU, "
"`wgpuSurfaceGetPreferredFormat` is not implemented yet. Actually, the "
"only texture format it supports is `WGPUTextureFormat_BGRA8Unorm`."
msgstr ""

#: ../../getting-started/first-color.md:86
msgid ""
"Textures are allocated for a **specific usage**, that dictates the way "
"the GPU organizes its memory. In our case, we use the swap chain textures"
" as targets for a *Render Pass* so it needs to be created with the "
"`RenderAttachment` usage flag:"
msgstr ""

#: ../../getting-started/first-color.md:92
msgid ""
"Finally, we can tell which texture from the waiting queue must be "
"presented at each frame. Possible values are:"
msgstr ""

#: ../../getting-started/first-color.md:94
msgid ""
"`Immediate`: No off-screen texture is used, the render process directly "
"draws on the surface, which might lead to artifacts (called *tearing*) "
"but has zero latency."
msgstr ""

#: ../../getting-started/first-color.md:95
msgid ""
"`Mailbox`: There is only one slot in the queue, and when a new frame is "
"rendered, it replaces the one currently waiting (which is discarded "
"without ever being presented)."
msgstr ""

#: ../../getting-started/first-color.md:96
msgid ""
"`Fifo`: Stands for \"first in, first out\", meaning that the presented "
"texture is always the oldest one, like a regular queue. No rendered "
"texture is wasted."
msgstr ""

#: ../../getting-started/first-color.md:99
msgid ""
"The `Force32` enum values that you can find when reading the source code "
"of `webgpu.h` is not a \"legal\" value, it is just here to force the "
"underlying enum type to be a 32 bit integer."
msgstr ""

#: ../../getting-started/first-color.md:102
msgid "In our case, we use `Fifo`, as illustrated in the video above."
msgstr ""

#: ../../getting-started/first-color.md:108
msgid "We may now create the swap chain:"
msgstr ""

#: ../../getting-started/first-color.md:120
msgid "And of course at the end of the program we destroy it:"
msgstr ""

#: ../../getting-started/first-color.md:127
msgid ""
"The Swap Chain is something that is not exposed in the JavaScript version"
" of the API. Like the notion of *surface* that we have met already, by "
"the way. The web browser takes care of it and does not offer any option."
msgstr ""

#: ../../getting-started/first-color.md:130
msgid "Troubleshooting"
msgstr ""

#: ../../getting-started/first-color.md:131
msgid ""
"If you get the error `Uncaptured device error: type 3 "
"(Device(OutOfMemory))` when calling `wgpuDeviceCreateSwapChain`, check "
"that you specified the `GLFW_NO_API` value to glfw when creating the "
"window."
msgstr ""

#: ../../getting-started/first-color.md:134
msgid "Texture View"
msgstr ""

#: ../../getting-started/first-color.md:137
msgid ""
"Let's move on to the **main loop** and see how to use the swap chain. As "
"explained above, the swap chain provides us with the texture where to "
"draw the next frame. It is as simple as this:"
msgstr ""

#: ../../getting-started/first-color.md:154
msgid ""
"Note that this returns a **Texture View**. This gives a restricted access"
" to the actual texture object allocated by the swap chain, so that "
"internally the swap chain can use whatever organization it wants while "
"exposing a view that has the dimensions and format that we expect."
msgstr ""

#: ../../getting-started/first-color.md:156
msgid ""
"Getting the texture view **may fail**, in particular if the window has "
"been resized and thus the target surface changed, so don't forget to "
"check that it is not null:"
msgstr ""

#: ../../getting-started/first-color.md:165
msgid ""
"The texture view is **used only for a single frame**, after which it is "
"our responsibility to destroy it:"
msgstr ""

#: ../../getting-started/first-color.md:171
msgid ""
"At the end of the main loop, once the texture is filled in and the view "
"released, we can tell the swap chain to present the next texture (which "
"depends on the `presentMode` of the swap chain):"
msgstr ""

#: ../../getting-started/first-color.md:180
msgid "Render pass encoder"
msgstr ""

#: ../../getting-started/first-color.md:182
msgid ""
"We now hold the texture where to draw to display something in our window."
" Like any GPU-side operation, we trigger drawing operations from the "
"command queue, using a command encoder as described in [the previous "
"chapter](the-command-queue.md)."
msgstr ""

#: ../../getting-started/first-color.md:184
msgid ""
"Build a `WGPUCommandEncoder` called `encoder`, then submit it to the "
"queue. In between we will add a command that clears the screen with a "
"uniform color."
msgstr ""

#: ../../getting-started/first-color.md:192
msgid ""
"If you look in `webgpu.h` at the methods of the encoder (the procedures "
"starting with `wgpuCommandEncoder`), most of them are related to copying "
"buffers and textures around. Except **two special ones**: "
"`wgpuCommandEncoderBeginComputePass` and "
"`wgpuCommandEncoderBeginRenderPass`. These return specialized encoder "
"objects, namely `WGPUComputePassEncoder` and `WGPURenderPassEncoder`, "
"that give access to commands dedicated to respectively computing and 3D "
"rendering."
msgstr ""

#: ../../getting-started/first-color.md:194
msgid "In our case, we use a render pass:"
msgstr ""

#: ../../getting-started/first-color.md:203
msgid ""
"Note that we directly end the pass without issuing any other command. "
"This is because the render pass has a built-in mechanism for clearing the"
" screen when it begins, which we'll set up through the descriptor."
msgstr ""

#: ../../getting-started/first-color.md:205
msgid "Color attachment"
msgstr ""

#: ../../getting-started/first-color.md:207
msgid ""
"A render pass leverages the 3D rendering circuits of the GPU to draw "
"content into one or multiple textures. So one important thing to set up "
"is to tell **which textures are the target** of this process. These are "
"the **attachments** of the render pass."
msgstr ""

#: ../../getting-started/first-color.md:209
msgid ""
"The number of attachment is variable, so the descriptor gets it through "
"two fields: the number `colorAttachmentCount` of attachments and the "
"address `colorAttachments` of the color attachment array. Since we only "
"use one, the address of the array is just the address of a single "
"`WGPURenderPassColorAttachment` variable."
msgstr ""

#: ../../getting-started/first-color.md:219
msgid ""
"The first important setting of the attachment is the texture view it must"
" draw in. In our case, the view returned by the swap chain because we "
"directly want to draw on screen, but in advanced pipelines it is very "
"common to draw on intermediate textures, which are then fed to e.g., "
"post-process passes."
msgstr ""

#: ../../getting-started/first-color.md:225
msgid ""
"There is a second target texture view called `resolveTarget`, but it is "
"not relevant here because we do not use *multi-sampling* (more on this "
"later)."
msgstr ""

#: ../../getting-started/first-color.md:231
msgid ""
"The `loadOp` setting indicates the load operation to perform on view "
"prior to executing the render pass. It can be either read from the view "
"or set to a default uniform color, namely the clear value. When it does "
"not matter, use `WGPULoadOp_Clear` as it is likely more efficient."
msgstr ""

#: ../../getting-started/first-color.md:233
msgid ""
"The `storeOp` indicates the operation to perform on view after executing "
"the render pass. It can be either stored or discarded (which only makes "
"sense if the render pass has side-effects)."
msgstr ""

#: ../../getting-started/first-color.md:235
msgid ""
"And the `clearValue` is the value to clear the screen with, put anything "
"you want in here! The 4 values are the red, green, blue and alpha "
"channels, on a scale from 0.0 to 1.0."
msgstr ""

#: ../../getting-started/first-color.md:245
msgid ""
"There is also one special type of attachment, namely the *depth* and "
"*stencil* attachment (it is a single attachment potentially containing "
"two channels). We'll come back on this later on, for now we do not use it"
" so we set it to null:"
msgstr ""

#: ../../getting-started/first-color.md:251
msgid ""
"When measuring the performance of a render pass, it is not possible to "
"use CPU-side timing functions, since the commands are not executed "
"synchronously. Instead, the render pass can receive a set of timestamp "
"queries. We do not use it in this example."
msgstr ""

#: ../../getting-started/first-color.md:258
msgid ""
"Lastly, we set `nextInChain` to a null pointer (remember this pointer is "
"an extension mechanism that the standard WebGPU API does not use)."
msgstr ""

#: ../../getting-started/first-color.md:267
msgid ""
"At this stage you should be able to get a colored window. This seems "
"simple, but it made us meet a lot of important concepts."
msgstr ""

#: ../../getting-started/first-color.md:269
msgid ""
"Instead of directly drawing to the window's surface, we draw to an off-"
"screen texture and the **swap chain** is responsible for managing the "
"texture turn over."
msgstr ""

#: ../../getting-started/first-color.md:270
msgid ""
"The 3D rendering pipeline of the GPU is leveraged through the **render "
"pass**, which is a special scope of commands accessible through the "
"command encoder."
msgstr ""

#: ../../getting-started/first-color.md:271
msgid ""
"The render pass draws to one or multiple **attachments**, which are "
"texture views."
msgstr ""

#: ../../getting-started/first-color.md:277
msgid "Our first color!"
msgstr ""

#: ../../getting-started/first-color.md:281
msgid ""
"When using Dawn, the displayed color is potentially different because the"
" surface color format uses another color space. More on this [later"
"](../basic-3d-rendering/input-geometry/loading-from-file.md)!"
msgstr ""

#: ../../getting-started/first-color.md:284
msgid ""
"We are now ready with the basic WebGPU setup, and can dive more deeply in"
" the 3D rendering pipeline."
msgstr ""

#: ../../getting-started/hello-webgpu.md:1
msgid "Hello WebGPU"
msgstr ""

#: ../../getting-started/hello-webgpu.md:10
#: ../../getting-started/hello-webgpu.md:268
msgid ""
"*Resulting code:* [`step005`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step005)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:12
msgid ""
"For your C++ code, WebGPU is nothing more than a single header file "
"listing all the available procedures and data structures: "
"[`webgpu.h`](https://github.com/webgpu-native/webgpu-"
"headers/blob/main/webgpu.h). When building the program though, your "
"compiler must know in the end (at the final *linking* step) where to find"
" the actual implementation of these functions."
msgstr ""

#: ../../getting-started/hello-webgpu.md:16
msgid ""
"A *Render Hardware Interface* (RHI) like WebGPU is not directly provided "
"by the drivers: we need to link to a library that implements the API on "
"top of the low-level one that the system supports."
msgstr ""

#: ../../getting-started/hello-webgpu.md:19
msgid "Installing WebGPU"
msgstr ""

#: ../../getting-started/hello-webgpu.md:22
msgid "There exists mostly two implementations of the WebGPU native header:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:24
msgid ""
"[wgpu-native](https://github.com/gfx-rs/wgpu-native), exposing a native "
"interface to the [`wgpu`](https://github.com/gfx-rs/wgpu) Rust library "
"developed for Firefox."
msgstr ""

#: ../../getting-started/hello-webgpu.md:25
msgid "Google's [Dawn](https://dawn.googlesource.com/dawn), developed for Chrome."
msgstr ""

#: ../../getting-started/hello-webgpu.md:29
msgid ""
"There are (at least) two implementations of WebGPU, developed for the two"
" main web engines."
msgstr ""

#: ../../getting-started/hello-webgpu.md:32
msgid ""
"These two implementations still have **some discrepancies**, but they "
"will disappear as the WebGPU specification gets stable. I try to write "
"this guide such that it **works for both** of them."
msgstr ""

#: ../../getting-started/hello-webgpu.md:34
msgid ""
"To make the integration of either of these in a CMake project as easy as "
"with GLFW and without too many extra dependencies, I share a [WebGPU-"
"distribution](https://github.com/eliemichel/WebGPU-distribution) "
"repository that lets you chose one of the following options:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:36
msgid "Option A: The lightness of wgpu-native"
msgstr ""

#: ../../getting-started/hello-webgpu.md:38
msgid ""
"Since `wgpu-native` is written in rust, we cannot easily build it from "
"scratch so the distribution includes pre-compiled libraries:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:41
msgid ""
"**WIP:** Use the \"for any platform\" link rather than the platform-"
"specific ones, I haven't automated their generation yet so they are "
"usually behind the main one."
msgstr ""

#: ../../getting-started/hello-webgpu.md:44
msgid ""
"[wgpu-native for any platform](https://github.com/eliemichel/WebGPU-"
"distribution/archive/refs/heads/wgpu.zip) (a bit heavier as it's a merge "
"of all the above basically)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:45
msgid "[wgpu-native for Linux](#)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:46
msgid "[wgpu-native for Windows](#)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:47
msgid "[wgpu-native for MacOS](#)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:50
msgid ""
"The pre-compiled binaries are provided by the `wgpu-native` project "
"itself so you can likely trust them. The only thing my distribution adds "
"is a `CMakeLists.txt` that makes it easy to integrate."
msgstr ""

#: ../../getting-started/hello-webgpu.md:53
#: ../../getting-started/hello-webgpu.md:70
#: ../../getting-started/hello-webgpu.md:131
msgid "**Pros**"
msgstr ""

#: ../../getting-started/hello-webgpu.md:54
msgid "This is the most lightweight to build with."
msgstr ""

#: ../../getting-started/hello-webgpu.md:56
#: ../../getting-started/hello-webgpu.md:75
#: ../../getting-started/hello-webgpu.md:134
msgid "**Cons**"
msgstr ""

#: ../../getting-started/hello-webgpu.md:57
msgid "You do not build from source."
msgstr ""

#: ../../getting-started/hello-webgpu.md:58
msgid "`wgpu-native` does not give as informative debug information as Dawn."
msgstr ""

#: ../../getting-started/hello-webgpu.md:60
msgid "Option B: The comfort of Dawn"
msgstr ""

#: ../../getting-started/hello-webgpu.md:62
msgid ""
"Dawn gives much better error messages, and since it is written in C++ we "
"can build it from source and thus inspect more deeply the stack trace in "
"case of crash:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:64
msgid ""
"[Dawn for any platform](https://github.com/eliemichel/WebGPU-"
"distribution/archive/refs/heads/dawn.zip)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:67
msgid ""
"The Dawn-based distribution I provide here fetches the source code of "
"Dawn from its original repository, but in an as shallow as possible way, "
"and pre-sets some options to avoid building parts that we do not use."
msgstr ""

#: ../../getting-started/hello-webgpu.md:72
msgid ""
"Dawn is much more comfortable to develop with, because it gives more "
"detailed error messages."
msgstr ""

#: ../../getting-started/hello-webgpu.md:73
msgid ""
"It is in general ahead of `wgpu-native` regarding the progress of "
"implementation (but `wgpu-native` will catch up eventually)."
msgstr ""

#: ../../getting-started/hello-webgpu.md:76
msgid ""
"Although I reduced the need for extra dependencies, you still need to "
"[install Python](https://www.python.org/) and [git](https://git-"
"scm.com/download)."
msgstr ""

#: ../../getting-started/hello-webgpu.md:77
msgid ""
"The distribution fetches Dawn's source code and its dependencies so the "
"first time you build you need an **Internet connection**."
msgstr ""

#: ../../getting-started/hello-webgpu.md:78
msgid ""
"The initial build takes significantly longer, and occupies more disk "
"space overall."
msgstr ""

#: ../../getting-started/hello-webgpu.md:82
msgid "Whichever distribution you choose, the integration is the same:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:84
msgid "Download the zip of your choice."
msgstr ""

#: ../../getting-started/hello-webgpu.md:85
msgid ""
"Unzip it at the root of the project, there should be a `webgpu/` "
"directory containing a `CMakeLists.txt` file and some other (.dll or "
".so)."
msgstr ""

#: ../../getting-started/hello-webgpu.md:86
msgid "Add `add_subdirectory(webgpu)` in your `CMakeLists.txt`."
msgstr ""

#: ../../getting-started/hello-webgpu.md:94
msgid ""
"When using Dawn, make sure to add the `webgpu` directory **after** you "
"add `glfw`, otherwise Dawn provides its own version (which may be fine "
"sometimes, but you don't get to chose the version)."
msgstr ""

#: ../../getting-started/hello-webgpu.md:97
msgid ""
"Add the `webgpu` target as a dependency of our app, after GLFW in the "
"`target_link_libraries` command."
msgstr ""

#: ../../getting-started/hello-webgpu.md:104
msgid ""
"One additional step when using pre-compiled binaries: call the function "
"`target_copy_webgpu_binaries(App)` at the end of `CMakeLists.txt`, this "
"makes sure that the .dll/.so file that your binary depends on at runtime "
"is copied next to it. Whenever you distribute your application, make sure"
" to also distribute this dynamic library file as well."
msgstr ""

#: ../../getting-started/hello-webgpu.md:114
msgid ""
"In the case of Dawn, there is no precompiled binaries to copy but I "
"define the `target_copy_webgpu_binaries` function anyway (it does "
"nothing) so that you can really use the same CMakeLists with both "
"distributions."
msgstr ""

#: ../../getting-started/hello-webgpu.md:117
msgid "Option C: The flexibility of both"
msgstr ""

#: ../../getting-started/hello-webgpu.md:119
msgid ""
"Bonus option that I use in the accompanying code that enables to decide "
"on one distribution or the other upon calling `cmake`:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:127
msgid "This is given by the `main` branch of my distribution repository:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:129
msgid ""
"[WebGPU any distribution](https://github.com/eliemichel/WebGPU-"
"distribution/archive/refs/heads/main.zip)"
msgstr ""

#: ../../getting-started/hello-webgpu.md:132
msgid ""
"You can have two `build` at the same time, one that uses Dawn and one "
"that uses `wgpu-native`"
msgstr ""

#: ../../getting-started/hello-webgpu.md:135
msgid ""
"This is a \"meta-distribution\" that fetches the one you want at "
"configuration time (i.e., when calling `cmake` the first time) so you "
"need an **Internet connection** and **git** at that time."
msgstr ""

#: ../../getting-started/hello-webgpu.md:137
msgid ""
"And of course depending on your choice the pros and cons of *Option A* "
"and *Option B* apply."
msgstr ""

#: ../../getting-started/hello-webgpu.md:141
msgid ""
"If you are interested in building your application for the web, you can "
"consult [the dedicated appendix](../appendices/building-for-the-web.md)!"
msgstr ""

#: ../../getting-started/hello-webgpu.md:143
msgid "Testing the installation"
msgstr ""

#: ../../getting-started/hello-webgpu.md:146
msgid ""
"To test the implementation, we simply create the WebGPU **instance**, "
"i.e., the equivalent of the `navigator.gpu` we could get in JavaScript. "
"We then check it and destroy it."
msgstr ""

#: ../../getting-started/hello-webgpu.md:163
msgid "Descriptors and Creation"
msgstr ""

#: ../../getting-started/hello-webgpu.md:165
msgid ""
"The instance is created using the `wgpuCreateInstance` function. Like all"
" WebGPU functions meant to **create** an entity, it takes as argument a "
"**descriptor**, which we can use to specify options regarding how to set "
"up this object."
msgstr ""

#: ../../getting-started/hello-webgpu.md:177
msgid ""
"The descriptor is a kind of way to pack many function arguments together,"
" because some descriptors really have a lot of fields. It can also be "
"used to write utility functions that take care of populating the "
"arguments, to ease the program's architecture."
msgstr ""

#: ../../getting-started/hello-webgpu.md:180
msgid ""
"We meet another WebGPU idiom in the `WGPUInstanceDescriptor` structure: "
"the first field of a descriptor is always a pointer called `nextInChain`."
" This is a generic way for the API to enable custom extensions to be "
"added in the future, or to return multiple entries of data. In a lot of "
"cases, we set it to `nullptr`."
msgstr ""

#: ../../getting-started/hello-webgpu.md:183
msgid "Check"
msgstr ""

#: ../../getting-started/hello-webgpu.md:185
msgid ""
"A WebGPU entity created with a `wgpuCreateSomething` function is "
"technically **just a pointer**. It is a blind handle that identifies the "
"actual object, which lives on the backend side and to which we never need"
" direct access."
msgstr ""

#: ../../getting-started/hello-webgpu.md:187
msgid ""
"To check that an object is valid, we can just compare it with `nullptr`, "
"or use the boolean operator:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:201
msgid ""
"This should display something like `WGPU instance: 000001C0D2637720` at "
"startup."
msgstr ""

#: ../../getting-started/hello-webgpu.md:203
msgid "Destruction and lifetime management"
msgstr ""

#: ../../getting-started/hello-webgpu.md:205
msgid ""
"All the entities that can be **created** using WebGPU must eventually be "
"**released**. A procedure that creates an object always looks like "
"`wgpuCreateSomething`, and its equivalent for releasing it is "
"`wgpuSomethingRelease`."
msgstr ""

#: ../../getting-started/hello-webgpu.md:207
msgid ""
"Note that each object internally holds a reference counter, and releasing"
" it only frees related memory if no other part of your code still "
"references it (i.e., the counter falls to 0):"
msgstr ""

#: ../../getting-started/hello-webgpu.md:227
msgid "In particular, we need to release the global WebGPU instance:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:235
msgid ""
"In older versions of `wgpu-native`, the Release and Reference functions "
"did not exist, and a Drop function was used to immediately free an "
"object. See details in [this GitHub issue](https://github.com/webgpu-"
"native/webgpu-headers/issues/9)."
msgstr ""

#: ../../getting-started/hello-webgpu.md:246
msgid "Implementation-specific behavior"
msgstr ""

#: ../../getting-started/hello-webgpu.md:248
msgid ""
"In order to handle the slight differences between implementations, the "
"distributions I provide also define the following preprocessor variables:"
msgstr ""

#: ../../getting-started/hello-webgpu.md:261
msgid ""
"The case of emscripten only occurs when trying to compile our code as a "
"WebAssembly module, which is covered in the [Building for the "
"Web](../appendices/building-for-the-web.md) appendix."
msgstr ""

#: ../../getting-started/hello-webgpu.md:266
msgid ""
"In this chapter we set up WebGPU and learnt that there are **multiple "
"backends** available. We also saw the basic idioms of **object creation "
"and destruction** that will be used all the time in WebGPU API!"
msgstr ""

#: ../../getting-started/index.md:1
msgid "Getting Started"
msgstr ""

#: ../../getting-started/opening-a-window.md:1
msgid "Opening a window"
msgstr ""

#: ../../getting-started/opening-a-window.md:10
#: ../../getting-started/opening-a-window.md:131
msgid ""
"*Resulting code:* [`step001`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step001)"
msgstr ""

#: ../../getting-started/opening-a-window.md:12
msgid ""
"Before being able to render anything on screen, we need to ask the "
"Operating System to hand us some place where to draw things, something "
"commonly known as a **window**."
msgstr ""

#: ../../getting-started/opening-a-window.md:14
msgid ""
"Unfortunately, the process to open a window depends a lot on the OS, so "
"we use a little library called [GLFW](https://www.glfw.org/) which "
"unifies the different window management APIs and enables our code to be "
"**agnostic** in the OS."
msgstr ""

#: ../../getting-started/opening-a-window.md:17
msgid ""
"I try to use as little libraries as I can, but this one is required to "
"make our code cross-platform, which feels even more important to me than "
"writing code from scratch. It is furthermore a very common choice and "
"quite minimal in its design."
msgstr ""

#: ../../getting-started/opening-a-window.md:20
msgid "Headless mode"
msgstr ""

#: ../../getting-started/opening-a-window.md:21
msgid ""
"WebGPU **does not require a window** to work actually, it may also run "
"headless. Since this is not a use case as common as drawing in a window, "
"I leave the details of this option to [a dedicated chapter](../advanced-"
"techniques/headless.md) of the advanced section."
msgstr ""

#: ../../getting-started/opening-a-window.md:24
msgid "Installation of GLFW"
msgstr ""

#: ../../getting-started/opening-a-window.md:27
msgid ""
"We do **not need to install** it, we just need to add the code of GLFW to"
" our project directory. Download the file [glfw.zip](../data/glfw.zip) "
"(621 KB) and **unzip** it in your project. This is a stripped down "
"version of the official release where I removed documentation, examples "
"and tests so that it is more **lightweight**."
msgstr ""

#: ../../getting-started/opening-a-window.md:29
msgid ""
"To integrate GLFW in your project, we first add its directory to our root"
" `CMakeLists.txt`:"
msgstr ""

#: ../../getting-started/opening-a-window.md:36
msgid ""
"The name 'glfw' here designate the directory where GLFW is located, so "
"there should be a file `glfw/CMakeLists.txt`. Otherwise it means that "
"`glfw.zip` was not decompressed in the correct directory; you may either "
"move it or adapt the `add_subdirectory` directive."
msgstr ""

#: ../../getting-started/opening-a-window.md:39
msgid ""
"Then, we must tell CMake to link our application to this library (after "
"`add_executable(App main.cpp)`):"
msgstr ""

#: ../../getting-started/opening-a-window.md:46
msgid ""
"This time, the name 'glfw' is one of the *target* defined in "
"`glfw/CMakeLists.txt` by calling `add_library(glfw ...)`, it is not "
"related to a directory name."
msgstr ""

#: ../../getting-started/opening-a-window.md:49
msgid ""
"You should now be able to build the application and add `#include "
"<GLFW/glfw3.h>` at the beginning of the main file."
msgstr ""

#: ../../getting-started/opening-a-window.md:56
msgid ""
"If you are on a linux system, make sure to install the package `xorg-"
"dev`, which GLFW depends on."
msgstr ""

#: ../../getting-started/opening-a-window.md:61
msgid ""
"First of all, any call to the GLFW library must be between its "
"initialization and termination:"
msgstr ""

#: ../../getting-started/opening-a-window.md:69
msgid "The init function returns false when it could not setup things up:"
msgstr ""

#: ../../getting-started/opening-a-window.md:79
msgid "Once the library has been initialized, we may create a window:"
msgstr ""

#: ../../getting-started/opening-a-window.md:91
msgid "Here again, we may add some error management:"
msgstr ""

#: ../../getting-started/opening-a-window.md:102
msgid ""
"At this point, the window opens and closes immediately after. To address "
"this, we add the application's **main loop**:"
msgstr ""

#: ../../getting-started/opening-a-window.md:113
msgid ""
"This main loop is where most of the application's logic occurs. We will "
"repeatedly clear and redraw the whole image, and check for new user "
"input."
msgstr ""

#: ../../getting-started/opening-a-window.md:119
msgid "Our first window, using the GLFW library."
msgstr ""

#: ../../getting-started/project-setup.md:1
msgid "Project setup"
msgstr ""

#: ../../getting-started/project-setup.md:8
#: ../../getting-started/project-setup.md:150
msgid ""
"*Resulting code:* [`step000`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step000)"
msgstr ""

#: ../../getting-started/project-setup.md:10
msgid ""
"In our running example, we use [CMake](https://cmake.org/) to organize "
"the compilation of the code. This is a very standard way of handling "
"cross-platform builds, and we follow the idioms of [modern "
"cmake](https://cliutils.gitlab.io/modern-cmake/)."
msgstr ""

#: ../../getting-started/project-setup.md:12
msgid "Requirements"
msgstr ""

#: ../../getting-started/project-setup.md:15
msgid ""
"All we need is CMake and a C++ compiler, instructions are detailed below "
"per OS."
msgstr ""

#: ../../getting-started/project-setup.md:18
msgid ""
"After the installation, you can type `which cmake` (linux/macOS) or "
"`where cmake` (Windows) to see whether your command line finds the full "
"path to the `cmake` command. If not, make sure your `PATH` environment "
"variable contains the directory where CMake is installed."
msgstr ""

#: ../../getting-started/project-setup.md:21
msgid "Linux"
msgstr ""

#: ../../getting-started/project-setup.md:23
msgid ""
"If you are under an Ubuntu/Debian distribution, install the following "
"packages:"
msgstr ""

#: ../../getting-started/project-setup.md:29
msgid ""
"Other distributions have equivalent packages, make sure you have the "
"commands `cmake`, `make` and `g++` working."
msgstr ""

#: ../../getting-started/project-setup.md:31
msgid "Windows"
msgstr ""

#: ../../getting-started/project-setup.md:33
msgid ""
"Download and install CMake from [the download "
"page](https://cmake.org/download/). You may use either [Visual "
"Studio](https://visualstudio.microsoft.com/downloads/) or "
"[MinGW](https://www.mingw-w64.org/) as a compiler toolkit."
msgstr ""

#: ../../getting-started/project-setup.md:35
msgid "MacOS"
msgstr ""

#: ../../getting-started/project-setup.md:37
msgid ""
"You can install CMake using `brew install cmake`, and "
"[XCode](https://developer.apple.com/xcode/) to build the project."
msgstr ""

#: ../../getting-started/project-setup.md:39
msgid "Minimal project"
msgstr ""

#: ../../getting-started/project-setup.md:42
msgid ""
"The most minimal project consists then in a `main.cpp` source file, and a"
" `CMakeLists.txt` build file."
msgstr ""

#: ../../getting-started/project-setup.md:44
msgid "Let us start with the classic hello world in `main.cpp`:"
msgstr ""

#: ../../getting-started/project-setup.md:55
msgid ""
"In `CMakeLists.txt`, we specify that we want to create a *target* of type"
" *executable*, called \"App\" (this will also be the name of the "
"executable file), and whose source code is `main.cpp`:"
msgstr ""

#: ../../getting-started/project-setup.md:61
msgid ""
"CMake also expects at the beginning of `CMakeLists.txt` to know the "
"version of CMake the file is written for (minimum supported...your "
"version) and some information about the project:"
msgstr ""

#: ../../getting-started/project-setup.md:74
msgid "Building"
msgstr ""

#: ../../getting-started/project-setup.md:77
msgid ""
"We are now ready to build our minimal project. Open a terminal and go to "
"the directory where you have the `CMakeLists.txt` and `main.cpp` files:"
msgstr ""

#: ../../getting-started/project-setup.md:84
msgid ""
"From a Windows explorer window showing your project's directory, press "
"Ctrl+L, then type `cmd` and hit return. This opens a terminal in the "
"current directory."
msgstr ""

#: ../../getting-started/project-setup.md:87
msgid ""
"Let us now ask CMake to create the build files for our project. We ask it"
" to isolate the build files from our source code by placing them in a "
"*build/* directory with the `-B build` option. This is very much "
"recommended, in order to be able to easily distinguish these generated "
"files from the ones we manually wrote (a.k.a. the source files):"
msgstr ""

#: ../../getting-started/project-setup.md:93
msgid ""
"This creates the build files for either `make`, Visual Studio or XCode "
"depending on your system (you can use the `-G` options to force a "
"particular build system, see `cmake -h` for more info). To finally build "
"the program and generate the `App` (or `App.exe`) executable, you can "
"either open the generated Visual Studio or XCode solution, or type in the"
" terminal:"
msgstr ""

#: ../../getting-started/project-setup.md:99
msgid "Then run the resulting program:"
msgstr ""

#: ../../getting-started/project-setup.md:106
msgid "Recommended extras"
msgstr ""

#: ../../getting-started/project-setup.md:109
msgid ""
"We set up some properties of the target `App` by calling somewhere after "
"`add_executable` the `set_target_properties` command."
msgstr ""

#: ../../getting-started/project-setup.md:118
msgid ""
"The `CXX_STANDARD` property is set to 17 to mean that we require C++17 "
"(this will enable us to use some syntactic tricks later on, but is not "
"mandatory per se)."
msgstr ""

#: ../../getting-started/project-setup.md:120
msgid ""
"The `COMPILE_WARNING_AS_ERROR` is turned on as a good practice, to make "
"sure no warning is left ignored. Warnings are actually important, "
"especially when learning a new language/library. To make sure we even "
"have as many warnings as possible, we add some compile options:"
msgstr ""

#: ../../getting-started/project-setup.md:131
msgid ""
"In the accompanying code, I hid these details in the "
"`target_treat_all_warnings_as_errors()` function defined in `utils.cmake`"
" and included at the beginning of the `CMakeLists.txt`."
msgstr ""

#: ../../getting-started/project-setup.md:134
msgid ""
"On MacOS, CMake can generate XCode project files. However, by default, no"
" *schemes* are created, and XCode itself generates a scheme for each "
"CMake target -- usually we only want a scheme for our main target. "
"Therefore, we set the `XCODE_GENERATE_SCHEME` property. We will also "
"already enable frame capture for GPU debugging."
msgstr ""

#: ../../getting-started/project-setup.md:148
msgid ""
"We now have a good basic project configuration, that we'll build upon in "
"the next chapters. We are ready to move on to opening a window."
msgstr ""

#: ../../getting-started/the-adapter.md:1
msgid "The Adapter"
msgstr ""

#: ../../getting-started/the-adapter.md:10
#: ../../getting-started/the-adapter.md:382
msgid ""
"*Resulting code:* [`step010`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step010)"
msgstr ""

#: ../../getting-started/the-adapter.md:12
msgid "Requesting the adapter"
msgstr ""

#: ../../getting-started/the-adapter.md:15
msgid ""
"The first thing we need to do in order to dialog with our GPU is to get a"
" WebGPU **adapter**. It is the main entry point of the library, and the "
"same host system may expose multiple adapters if it has multiple "
"implementations of the WebGPU backend (e.g., a high performance one, a "
"low energy consumption one, etc.)."
msgstr ""

#: ../../getting-started/the-adapter.md:17
msgid "In JavaScript, this would be:"
msgstr ""

#: ../../getting-started/the-adapter.md:24
msgid ""
"The equivalent in the C API is a bit more complex because there is no "
"such thing as [promises](https://developer.mozilla.org/en-"
"US/docs/Web/JavaScript/Reference/Global_Objects/Promise) in C, but the "
"logic is very similar."
msgstr ""

#: ../../getting-started/the-adapter.md:26
msgid "Without the `await` keyword, the JavaScript version can be rewritten as:"
msgstr ""

#: ../../getting-started/the-adapter.md:35
msgid "which is close enough to the C/C++ version (minus the boilerplate):"
msgstr ""

#: ../../getting-started/the-adapter.md:55
msgid ""
"The names of the procedure provided by `webgpu.h` always follow the same "
"construction:"
msgstr ""

#: ../../getting-started/the-adapter.md:64
msgid ""
"The first argument of the function is always a \"handle\" (a blind "
"pointer) representing an object of type \"Something\"."
msgstr ""

#: ../../getting-started/the-adapter.md:67
msgid "Request"
msgstr ""

#: ../../getting-started/the-adapter.md:69
msgid ""
"We can wrap this in a `requestAdapter()` function that mimicks the JS "
"`await requestAdapter()`:"
msgstr ""

#: ../../getting-started/the-adapter.md:127
msgid "In the main function, after opening the window, we can get the adapter:"
msgstr ""

#: ../../getting-started/the-adapter.md:138
msgid "Destruction"
msgstr ""

#: ../../getting-started/the-adapter.md:140
msgid "Like for the WebGPU instance, we must destroy the adapter:"
msgstr ""

#: ../../getting-started/the-adapter.md:185
msgid "The Surface"
msgstr ""

#: ../../getting-started/the-adapter.md:194
msgid ""
"We actually need to pass an option to the adapter request: the "
"**surface** onto which we draw."
msgstr ""

#: ../../getting-started/the-adapter.md:206
msgid ""
"How do we get the surface? This depends on the OS, and GLFW does not "
"handle this for us, for it does not know WebGPU (yet?). So I provide you "
"this function, in a little extension to GLFW3 called "
"[`glfw3webgpu`](https://github.com/eliemichel/glfw3webgpu)."
msgstr ""

#: ../../getting-started/the-adapter.md:208
msgid "GLFW3 WebGPU Extension"
msgstr ""

#: ../../getting-started/the-adapter.md:210
msgid ""
"Download and unzip "
"[glfw3webgpu.zip](https://github.com/eliemichel/glfw3webgpu/releases/download/v1.0.1/glfw3webgpu-v1.0.1.zip)"
" in your project's directory. There should now be a directory "
"`glfw3webgpu` sitting next to your `main.cpp`. Like we have done before, "
"we can add this directory and link the target it creates to our App:"
msgstr ""

#: ../../getting-started/the-adapter.md:222
msgid ""
"The `glfw3webgpu` library is very simple, it is only made of 2 files so "
"we could have almost included them directly in our project's source tree."
" However, it requires some special compilation flags in macOS that we "
"would have had to deal with (you can see them in the `CMakeLists.txt`)."
msgstr ""

#: ../../getting-started/the-adapter.md:225
msgid ""
"You can now `#include <glfw3webgpu.h>` at the beginning of your "
"`main.cpp` and get the surface by simply doing:"
msgstr ""

#: ../../getting-started/the-adapter.md:235
msgid "Also don't forget to release the surface at the end:"
msgstr ""

#: ../../getting-started/the-adapter.md:247
msgid ""
"One last thing: we can **tell GLFW not to care about the graphics API** "
"setup, as it does not know WebGPU and we won't use what it could set up "
"by default for other APIs:"
msgstr ""

#: ../../getting-started/the-adapter.md:268
msgid ""
"The `glfwWindowHint` function is a way to pass optional arguments to "
"`glfwCreateWindow`. Here we tell it to initialize no particular graphics "
"API by default, as we manage this ourselves."
msgstr ""

#: ../../getting-started/the-adapter.md:271
msgid ""
"I invite you to look at the documentation of GLFW to know more about "
"[`glfwCreateWindow`](https://www.glfw.org/docs/latest/group__window.html#ga3555a418df92ad53f917597fe2f64aeb)"
" and other related functions."
msgstr ""

#: ../../getting-started/the-adapter.md:274
msgid "Inspecting the adapter"
msgstr ""

#: ../../getting-started/the-adapter.md:277
msgid ""
"The adapter object provides **information about the underlying "
"implementation** and hardware, and about what it is able or not to do."
msgstr ""

#: ../../getting-started/the-adapter.md:279
msgid ""
"Let us focus on the `wgpuAdapterEnumerateFeatures` function, which "
"enumerates the features of the WebGPU implementation, because its usage "
"is very typical from WebGPU native."
msgstr ""

#: ../../getting-started/the-adapter.md:281
msgid ""
"We call the function **twice**. The **first time**, we provide a null "
"pointer as the return, and as a consequence the function only returns the"
" **number of features**, but not the features themselves."
msgstr ""

#: ../../getting-started/the-adapter.md:283
msgid ""
"We then dynamically **allocate memory** for storing this many items of "
"result, and call the same function a **second time**, this time with a "
"pointer to where the result should store its result."
msgstr ""

#: ../../getting-started/the-adapter.md:318
msgid ""
"The features are numbers corresponding to the enum `WGPUFeatureName` "
"defined in `webgpu.h`."
msgstr ""

#: ../../getting-started/the-adapter.md:320
msgid ""
"You may notice very high numbers apparently not defined in this enum. "
"These are **extensions** provided by our native implementation (e.g., "
"defined in `wgpu.h` instead of `webgpu.h` in the case of `wgpu-native`)."
msgstr ""

#: ../../getting-started/the-adapter.md:323
msgid ""
"In the accompanying code, extra information retrieval is exemplified in "
"the `inspectAdapter()` function. Look in `webgpu.h` for function that "
"starts with `wgpuAdapter` to find other adapter methods."
msgstr ""

#: ../../getting-started/the-adapter.md:377
msgid "The very first thing to do with WebGPU is to get the **adapter**."
msgstr ""

#: ../../getting-started/the-adapter.md:378
msgid ""
"This adapter can have **options**, in particular the **surface** on which"
" it draws."
msgstr ""

#: ../../getting-started/the-adapter.md:379
msgid ""
"To get a WebGPU surface from our GLFW window, we use a small **extension "
"of GLFW** called `glfw3webgpu`."
msgstr ""

#: ../../getting-started/the-adapter.md:380
msgid "Once we have an adapter, we can inspect its **capabilities**."
msgstr ""

#: ../../getting-started/the-command-queue.md:1
msgid "The Command Queue"
msgstr ""

#: ../../getting-started/the-command-queue.md:9
#: ../../getting-started/the-command-queue.md:196
msgid ""
"*Resulting code:* [`step017`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step017)"
msgstr ""

#: ../../getting-started/the-command-queue.md:11
msgid ""
"We are getting close, but we will still not display anything on our "
"window. We learn in this chapter a key concept of WebGPU (and of most "
"modern graphics APIs as well): the **command queue**."
msgstr ""

#: ../../getting-started/the-command-queue.md:16
msgid ""
"The CPU instructs the GPU what to do by sending commands through a "
"command queue."
msgstr ""

#: ../../getting-started/the-command-queue.md:19
msgid "Different timelines"
msgstr ""

#: ../../getting-started/the-command-queue.md:22
msgid ""
"One thing important to keep in mind when doing graphics programming: we "
"have **two processors running simultaneously**. One of them is the CPU, "
"also known as *host*, and the other one is the GPU, or *device*. There "
"are two rules:"
msgstr ""

#: ../../getting-started/the-command-queue.md:24
msgid ""
"**The code we write runs on the CPU**, and some of it triggers operations"
" on the GPU. The only exception are *shaders*, which actually run on GPU."
msgstr ""

#: ../../getting-started/the-command-queue.md:25
msgid ""
"Processors are \"**far away**\", meaning that communicating between them "
"takes time."
msgstr ""

#: ../../getting-started/the-command-queue.md:27
msgid ""
"They are not too far, but for high performance applications like real "
"time graphics, this matters. In advanced pipelines, rendering a frame may"
" involve thousands or tens of thousands of commands running on the GPU."
msgstr ""

#: ../../getting-started/the-command-queue.md:29
msgid ""
"As a consequence, we cannot afford to send the commands one by one from "
"the CPU and wait for a response after each one. Instead, commands meant "
"to the GPU are batched and fired through a **command queue**. The GPU "
"consumes this queue whenever it is ready, and this way processors "
"minimize the time spend idling for their sibling to respond."
msgstr ""

#: ../../getting-started/the-command-queue.md:31
msgid ""
"The CPU-side of your program, i.e., the C++ code that you write, lives in"
" the **Content timeline**. The other side of the command queue is the "
"**Queue timeline**, running on the GPU."
msgstr ""

#: ../../getting-started/the-command-queue.md:34
msgid ""
"There is also a **Device timeline** defined in [WebGPU's "
"documentation](https://www.w3.org/TR/webgpu/#programming-model-"
"timelines). It corresponds to the GPU operations for which our code "
"actually waits for an immediate answer (called \"synchronous\" calls), "
"but unlike the JavaScript API, it is roughly the same as the content "
"timeline in our C++ case."
msgstr ""

#: ../../getting-started/the-command-queue.md:37
msgid "Queue operations"
msgstr ""

#: ../../getting-started/the-command-queue.md:40
msgid ""
"Our WebGPU device has a single queue, which we can get with "
"`wgpuDeviceGetQueue`."
msgstr ""

#: ../../getting-started/the-command-queue.md:47
msgid ""
"Other graphics API allow one to build multiple queues per device, and "
"future version of WebGPU might as well. But for now, one queue is already"
" more than enough for us to play with!"
msgstr ""

#: ../../getting-started/the-command-queue.md:50
msgid ""
"Looking at `webgpu.h`, we find 3 different ways to submit work to this "
"queue:"
msgstr ""

#: ../../getting-started/the-command-queue.md:52
msgid "`wgpuQueueSubmit`"
msgstr ""

#: ../../getting-started/the-command-queue.md:53
msgid "`wgpuQueueWriteBuffer`"
msgstr ""

#: ../../getting-started/the-command-queue.md:54
msgid "`wgpuQueueWriteTexture`"
msgstr ""

#: ../../getting-started/the-command-queue.md:56
msgid ""
"The first one only sends commands (potentially complicated ones though), "
"and the two other ones send memory from the CPU memory (RAM) to the GPU "
"one (VRAM). This is where the delay of the communication might become "
"particularly critical."
msgstr ""

#: ../../getting-started/the-command-queue.md:58
msgid ""
"We also find a `wgpuQueueOnSubmittedWorkDone` procedure that we can use "
"to set up a function to be called back once the work is done. Let us do "
"it to make sure things happen as expected:"
msgstr ""

#: ../../getting-started/the-command-queue.md:78
msgid "Submitting commands"
msgstr ""

#: ../../getting-started/the-command-queue.md:81
msgid "We submit commands using the following procedure:"
msgstr ""

#: ../../getting-started/the-command-queue.md:87
msgid ""
"We see **a typical idiom** here: WebGPU is a C API so whenever it needs "
"to receive an array of things, we first provide the array size then a "
"pointer to the first element."
msgstr ""

#: ../../getting-started/the-command-queue.md:89
msgid "If we have a single element, it is simply:"
msgstr ""

#: ../../getting-started/the-command-queue.md:97
msgid ""
"If we know at compile time (\"statically\") the number of commands, we "
"may use a C array (although a `std::array` is safer):"
msgstr ""

#: ../../getting-started/the-command-queue.md:115
msgid "And if we need to dynamically change the size, we use a `std::vector`:"
msgstr ""

#: ../../getting-started/the-command-queue.md:123
msgid ""
"However, we **cannot manually create** a `WGPUCommandBuffer` object. This"
" buffer uses a special format that is left to the discretion of your "
"driver/hardware. To build this buffer, we use a **command encoder**."
msgstr ""

#: ../../getting-started/the-command-queue.md:125
msgid "Command encoder"
msgstr ""

#: ../../getting-started/the-command-queue.md:128
msgid ""
"A command encoder is created following the usual object creation idiom of"
" WebGPU:"
msgstr ""

#: ../../getting-started/the-command-queue.md:137
msgid ""
"We can now use the encoder to write instructions (debug placeholder for "
"now)."
msgstr ""

#: ../../getting-started/the-command-queue.md:144
msgid ""
"And then finally generating the command from the encoder also requires an"
" extra descriptor:"
msgstr ""

#: ../../getting-started/the-command-queue.md:174
msgid "This should output:"
msgstr ""

#: ../../getting-started/the-command-queue.md:181
msgid ""
"At this stage, the code works, but submits a command queue that is almost"
" empty. So it is a bit hard to be thrilled about, let's pump it up with "
"some basic buffer manipulation."
msgstr ""

#: ../../getting-started/the-command-queue.md:186
msgid "We have seen a few important notions in this chapter:"
msgstr ""

#: ../../getting-started/the-command-queue.md:188
msgid "The CPU and GPU live in **different timelines**."
msgstr ""

#: ../../getting-started/the-command-queue.md:189
msgid "Commands are streamed from CPU to GPU through a **command queue**."
msgstr ""

#: ../../getting-started/the-command-queue.md:190
msgid "Queued command buffers must be encoded using a **command encoder**."
msgstr ""

#: ../../getting-started/the-command-queue.md:192
msgid ""
"This was a bit abstract because we can queue operations but we did not "
"see any yet. In the next chapter we use it to **finally display "
"something** in our window!"
msgstr ""

#: ../../getting-started/the-command-queue.md:194
msgid ""
"We will also see in [*Playing with buffers*](../basic-3d-rendering/input-"
"geometry/playing-with-buffers.md) how to use it for GPU-side buffer "
"manipulation."
msgstr ""

#: ../../getting-started/the-device.md:1
msgid "The Device"
msgstr ""

#: ../../getting-started/the-device.md:9
#: ../../getting-started/the-device.md:238
msgid ""
"*Resulting code:* [`step015`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step015)"
msgstr ""

#: ../../getting-started/the-device.md:11
msgid ""
"A WebGPU **device** represents a **context** of use of the API. All the "
"objects that we create (geometry, textures, etc.) are owned by the "
"device."
msgstr ""

#: ../../getting-started/the-device.md:13
msgid "ðŸ¤” Why do we have both an **adapter** and then a **device** abstraction?"
msgstr ""

#: ../../getting-started/the-device.md:15
msgid ""
"The idea is to limit the \"it worked on my machine\" issue you could "
"encounter when trying your program on a different machine. The "
"**adapter** is used to **access the capabilities** of the customer's "
"hardware, which are used to select the behavior of your application among"
" very different code paths. Once a code path is chosen, a **device** is "
"created with **the capabilities we choose**."
msgstr ""

#: ../../getting-started/the-device.md:17
msgid ""
"Only the capabilities selected for this device are then allowed in the "
"rest of the application. This way, it is **not possible to inadvertently "
"rely on capabilities specific to your own machine**."
msgstr ""

#: ../../getting-started/the-device.md:21
msgid ""
"In an advanced use of the adapter/device duality, we can set up multiple "
"limit presets and select one depending on the adapter. In our case, we "
"have a single preset and abort early if it is not supported."
msgstr ""

#: ../../getting-started/the-device.md:24
msgid "Device request"
msgstr ""

#: ../../getting-started/the-device.md:27
msgid ""
"Requesting the device looks a lot like requesting the adapter, so we will"
" use a very similar function:"
msgstr ""

#: ../../getting-started/the-device.md:72
msgid ""
"In the accompanying code, I moved these utility functions into `webgpu-"
"utils.cpp`"
msgstr ""

#: ../../getting-started/the-device.md:142
msgid ""
"In the main function, after getting the adapter, we can request the "
"device:"
msgstr ""

#: ../../getting-started/the-device.md:159
msgid "And before destroying the adapter, we release the device:"
msgstr ""

#: ../../getting-started/the-device.md:165
msgid "Device descriptor"
msgstr ""

#: ../../getting-started/the-device.md:168
msgid "Let us look in `webgpu.h` what the descriptor looks like:"
msgstr ""

#: ../../getting-started/the-device.md:187
msgid "For now we will initialize this to a very minimal option:"
msgstr ""

#: ../../getting-started/the-device.md:198
msgid ""
"We will come back here and refine these options whenever we will need "
"some more capabilities from the device."
msgstr ""

#: ../../getting-started/the-device.md:201
msgid ""
"The `label` is **used in error message** to help you debug where "
"something went wrong, so it is good practice to use it as soon as you get"
" multiple objects of the same type. Currently, this is only used by Dawn."
msgstr ""

#: ../../getting-started/the-device.md:204
msgid "Device error callback"
msgstr ""

#: ../../getting-started/the-device.md:207
msgid ""
"Before moving on to the next section, I would like you to add this call "
"after creating the device:"
msgstr ""

#: ../../getting-started/the-device.md:218
msgid ""
"This defines **a callback that gets executed upon errors**, which is very"
" handy for debugging, especially when we will start using "
"**asynchronous** operations."
msgstr ""

#: ../../getting-started/the-device.md:220
msgid ""
"If you use a debugger (which I recommend), like `gdb` or your IDE, I "
"recommend you **put a breakpoint** in this callback, so that your program"
" pauses and provides you with a call stack whenever WebGPU encounters an "
"unexpected error."
msgstr ""

#: ../../getting-started/the-device.md:223
msgid ""
"By default Dawn runs callbacks only when the device \"ticks\", so the "
"error callbacks are invoked in a different call stack than where the "
"error occurred, making the breakpoint less informative. To force Dawn to "
"invoke error callbacks as soon as there is an error, you can set the "
"environment variable `DAWN_DEBUG_BREAK_ON_ERROR` to a non-empty non-zero "
"value."
msgstr ""

#: ../../getting-started/the-device.md:225
msgid ""
"To automatically set this up in Visual Studio from CMake, you can add the"
" following to your `CMakeLists.txt`:"
msgstr ""

#: ../../getting-started/the-device.md:231
msgid ""
"Note that **this feature is imperfect** and sometimes breaks in non-error"
" cases. This [has been "
"reported](https://bugs.chromium.org/p/dawn/issues/detail?id=1789&q=&can=4),"
" in the meantime just press \"Continue\" in your IDE when this happens."
msgstr ""

#: ../../getting-started/the-device.md:234
msgid "Dawn again"
msgstr ""

#: ../../getting-started/the-device.md:235
msgid ""
"Dawn will show a warning about a missing **device lost callback**. You "
"may set it in a very similar way than the error callback, except as of "
"now (2023-07-04) the API is different in the official `webgpu.h` header, "
"so I won't add it until this is settled."
msgstr ""

#: ../../index.md:1
msgid "Learn WebGPU"
msgstr ""

#: ../../index.md:4
msgid "*For native graphics in C++.*"
msgstr ""

#: ../../index.md:6
msgid ""
"This documentation walks you through the use of the "
"[WebGPU](https://www.w3.org/TR/webgpu) graphics API to create **native 3D"
" applications** in C++ from scratch, for Windows, Linux and macOS."
msgstr ""

#: ../../introduction.md:4
msgid "What is a graphics API?"
msgstr ""

#: ../../introduction.md:7
msgid ""
"A personal computer or smartphone commonly contains two computing units: "
"the **CPU** (for *Central Processing Unit*) and the **GPU** (*Graphics "
"Processing Unit*). When programming an application, **one primarily "
"writes instructions for the CPU**. This is what most of programming "
"languages are for."
msgstr ""

#: ../../introduction.md:11
msgid ""
"The CPU and GPU are two different processors. We program the CPU so that "
"it instructs the GPU what to do through the graphics API and the driver."
msgstr ""

#: ../../introduction.md:14
msgid ""
"If one wants the application to execute instructions on the GPU (e.g., to"
" render 3D images), the CPU code must **send instructions to the driver**"
" of the GPU. A graphics API is a programming interface used by the CPU "
"code to dialog with the GPU."
msgstr ""

#: ../../introduction.md:16
msgid ""
"There exists many such APIs, for instance you may have heard of OpenGL, "
"DirectX, Vulkan or Metal."
msgstr ""

#: ../../introduction.md:19
msgid ""
"In theory anyone can invent their own graphics API. Each GPU vendor has "
"its own low-level protocol for their driver to dialog with the hardware, "
"on top of which the more common APIs are implemented (often provided with"
" the driver)."
msgstr ""

#: ../../introduction.md:22
msgid ""
"In this documentation, we learn a graphics API called "
"[WebGPU](https://www.w3.org/TR/webgpu/). This API has been designed to "
"provide a **unified access** to GPUs whichever the GPU vendor and "
"operating system the application runs with."
msgstr ""

#: ../../introduction.md:27
msgid ""
"WebGPU is a *Render Hardware Interface* built on top of the various APIs "
"provided by the driver/OS depending on your platform. This duplicated "
"development effort is made once by the web browsers and made available to"
" us through the `webgpu.h` header they provide."
msgstr ""

#: ../../introduction.md:36
msgid "Why WebGPU?"
msgstr ""

#: ../../introduction.md:39
msgid ""
"ðŸ¤” Yeah, why in the world would I use a **web API** to develop a **desktop"
" application**?"
msgstr ""

#: ../../introduction.md:41
msgid "Glad you asked, the short answer is:"
msgstr ""

#: ../../introduction.md:43
msgid "Reasonable level of abstraction"
msgstr ""

#: ../../introduction.md:44
msgid "Good performance"
msgstr ""

#: ../../introduction.md:45
msgid "Cross-platform"
msgstr ""

#: ../../introduction.md:46
msgid "Standard enough"
msgstr ""

#: ../../introduction.md:47
msgid "Future-proof"
msgstr ""

#: ../../introduction.md:49
msgid ""
"And it is actually the **only** graphics API that benefits from all of "
"these properties!"
msgstr ""

#: ../../introduction.md:51
msgid ""
"Yes, the WebGPU API has been **designed primarily for the web**, as an "
"interface between JavaScript and GPUs. This is **not a drawback**, since "
"as of today the requirements in terms of performance for web pages is "
"actually the same as for native application. You can read more about [why"
" I believe that WebGPU is the best graphics API to learn in "
"2023](appendices/teaching-native-graphics-in-2023.md)."
msgstr ""

#: ../../introduction.md:54
msgid ""
"When designing an API for the Web, the two key constraints are "
"**portability** and **privacy**. We **benefit** here from the effort "
"developed for portability, and fortunately the limitations of the API due"
" to privacy considerations can be **disabled** when using WebGPU as a "
"native API."
msgstr ""

#: ../../introduction.md:57
msgid "Why C++ then?"
msgstr ""

#: ../../introduction.md:60
msgid ""
"Shouldn't we use **JavaScript** since it is the initial target of WebGPU?"
" Or **C** because it is the language of the `webgpu.h` header we'll be "
"using? Or **Rust** since this is the language in which one of the WebGPU "
"backend is written? All of these are valid languages to use WebGPU with, "
"but I chose C++ because:"
msgstr ""

#: ../../introduction.md:62
msgid ""
"C++ is still the primary language used for high performance graphics "
"application (video games, render engines, modeling tools, etc.)."
msgstr ""

#: ../../introduction.md:63
msgid ""
"The level of abstraction and control of C++ is well suited for "
"interacting with graphics APIs in general."
msgstr ""

#: ../../introduction.md:64
msgid ""
"Graphics programming is a very good occasion to really learn C++. I will "
"only assume a very shallow knowledge of this language in the beginning."
msgstr ""

#: ../../introduction.md:67
msgid ""
"For an equivalent of this documentation for Rust, I recommend you to have"
" a look at Sotrh's [Learn WGPU](https://sotrh.github.io/learn-wgpu)."
msgstr ""

#: ../../introduction.md:70
msgid "How to use this documentation?"
msgstr ""

#: ../../introduction.md:73
msgid "Reading"
msgstr ""

#: ../../introduction.md:75
msgid ""
"The first two parts of this documentation have been designed to be read "
"sequentially, as a full lecture, but its different pages can also be used"
" as reminders on specific topics."
msgstr ""

#: ../../introduction.md:77
msgid ""
"The [Getting Started](getting-started/index.md) part deals with the "
"boilerplate needed to initialize WebGPU and the window management (using "
"GLFW), and introduces key concepts and idioms of the API. In this "
"section, we manipulate the raw C API, and finish by introducing the C++ "
"wrapper that we use in the rest of this documentation."
msgstr ""

#: ../../introduction.md:79
msgid ""
"It is possible to **go straight to part 2** on [Basic 3D Rendering"
"](basic-3d-rendering/index.md) and use the boilerplate code resulting "
"from part 1 as a starter kit. You can always come back later to the "
"details of the getting started part later on."
msgstr ""

#: ../../introduction.md:81
msgid ""
"Rendering is far from being the only use of GPUs nowadays; part 3 "
"introduces [Basic Compute](basic-compute/index.md), i.e., non-rendering "
"use of WebGPU."
msgstr ""

#: ../../introduction.md:83
msgid ""
"The fourth part [Advanced Techniques](advanced-techniques/index.md) is "
"made of focus points on various computer graphics techniques, which can "
"be read more independently on each others."
msgstr ""

#: ../../introduction.md:85
msgid "Literate Programming"
msgstr ""

#: ../../introduction.md:88
msgid ""
"This guide is in an early phase; it is only available for the first few "
"chapters."
msgstr ""

#: ../../introduction.md:91
msgid ""
"This guide follows the principle of **Literate Programming**: the "
"documentation you read is annotated such that one can **automatically "
"combine its code blocks** into a fully working code. This is a way to "
"ensure that the guide truly contains everything you need to **reproduce "
"the results**."
msgstr ""

#: ../../introduction.md:93
msgid ""
"On the right-hand sidebar of the chapters that support it, you can "
"enable/disable the display of these information:"
msgstr ""

#: ../../introduction.md:105
msgid ""
"Everything is turned off by default to avoid visual clutter, but if you "
"feel you don't know where exactly to include in particular code snippet, "
"you can turn them on."
msgstr ""

#: ../../introduction.md:107
msgid "Contributing"
msgstr ""

#: ../../introduction.md:109
msgid ""
"If you encounter any typo or more important issue, feel free of fixing it"
" by clicking the edit button present on top of each page!"
msgstr ""

#: ../../introduction.md:111 ../../introduction.md:116
msgid "Use the edit button present on top of each page!"
msgstr ""

#: ../../introduction.md:121
msgid ""
"More generally, you can discuss any technical or organizational choice "
"through [the repo's "
"issues](https://github.com/eliemichel/LearnWebGPU/issues). Any "
"constructive and/or benevolent feedback is welcome!"
msgstr ""

#: ../../introduction.md:123
msgid "Work In Progress"
msgstr ""

#: ../../introduction.md:125
msgid ""
"This guide is still under construction, and the WebGPU API itself is as "
"well. I am trying to follow as tightly as I can the changes, but until "
"the API gets stable this inherently leads to slight inconsistencies."
msgstr ""

#: ../../introduction.md:127
msgid ""
"Always pay attention to the date of last modification of a page and of "
"the accompanying code (using "
"[git](https://github.com/eliemichel/LearnWebGPU)). They may not be "
"perfectly in sync; usually I first update the code, then the content of "
"the guide."
msgstr ""

