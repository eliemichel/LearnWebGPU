# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2023, Ã‰lie Michel and contributors
# This file is distributed under the same license as the Learn WebGPU for
# C++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Learn WebGPU for C++ \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-25 09:12+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ko\n"
"Language-Team: ko <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:1
msgid "A simple example"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:5
#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:245
msgid ""
"*Resulting code:* [`step050`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step050)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:9
#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:249
msgid ""
"*Resulting code:* [`step050-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step050-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:12
msgid ""
"Let's dive into what you are quite likely here for: rendering **3D "
"shapes**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:15
msgid ""
"I rolled back the part of the code about dynamic uniforms for now. I also"
" set the `offset` to `vec2f(0.0)`;"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:18
msgid "Switching to 3D data"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:21
msgid "The first thing we need is a 3rd column in our point position!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:23
msgid "Here is a simple shape that you can save in `resources/pyramid.txt`:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:50
msgid ""
"Of course we need to adapt our `loadGeometry` function to handle this "
"extra dimension. I added a `int dimensions` argument that should be "
"either 2 or 3 depending on whether we are in 2D or 3D:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:64
msgid "We can now load the geometry as follows:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:70
msgid ""
"As a consequence of this new dimension, we need to update the vertex "
"buffer stride, the position attribute format and the color attribute "
"offset:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:87
msgid "We also need to increase the maximum stride of vertex arrays:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:95
msgid "And don't forget to update the vertex input struct in the **shader**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:105
msgid ""
"Now it kinda works, we can guess a pyramid is here, but I wouldn't call "
"it 3D yet. And adding `in.position.z` to `out.position.z` does not change"
" anything so far:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:110
msgid "The pyramid... seen from above, with no perspective."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:114
msgid ""
"I intentionally set a different color for the tip of the pyramid so that "
"we can see better. This will be better addressed when introducing a basic"
" **shading**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:117
msgid "Basic transform"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:120
msgid ""
"*This is a gentle introduction to trigonometry. If you are familiar with "
"the concept, you may jump ahead.*"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:122
msgid ""
"Seen from above, this pyramid boringly looks like an square. Could we "
"**rotate** this? A very basic way to change the view angle is to swap "
"axes:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:136
msgid "The pyramid seen from the side (still no perspective)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:139
msgid ""
"What about in-between rotations? The idea is to **mix axes**, adding a "
"little bit of z in the y coordinates and a little bit of y in the z "
"coordinates."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:153
msgid "The pyramid from a tilted view angle."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:156
msgid ""
"Of course at some point we have to remove some of `in.position.y` from Y "
"so that after a quarter of turn we reach `Y = 0.0 * in.position.y + 1.0 *"
" in.position.z`, as in the example above. So more generally our transform"
" writes like this, where `alpha` and `beta` depend on the rotation angle:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:171
msgid ""
"If you payed close attention to the snippet above, you should have "
"noticed **a minus sign** `-` before the second `beta`. It is not visible "
"on our pyramid because it is symmetrical but swapping axes also flips the"
" object. To **counter-balance** this, we can change the sign of one of "
"the dimensions. Hence the Z coordinate after a quarter of turn must be "
"`-in.position.y` instead of `in.position.y`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:174
msgid ""
"It turns out that these weights `alpha` and `beta` are not easy to "
"express in terms of basic operations with respect to the angle. So "
"mathematicians came up with a dedicated name for them: **cosine** and "
"**sine**! And the good news is that these are **built-in operations** in "
"WGSL:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:207
msgid ""
"Congratulations, you have learned most of what there is to know about "
"**trigonometry** for computer graphics!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:210
msgid ""
"**If you cannot remember** which one is the $cos$ and which one is the "
"$sin$ among `alpha` and `beta` (don't worry it happens to all the time), "
"**just take an example** of very simple rotation: `angle = 0`. In such a "
"case, we need `alpha = 1` and `beta = 0`. If you look at a plot of the "
"$sin$ and $cos$ functions you'll quickly see that $cos(0) = 1$ and "
"$sin(0) = 0$"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:214
msgid ""
"The argument of trigonometric functions is an **angle**, but be aware "
"that it must be expressed in **radians**. There is a total of $2\\pi$ "
"radians for a full turn, which leads to the following elementary cross-"
"multiplication rule:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:216
msgid ""
"\n"
"\\frac{r \\text{ radians}}{d \\text{ degrees}} = \\frac{2\\pi \\text{ "
"radians}}{360 \\text{ degrees}}\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:220
msgid ""
"So to convert an angle $d$ in degrees into its equivalent $r$ in radians,"
" we simply do:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:222
msgid ""
"\n"
"r = d \\times \\frac{\\pi}{180}\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:227
#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:343
#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:341
#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:224
#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:697
#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:415
#: ../../basic-3d-rendering/hello-triangle.md:477
#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:376
#: ../../basic-3d-rendering/input-geometry/index-buffer.md:187
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:481
#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:344
#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:329
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:204
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:110
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:456
#: ../../basic-3d-rendering/lighting-and-material/pbr.md:66
#: ../../basic-3d-rendering/lighting-and-material/specular.md:302
#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:258
#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:246
#: ../../basic-3d-rendering/some-interaction/camera-control.md:266
#: ../../basic-3d-rendering/some-interaction/lighting-control.md:382
#: ../../basic-3d-rendering/some-interaction/refactoring.md:268
#: ../../basic-3d-rendering/some-interaction/resizing-window.md:202
#: ../../basic-3d-rendering/some-interaction/simple-gui.md:256
#: ../../basic-3d-rendering/texturing/a-first-texture.md:477
#: ../../basic-3d-rendering/texturing/loading-from-file.md:516
#: ../../basic-3d-rendering/texturing/sampler.md:578
#: ../../basic-3d-rendering/texturing/texture-mapping.md:201
msgid "Conclusion"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:230
msgid ""
"We have a beginning of something. With this rotation, it starts looking "
"like 3D, but there remains some important points to be concerned about:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:232
msgid ""
"**Depth fighting** As highlighted in the image below, the triangles do "
"not overlap in the correct order."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:233
msgid ""
"**Transform** We have the basics, but it is a bit manual, and there is "
"still **no perspective**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:234
msgid ""
"**Shading** The trick of setting the tip of the pyramid to a darker color"
" was good for starting, but we can do much better."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:236
msgid ""
"These points are, in this order, the topic of the next 4 chapters "
"(transforms are split in 2 chapters)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/a-simple-example.md:241
#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:15
msgid "There is something wrong with the depth."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:1
msgid "Basic shading"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:5
#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:349
msgid ""
"*Resulting code:* [`step056`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step056)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:9
#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:353
msgid ""
"*Resulting code:* [`step056-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step056-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:12
msgid ""
"From the beginning of this 3D mesh section, **we have been cheating** by "
"darkening the color of the tip of the pyramid in order to get some sense "
"of the geometry. But in reality, the strongest **visual clues** we get "
"about the geometry of the objects that surround us come from the "
"**lighting effects**, and in particular the **shading**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:14
msgid ""
"In this chapter we get **an intuition** about how to shade a scene, but "
"do not follow a very physically based approach (this will come later on)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:16
msgid "Theory"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:19
msgid ""
"Let's be quick with the theory, because we've had enough in the previous "
"chapter. Simply look at this picture:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:24
msgid "It is always a good idea to observe natural images."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:27
msgid ""
"The jar has a more or less uniform material. Yet, its different sides "
"**look** different, the left-hand squared area is darker than the right-"
"hand one."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:29
msgid ""
"Why so? Because they have different **orientations**. One is oriented "
"towards the light, whereas the other one faces a different direction."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:31
msgid ""
"The direction of a face is expressed as **a vector that is perpendicular "
"to the face**. This is called a **normal** vector, and it always has "
"length 1 because all we care about is its direction (it is called a "
"*normalized* vector, or a *unit* vector)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:48
msgid ""
"There are **two possible** vectors that are perpendicular to the face and"
" have a unit length: one and its opposite (going towards the other side "
"of the face). **By convention**, we point the normal towards the outside "
"of the object, but this might not be well defined for meshes that are not"
" closed. Whenever you encounter weird shading artifacts, always check "
"your normals!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:51
msgid "Normal"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:54
msgid "Data"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:56
msgid ""
"The normals can be mathematically computed (using the cross product of "
"two sides of the triangle), but it is common to **store them in the 3D "
"file** format, because sometimes we use intentionally fake normals to "
"give the feeling that triangles are slightly curved."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:58
msgid ""
"We will add this normal information to our little file format and add a "
"new vertex attribute:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:102
msgid ""
"I had to **duplicate some points**, because although they have the same "
"location, they have different normals depending on the face they belong "
"to. Actually, vertices should be considered in general as **face "
"corners** rather than 3D points."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:106
msgid ""
"To better see the impact of our shading, I gave the same base color to "
"the whole pyramid this time."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:109
msgid "Loading"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:111
msgid ""
"We do not need to change our geometry loading procedure, only the number "
"of float attributes per vertex:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:118
msgid ""
"The `vertexData` array now contains 3 attributes per vertex. In order to "
"**better manage** our vertex attributes, we can create a structure that "
"we will use similarly to the `MyUniforms` struct:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:132
msgid "This structure mirrors the `VertexInput` struct from the WGSL shader:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:142
msgid ""
"The **order of the fields** does not need to be the same. The order of "
"the fields in the C++ struct `VertexAttributes` is driven by the order in"
" which the data is stored in the loaded file."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:144
msgid ""
"The order in `VertexInput` does not matter, and the `@location` must "
"match the attribute definition:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:171
msgid "And do not forget to change the device limits:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:188
msgid "Shading"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:191
msgid "Light direction"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:193
msgid ""
"Now the normal data is loaded from the file, and accessible to the vertex"
" shader. But shading occurs in the **fragment shader**, so we need to "
"forward the normal attribute:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:213
msgid ""
"In order to **check that everything is piped up correctly**, you can try "
"to just use the coordinates of the normal vector as the output color. "
"Since these coordinates are in the range $(-1,1)$, I usually add ` * 0.5 "
"+ 0.5` to remap them in the range $(0,1)$, which the color output "
"expects:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:231
msgid "Let's now do some experiments with this normal:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:243
msgid ""
"Multiplying the color by the normal axes creates axis-aligned directional"
" lights."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:246
msgid ""
"To apply a lighting coming from an arbitrary direction, we again use a "
"linear combination of the different axes:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:259
msgid ""
"Mixing multiple axes can create a directional light coming from any "
"direction."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:262
msgid ""
"The coefficient $(0.5, -0.9, 0.1)$ are in fact the **light direction** "
"This combination is called a **dot product**:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:274
msgid ""
"The term \"direction\" suggests that this is a **normalized** vector "
"(i.e., a vector whose length is $1$. Here we actually encode the "
"direction plus the **intensity** of the light, through the magnitude "
"(i.e., length) of the vector."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:277
msgid "Multiple lights"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:279
msgid ""
"Adding multiple light sources is as simple as summing the contribution of"
" multiple directions. One important thing though:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:318
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:321
msgid "Transform"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:321
msgid ""
"In the previous part, the light direction changes with the object's "
"orientation. To apply a fixed global lighting, we need to transform the "
"normal wrt. the model transform, but not the view transform (hence the "
"distinction)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/basic-shading.md:346
msgid ""
"We will see a much more accurate material model in the [Lighting and "
"material](/basic-3d-rendering/lighting-and-material/index.md) chapter."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:1
msgid "Depth buffer"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:5
#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:353
msgid ""
"*Resulting code:* [`step052`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step052)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:9
#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:357
msgid ""
"*Resulting code:* [`step052-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step052-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:18
msgid "The Z-Buffer algorithm"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:21
msgid ""
"The issue we are facing with this basic example comes from the problem of"
" **visibility**. As easy to conceive as it is, the question \"does this "
"point see that one\" (i.e., does the line between them intersect any "
"geometry) is hard to answer efficiently."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:23
msgid ""
"In particular, when producing a **fragment**, we must figure out whether "
"the 3D point it corresponds to is seen by the view point in order decide "
"whether it must be blended into the output texture."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:25
msgid ""
"The **Z-Buffer algorithm** is what the GPU's render pipeline uses to "
"solve the visibility problem:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:27
msgid ""
"**For each pixel**, it stores the depth of the last fragment that has "
"been blended into this pixel, or a default value (that represents the "
"furthest depth possible)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:28
msgid ""
"Each time a new fragment is produced, its **depth is compared** to this "
"value. If the fragment depth is larger than the currently stored depth, "
"it is **discarded** without being blended. Otherwise, it is blended "
"normally and the stored value is updated to the depth of this new closest"
" fragment."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:30
msgid ""
"As a result, only the fragment with the lowest depth is visible in the "
"resulting image. The depth value for each pixel is stored in a special "
"**texture** called the **Z-buffer**. This is the only memory overhead "
"required by the Z-buffer algorithm, making it a good fit for real time "
"rendering."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:32
msgid "About transparency"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:33
msgid ""
"The fact that only the fragment with the lowest depth is visible is **not"
" guaranteed** when fragments have **opacity values that are neither 0 or "
"1** (and alpha-blending is used). Even worst: the order in which "
"fragments are emitted has an impact on the result (because blending a "
"fragment **A** and then a fragment **B** is different than blending **B**"
" then **A**)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:35
msgid ""
"Long story short: **transparent objects are always a bit tricky** to "
"handle in a Z-buffer pipeline. A simple solution is to limit the number "
"of transparent objects, and dynamically sort them wrt. their distance to "
"the view point. More advanced schemes exist such as [Order-independent "
"transparency](https://en.wikipedia.org/wiki/Order-"
"independent_transparency) techniques."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:38
msgid "Pipeline State"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:41
msgid ""
"Since this Z-Buffer algorithm is a critical step of the 3D rasterization "
"pipeline, it is implemented as a **fixed-function** stage. We configure "
"it through the `pipelineDesc.depthStencil` field, which we had left null "
"so far."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:82
msgid ""
"The first aspect of the Z-Buffer algorithm that we can configure is the "
"**comparison function** that is used to decide whether we should keep a "
"new fragment or not. It defaults to `Always`, which basically deactivate "
"the depth testing (the fragment is always blended)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:84
msgid ""
"**The most common choice** is to set it to `Less` to mean that a fragment"
" is blended only if its depth is **less** than the current value of the "
"Z-Buffer."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:98
msgid ""
"The second option we have is whether or not we want to **update the "
"value** of the Z-Buffer once a fragment passes the test. It can be useful"
" to deactivate this, when rendering user interface elements for instance,"
" or when dealing with transparent objects, but **for a regular use "
"case**, we indeed want to write the new depth each time a fragment is "
"blended."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:104
msgid ""
"Lastly, we must tell the pipeline how the depth values of the Z-Buffer "
"are **encoded** in memory:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:123
msgid ""
"Depth textures **do not use the same formats** as color textures, they "
"have their own set of possible values (all starting with `Depth`). The "
"same texture is used to represent both the depth and the *stencil* value,"
" when enabled, and the total budget is 32 bits per pixel, so it is common"
" to use a depth encoded on 24 bits and leave the last 8 bits to a "
"potential stencil buffer."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:126
msgid ""
"Lastly, **we deactivate the stencil** by telling that it should neither "
"read nor write any of the bytes of the stencil buffer."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:134
msgid "Depth texture"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:137
msgid ""
"We must allocate the texture where the GPU stores the Z-buffer ourselves."
" I'm going to be quick on this part, as **we will come back on textures "
"later on**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:139
msgid ""
"We first create a texture that has the size of our swap chain texture, "
"with a usage of `RenderAttachment` and a format that matches the one "
"declared in `depthStencilState.format`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:173
msgid ""
"We also create a **texture view**, which is what the render pipeline "
"expects. In general a texture view represents a sub-part of a texture, "
"potentially exposed as a different format, but here we have a simple "
"texture and the view mostly represents the whole texture. Only the "
"`aspect` set to `DepthOnly` limits the scope of the view."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:205
msgid ""
"Like buffers, textures must be destroyed after use, and both views and "
"textures must be released:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:225
msgid ""
"Lastly, we need to update the required limits to state the maximum "
"texture size:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:235
msgid "Again, more on textures and texture views later!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:238
msgid "Depth attachment"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:241
msgid ""
"Like when attaching a color target or binding a uniform buffer, we define"
" an object to \"connect\" our depth texture to the render pipeline. This "
"is the `RenderPassDepthStencilAttachment`:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:267
msgid ""
"We must set up clear/store operations for the stencil part as well even "
"if we do not use it:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:315
#: ../../basic-3d-rendering/hello-triangle.md:461
#: ../../basic-3d-rendering/hello-triangle.md:491
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:402
msgid "Dawn"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:316
msgid ""
"When using the Dawn implementation of WebGPU, `stencilLoadOp` and "
"`stencilStoreOp` must be set to respectively `LoadOp::Undefined` and "
"`StoreOp::Undefined` instead."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:318
msgid ""
"Furthermore, a `clearDepth` attribute of `depthStencilAttachment` must be"
" turned to NaN (it's a backward compatibility thing):"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:326
#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:14
#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:14
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:41
#: ../../basic-3d-rendering/texturing/a-first-texture.md:417
msgid "Shader"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:329
msgid ""
"The last thing we need to do is to set up a depth for each fragment, "
"which we can do through the **vertex shader** (and the rasterizer will "
"interpolate it for each fragment):"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:335
msgid ""
"The depth value must be in the range $(0,1)$. We will build a proper way "
"to define it in the next chapter but for now let use simply remap our "
"`position.z` from its range $(-1,1)$ to $(0,1)$:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:344
msgid ""
"We now fixed the depth issue, and setup an important part of the 3D "
"rendering pipeline that we won't have to edit so much."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/depth-buffer.md:349
msgid "The depth ordering issue is gone!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/index.md:1
msgid "3D Meshes"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/index.md:4
#: ../../basic-3d-rendering/index.md:4
#: ../../basic-3d-rendering/input-geometry/index.md:4
#: ../../basic-3d-rendering/lighting-and-material/index.md:4
#: ../../basic-3d-rendering/shader-uniforms/index.md:4
#: ../../basic-3d-rendering/some-interaction/index.md:4
#: ../../basic-3d-rendering/texturing/index.md:4
msgid "Contents"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:1
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:1
#: ../../basic-3d-rendering/texturing/loading-from-file.md:1
#: ../../basic-3d-rendering/texturing/texture-mapping.md:102
msgid "Loading from file"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:5
#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:234
msgid ""
"*Resulting code:* [`step058`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step058)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:9
#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:238
msgid ""
"*Resulting code:* [`step058-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step058-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:12
msgid ""
"This time, we are ready to load **an actual 3D file format** instead of "
"the ad-hoc one we have been using so far, so that you can play with any "
"model you'd like."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:14
msgid ""
"In this chapter we load 3D models from the "
"[OBJ](https://en.wikipedia.org/wiki/Wavefront_.obj_file) format. This is "
"a very common format for storing 3D meshes with extra attributes (vertex "
"colors, normals, but also texture coordinates and any other arbitrary "
"data). You can for instance create an OBJ file by exporting it from "
"[Blender](https://www.blender.org/)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:16
msgid "TinyOBJLoader"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:18
msgid ""
"Instead of manually parsing OBJ files, we use the "
"[TinyOBJLoader](https://github.com/tinyobjloader/tinyobjloader) library. "
"The file format is **not that complex**, but parsing files is not the "
"main point of this tutorial series, and this library has been intensively"
" tested and has a very small footprint."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:20
msgid ""
"Similarly to [our `webgpu.hpp` wrapper](/getting-started/cpp-idioms.md), "
"TinyOBJLoader is made of a single file "
"[`tiny_obj_loader.h`](https://raw.githubusercontent.com/tinyobjloader/tinyobjloader/release/tiny_obj_loader.h)"
" that you may simply save next to your `main.cpp`. Exactly one of your "
"source files must define `TINYOBJLOADER_IMPLEMENTATION` before including "
"it:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:27
msgid "We create a new loading function:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:33
msgid ""
"We can use [the example "
"code](https://github.com/tinyobjloader/tinyobjloader#example-code-"
"deprecated-api) from TinyOBJLoader's README as a base, that shows how to "
"call the `LoadObj` function it provides:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:64
msgid ""
"Once the tinyobj-specific structures are filled in (`shape_t`, "
"`attrib_t`), we can extract our vertex array data, making the code a bit "
"clearer:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:94
msgid ""
"We can generalize to all the parts of the model by iterating over "
"`shapes`:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:108
msgid "Loading a first object"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:110
msgid ""
"We stop using indexed drawing but switch to a vector of "
"`VertexAttributes` rather than a blind vector of `float` for the vertex "
"buffer data:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:162
msgid ""
"One last thing we need is to increase the maximum buffer size to be able "
"to load various meshes:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:169
msgid ""
"Test this with [pyramid.obj](../../data/pyramid.obj), which is the same "
"pyramid but with beveled edges (I also set the `T1 = mat4x4(1.0)` and "
"`focalPoint = vec3(0.0, 0.0, -1.0)`):"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:174
msgid "The 3D model is correctly loaded but not oriented as expected."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:178
msgid ""
"If you see a warning about missing material information when loading the "
"OBJ, do not worry:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:184
msgid ""
"OBJ files may have a companion .mtl file providing information about "
"materials but we do not use this information here."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:187
msgid "Vertical axis convention"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:189
msgid ""
"There is **no consensus** among 3D modeling and 3D rendering tools about "
"which axis should represent the vertical direction. But file formats "
"usually impose a convention. In the case of the OBJ format, it is "
"specified that **the Y axis represents the upward vertical direction**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:191
msgid ""
"Since we have been implicitly following the convention that **Z is the "
"vertical in our code**, we need to either change our convention (by "
"changing the view matrix) or convert upon loading. I chose the latter:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:211
msgid "The loaded 3D model, correctly oriented."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:214
msgid "Another example"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:216
msgid ""
"Want something a bit more interesting? Try "
"[mammoth.obj](../../data/mammoth.obj)! And thank the Smithsonian for "
"[sharing the model](https://sketchfab.com/3d-models/mammuthus-"
"primigenius-blumbach-229976b3db4646b39c44e57a7e3d8744)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:221
msgid "A complex 3D model."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:227
msgid ""
"This chapter concludes this part about loading and rendering 3D meshes. "
"It was quite of a part, congratulations for having followed so far!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:229
msgid ""
"From now on we will see how to improve on top of this base, but feel free"
" to take some time to **play around**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/loading-from-file.md:231
msgid ""
"You can now load your own models (going through Blender to convert them "
"if you get them in a different file format), animate the position of "
"different objects, change the lighting (even animate it using uniforms), "
"etc."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:1
msgid "Projection matrices"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:5
#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:712
msgid ""
"*Resulting code:* [`step055`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step055)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:9
#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:716
msgid ""
"*Resulting code:* [`step055-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step055-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:12
msgid ""
"Now that we are familiar with the concept of matrices, we see how they "
"are used to represent projections, although a **perspective projection** "
"is neither a linear nor an affine transform so it is not exactly what "
"matrices are supposed to represent, mathematically speaking."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:14
msgid ""
"We also present in a second part a **typical way** of managing transform "
"and projection matrices from the C++ code, using the GLM library."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:16
msgid "Orthographic projection"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:19
msgid ""
"What have we been doing so far regarding the projection of the 3D scene "
"onto our 2D screen? The $x$ and $y$ coordinates of the output position "
"`out.position` is mapped to the window coordinates, and the $z$ "
"coordinate does not affect the pixel position of our geometry, so this is"
" **an orthographic projection along the Z axis**:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:25
msgid ""
"Remember that we had to remap the $z$ coordinate to the range $(0,1)$, "
"because anything outside this range is **clipped out**, the same way "
"anything outside the range $(-1,1)$ along the $x$ and $y$ axes falls "
"outside the window."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:41
msgid ""
"We call this the **clipping volume**. Only the geometry that lies inside "
"this volume after the vertex shader can produce **visible fragments**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:44
msgid ""
"The expected range for the output $z$ coordinate differs with the "
"graphics API. All modern APIs (DirectX 12, Metal, Vulkan, WebGPU) use "
"$(0,1)$ but OpenGL and WebGL expect $(-1,1)$. The projection matrices "
"have thus slightly different definitions."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:47
msgid ""
"Of course this orthographic projection can be easily represented as a "
"matrix:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:61
msgid ""
"Note that the coefficients $0.5$ in the matrix above come from the fact "
"that we want to remap Z coordinate from the range $(-1,1)$. In general, "
"if the $z$ coordinates of our model are in range $(n,f)$, we get "
"$z_{\\text{out}} = \\frac{z - n}{f - n} = \\frac{z}{f - n} - \\frac{n}{f "
"- n}$ and so the coefficients become $p_{zz} = \\frac{1}{f - n}$ and "
"$p_{zw} = \\frac{- n}{f - n}$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:63
msgid ""
"We can also change the range of view by dividing the XY size of the scene"
" to fit a larger part of it in the view frustum."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:78
msgid "Perspective projection"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:81
msgid "Focal point"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:83
msgid ""
"A perspective projection is (more or less) the projection that occurs "
"**in an actual camera** or a human eye. Instead of projecting the scene "
"onto a plane, it **projects onto a single point**, called the **focal "
"point**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:85
msgid ""
"The pixels of the screen correspond to different **incoming directions** "
"from which elements of geometry are projected."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:97
msgid ""
"If we want to map the perspective **view frustum** (i.e., the set of "
"visible directions) to the normalized clip space described above, we "
"**need to divide** the XY position by the $z$ coordinate. Let us take an "
"example:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:109
msgid ""
"The points $A$ and $C$ project along the same direction, so they should "
"have the same $y_\\text{out}$ coordinate. At the same time, the points "
"$A$ and $B$ have the same input $y$ coordinate."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:111
msgid ""
"The thing is that they have **different depths**, and as we know "
"**objects that are further away look smaller**. This is modeled by a "
"division by the depth:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:113
msgid ""
"\n"
"y_\\text{out} = \\frac{y}{z}\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:117
msgid ""
"Since $A$ and $B$ have different $z$, they end up at different "
"$y_\\text{out}$ coordinates, which means we see them in slightly "
"different directions (i.e., different pixels in the final image)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:119
msgid "We can try this out:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:151
msgid "Ta-dam, it works!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:153
msgid "Focal length"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:155
msgid ""
"Dividing by the raw $z$ coordinate was a bit arbitrary, and the formula "
"above is a bit suspicious because its terms are **not commensurable**: "
"$y_\\text{out}$ is a **length** (e.g., in meters or feet), but $y / z$ is"
" a **ratio** (unit-less). We can in fact scale the division factor:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:162
msgid "This corresponds to introducing the **focal length** $l$ in the formula:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:164
msgid ""
"\n"
"y_\\text{out} = l\\frac{y}{z}\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:169
msgid ""
"The focal length can be seen as **the distance between the focal point "
"and a virtual sensor** corresponding to the output window (can be "
"verified using Thales's theorem)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:188
msgid ""
"The focal length is a user parameter that corresponds to the **level of "
"zoom** of our virtual camera."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:193
msgid ""
"This lens ranges from focal length 18mm to 55mm, depending on how the "
"zoom ring is turned."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:197
msgid ""
"The projection depends only on **the ratio** between the **sensor size** "
"and the actual **focal length** (it is easy to see that if we multiply by"
" 2 the size of the sensor and move it twice as far from the focal point, "
"we get the same image)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:199
msgid ""
"As a consequence, commercial focal lengths are generally expressed for a "
"given **standard sensor size**, namely 35 mm along its diagonal (a size "
"called \"full frame\")."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:201
msgid ""
"Since our clip space has a width of 2 units (from -1 to 1), if we want "
"the visual look of a commercial 50 mm lens, we need to set our "
"`focalLength` to `2 * 50 / 35 = 2.86`. And actually with the `640/480` "
"ratio the diagonal of our clip space is `2.5` so the `focalLength` ends "
"up being `3.57`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:204
msgid "Perspective matrix"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:206
msgid ""
"Unfortunately, a perspective projection is **not a linear transform**, "
"because of the division by $z$. However, since this division is that "
"commonly used, it is embedded **in the fixed pipeline**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:208
msgid ""
"How didn't we notice it yet? Because for more flexibility it does not "
"divide by `out.position.z` but rather by `out.position.w`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:210
msgid ""
"We want $w$ to be `position.z / focalLength`, so in the projection matrix"
" `P` we set the coefficient $p_{wz}$ to `1.0 / focalLength`, and set the "
"last diagonal coefficient $p_{ww}$ to $0$ instead of $1$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:227
msgid "The $z$ coordinate itself is also divided by $w$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:233
msgid ""
"The projection is the same, but since the $z$ coordinate is also divided "
"by $w$, the depth information is messed up."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:236
msgid ""
"Before addressing this, we can notice that thanks to the hard-coded "
"division, our perspective projection **can be fully encoded as a "
"matrix**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:253
msgid ""
"The coefficients `p_zz` and `p_zw` used to be respectively `1.0 / (far - "
"near)` and `-near / (far - near)` so that $z_\\text{out}$ is in range "
"$(0,1)$. Now we need it to be in range $(0, w_\\text{out}) = (0, "
"\\frac{z_\\text{in}}{l})$ so that after the normalization by "
"$w_\\text{out}$ it ends up in $(0,1)$:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:255
msgid ""
"\n"
"\\left\\{\n"
"\\begin{align}\n"
"p_{zz} & = \\frac{f}{l(f - n)} \\\\\n"
"p_{zw} & = -\\frac{fn}{l(f - n)}\n"
"\\end{align}\n"
"\\right.\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:264
msgid "Proof"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:265
msgid ""
"For $z_\\text{in} = n$, the result is $z_\\text{out} = 0$, and for "
"$z_\\text{in} = f$, the result is $z_\\text{out} = "
"\\frac{z_\\text{in}}{l} = \\frac{f}{l}$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:267
msgid ""
"\n"
"\\left\\{\n"
"\\begin{align}\n"
"n p_{zz} + p_{zw} & = 0 \\quad\\quad (L_1)\\\\\n"
"f p_{zz} + p_{zw} & = \\frac{f}{l} \\quad\\quad (L_2)\n"
"\\end{align}\n"
"\\right.\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:276
msgid "Subtract $L_2 - L_1$ and $f L_1 - n L_2$:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:278
msgid ""
"\n"
"\\left\\{\n"
"\\begin{align}\n"
"f p_{zz} - n p_{zz} & = \\frac{f}{l} \\\\\n"
"f p_{zw} - n p_{zw} & = -\\frac{fn}{l}\n"
"\\end{align}\n"
"\\right.\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:287
msgid "Divide by $f - n$ and this lead to the result above."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:291
msgid ""
"(TODO: explain) This does not work if $n$ is **not null**. We must thus "
"set `near` to a small but non-zero value."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:312
msgid ""
"We are back to what we had with a manual division, only this time it's "
"all matrices!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:315
msgid ""
"Our matrix `P` as defined in the last code block is a **perspective "
"projection matrix**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:317
msgid ""
"The projection matrix is in general globally multiplied by `focalLength` "
"compared to our last formula:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:328
msgid ""
"This does not affect the end result because it also scales the $w$ "
"coordinate. Similarly, multiplying `out.position` by any value does not "
"change the end pixel of the vertex."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:331
msgid ""
"The value `out.position / out.position.w` that is computed by the fixed "
"pipeline is called the ***Normalized** Device Coordinate* (NDC). It is "
"this NDC that must fall within the normalized clipping volume described "
"above."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:335
msgid ""
"Mathematically, considering that two vectors are **equivalent** when they"
" are a multiple of each others (like we do here with `out.position`) "
"defines a [projective "
"space](https://en.wikipedia.org/wiki/Projective_space), namely a space of"
" directions. Its elements are represented by **homogeneous coordinates**,"
" called so to remind one that they are not unique, so they do not form a "
"regular (Euclidean) coordinate system."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:338
msgid "Matrix Uniforms"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:341
msgid "Coordinate systems"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:343
msgid ""
"Instead of building the same matrices for each vertex of each object of "
"the scene, we build them once and store them in a **uniform buffer**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:345
msgid "We can thus extend our uniform structure:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:371
msgid ""
"Remember the **alignment** rules: put the matrices first as they are "
"larger structures."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:374
msgid ""
"This is the occasion to more formally introduce **the typical way of "
"splitting the transform**. We could just store one single matrix $M$ that"
" would encode the whole transform from the input position to the output "
"clip position, but instead we separate it into a product of a **model** "
"matrix, then a **view** matrix, and then the **projection** matrix:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:381
msgid ""
"Changing the **projection** matrix corresponds to changing the virtual "
"camera that captures the scene. It happens rarely (unless we create zoom "
"in/out effects)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:383
msgid ""
"Changing the **view** matrix corresponds to moving and turning the "
"camera. It happens almost all the time, whenever the user interacts with "
"your tool/game usually."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:385
msgid ""
"Changing the **model** matrix corresponds to moving the object with "
"respect to the global scene, which is often called the **world**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:387
msgid ""
"As a consequence, we give a name to the intermediate **coordinate "
"systems** through which the position passes while being transformed:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:389
msgid ""
"`in.position` is the **local** coordinates, or **model coordinates** of "
"the object. It describes the geometry as if the object was alone and "
"centered around the origin."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:390
msgid ""
"`modelMatrix * in.position` gives the **world** coordinates of the "
"points, telling where it is relatively to a global static frame."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:391
msgid ""
"`viewMatrix * modelMatrix * in.position` gives the **camera** "
"coordinates, or **view** coordinates. This is the coordinates of the "
"point as seen from the camera. You can think of it as if instead of "
"moving the eye, we actually move and rotate the whole scene in the "
"opposite direction."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:392
msgid ""
"And finally multiplying by `projectionMatrix` applies the projection, "
"either orthographic or perspective, to give us **clip** coordinates."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:393
msgid ""
"Afterwards, the fixed pipeline divides the clip coordinates by its $w$, "
"which gives the **NDC** (normalized device coordinates)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:396
msgid ""
"In order to alleviate notations I omitted above the fact that we actually"
" use the homogeneous coordinates `vec3f(in.position, 1.0)` as the input "
"of the transform."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:399
msgid "Precomputing"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:401
msgid ""
"For now the content of the matrices is **precomputed on the CPU** and "
"then uploaded, but this could also be done in a compute shader, as we "
"will see in [the compute part](/basic-compute/index.md) of this "
"documentation."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:403
msgid ""
"Make sure to lift the device limit on the uniform buffer size, and define"
" a value for the matrices:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:417
msgid ""
"Remember that we added a `transpose` operation all the time. Make sure to"
" flip the coefficient along the matrices compared to our definitions "
"above."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:420
msgid ""
"ðŸ˜’ Ahem this is a bit annoying, couldn't we rather define this `transpose`"
" operation? What about the matrix multiplication?"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:422
msgid ""
"Yes we could, or we could even reuse what has already been done! Which "
"leads us to the GLM library."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:424
msgid "GLM"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:426
msgid ""
"The [GLM](https://github.com/g-truc/glm) library reproduces the "
"matrix/vector types and operations that are available in shaders, so that"
" we can **easily port code** between C++ and shaders."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:428
msgid ""
"It was originally designed to be as close as possible to the GLSL syntax,"
" which is close in features to WGSL (although type names are slightly "
"different). It is widely used, supported on multiple platforms, "
"battlefield-tested, header-only (so easy to integrate)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:430
msgid "Integration"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:432
msgid ""
"Here is a stripped down version of GLM: "
"[glm.zip](../../data/glm-0.9.9.8-light.zip) (392 KB, as opposed to the "
"5.5 MB of the official release). Unzip this directly into your source "
"tree. You can include it as follows:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:439
msgid ""
"Make sure to add the main source directory to the include path in your "
"`CMakeLists.txt`, as some compiler require it to use the `<...>` brackets"
" in include directives:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:446
msgid "Basic usage"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:448
msgid ""
"Everything GLM defines is contained in the `glm` namespace. You can "
"either use it globally with a `using namespace glm;` or import individual"
" types:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:465
msgid ""
"The `mat4x4` type of GLM corresponds to WGSL's `mat4x4f`. The equivalent "
"of `mat4x4<f64>` is `dmat4x4`, with the prefix `d` for `double`. It also "
"has an alias called `mat4` to correspond to GLSL, which you might like as"
" it is less characters to type. The same goes for vectors (`vec3` is "
"`vec3f`) for integers (`ivec2` is WGLS's `vec2<i32>`), etc."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:468
msgid ""
"It is thus easy to reproduce what we were doing in WGSL. Let's start with"
" the **model** transform:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:503
msgid ""
"Then comes the **view** transform. Do not forget to include the "
"translation of the focal point (which we did not represent as a matrix "
"product above but the conversion is straightforward):"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:531
msgid "And finally the projection:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:547
msgid "The vertex shader simply becomes:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:558
msgid ""
"I am not putting the image again, you should still obtain the same "
"result. Only this time it is **much less energy consuming** since "
"matrices are computed only once, instead of once per vertex and per frame"
" (which can easily count in millions or more in a practical scenario)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:560
msgid "Extensions"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:562
msgid ""
"The construction of **atomic matrices** like translations, rotations, "
"scaling or perspective is something that is very common. Yet it is not "
"part of the built-in functions of WGSL because, as we just saw, we are "
"not supposed to do it in the shader code."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:564
msgid ""
"Since GLM intends to reproduce the types of the shader languages, it does"
" not include those neither. At least not in the `glm/glm.hpp`. But it "
"does in its **extensions**, which we can include like this:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:570
msgid "The construction of the model and view matrices becomes as simple as this:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:583
msgid ""
"Note that transformation functions provided by GLM all take an input "
"matrix to transform, in order to spare us a matrix multiplication. Here "
"we always use the **identity** matrix `mat4x4(1.0)` to build atomic "
"transforms, but the model matrix above could have also been built this "
"way:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:593
msgid ""
"I personally find it harder to read though, because we must apply the "
"operations in reverse."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:596
msgid ""
"The `rotate` function enables one to turn around any axis (the second "
"argument) instead of being limited to the X, Y and Z axes like we did "
"when manually building rotation matrices."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:599
msgid ""
"GLM extensions also provide a procedure for building **projection "
"matrices**, and in particular a perspective projection:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:609
msgid ""
"It has almost the same parameters as we used, except that instead of a "
"**focal length**, it uses a **field of view** argument, a.k.a. **fov**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:612
msgid ""
"There are actually two *hidden* settings that the `perspective` function "
"depends on and which we **must take care of**. Both of these settings are"
" enabled globally by defining preprocessor variables before including "
"GLM:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:620
msgid ""
"The first one is `GLM_FORCE_DEPTH_ZERO_TO_ONE`, which tells GLM that the "
"clip volume's Z range is $(0,1)$. By default, it assumes that it is "
"$(-1,1)$ because this is the convention that was used by OpenGL, which is"
" different from WebGPU."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:622
msgid ""
"The second one is the `GLM_FORCE_LEFT_HANDED` to mean that our view space"
" uses a **left-handed coordinate system**. This is the choice that we "
"have implicitly adopted so far because the clip space is left-handed. "
"Switching to a right-handed system is possible, in which case be aware "
"that the camera looks in the direction -Z of the view space instead of "
"+Z."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:626
msgid ""
"You may also define these settings globally in your `CMakeLists.txt` with"
" `target_compile_definition` in order to ensure that they are consistent "
"across all of your files."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:629
msgid "Back to the field of view: it is directly related to the focal length:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:641
msgid ""
"We can see from this figure that $\\tan\\frac{\\alpha}{2} = "
"\\frac{1}{l}$, which gives us the following **conversion rules** between "
"focal length and field of view:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:643
msgid ""
"\n"
"\\begin{align}\n"
"l & = \\frac{1}{\\tan(\\alpha/2)} = \\cot\\frac{\\alpha}{2} \\\\\n"
"\\alpha & = 2 \\arctan\\frac{1}{l}\n"
"\\end{align}\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:650
msgid ""
"Most probably you will use either fov or focal length and stick to it so "
"there will be no need for conversion! We can still check that our formula"
" gives again the same result:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:658
msgid ""
"The field of view expected by `glm::perspective` must be expressed in "
"**radians**. If you want to set it to $45\\deg$ (which is a common "
"value), you must set `fov = 45 * PI / 180`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:664
msgid "Still looking the same... but we make our code base so much more robust!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:667
msgid "ðŸ˜Ÿ Hey it's no longer turning around for me..."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:669
msgid "You need to update the model matrix in the main loop!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:700
msgid "In this quite mathematical chapter, we have seen fundamental points:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:702
msgid ""
"**Projections** (either orthographic or perspective) can be **encoded as "
"matrices** thanks to the coordinate normalization performed by the fixed "
"pipeline (the division by $w$)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:703
msgid ""
"A **perspective** projection is parameterized either by a **focal "
"length** or a **field of view**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:704
msgid ""
"Transform matrices (mode, view, projection) should be computed once and "
"stored in a **uniform buffer** to avoid unnecessary costly computation."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:705
msgid ""
"The GLM library provides us with all we need to easily compute these "
"matrices on the CPU side."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/projection-matrices.md:708
msgid ""
"The GLM library is focused on vector and matrices up to the 4th "
"dimension. For linear algebra of higher dimensions, I usually turn to the"
" [Eigen](https://eigen.tuxfamily.org) library instead, but we won't need "
"it here."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:1
msgid "Transformation matrices"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:5
#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:423
msgid ""
"*Resulting code:* [`step054`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step054)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:9
#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:427
msgid ""
"*Resulting code:* [`step054-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step054-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:12
msgid ""
"We have been manipulating **transforms** in our shader code at multiple "
"occasions already: offset of the 2D scene, viewport ratio, rotation of "
"the 3D object. This chapter presents **a proper and unified way** of "
"handling these. This will lead us in the next part to the introduction of"
" the **perspective** transform!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:14
msgid ""
"This chapter introduces **mathematical concepts**. But **don't worry** if"
" you do not feel comfortable with math: I try to introduce it as smoothly"
" as possible and to always justify its use. Think of it as a way to "
"**learn math thanks to 3D** and not the other way around!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:16
msgid "A common formalism"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:19
msgid ""
"Let us summarize the **various cases of transforms** that we have "
"encountered in the previous chapters:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:39
msgid ""
"There is **not much difference** between moving the object and moving the"
" viewpoint. The line `position.x += 0.25` can be seen either as **moving "
"the object forward** along the X axis or **moving the viewpoint "
"backwards** along the X axis. But as soon as we have multiple objects "
"and/or light sources, this distinction becomes relevant."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:42
msgid ""
"We can actually unify these transforms under a **common formalism**. "
"First of all, we can see both the object and screen projection as **a "
"scaling plus a translation**:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:59
msgid ""
"What about the **rotation**? We need a bit more than a vector scaling for"
" this, because we **mix multiple axes**. And this is exactly what a "
"**matrix** is for!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:61
msgid "Matrices"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:64
#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:32
msgid "Definition"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:66
msgid ""
"A matrix is a **double entry table** that describes a way to build a new "
"vector by **linearly mixing** the coordinates of an input vector. **Each "
"row** of the matrix lists the mixing coefficients to build one of the "
"output coordinates."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:82
msgid ""
"The $i$-th row describes the $i$-th output coordinate. And on each row, "
"the $j$-th coefficient tells how much of the input's $j$-th coordinate we"
" must mix."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:85
msgid ""
"The term **\"linearly\"** just means that we can only scale and add input"
" coordinates. We cannot for instance multiply $x$ by $y$. In general "
"linear coordinate mixes have the form $\\alpha x + \\beta y + \\gamma z$ "
"where $\\alpha$, $\\beta$ and $\\gamma$ are predefined factors "
"(coefficients of the matrix)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:88
msgid "Scaling matrix"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:90
msgid ""
"Let us see a simple example first: **scaling** a vector consists in "
"applying a diagonal matrix, because the $i$-th coordinate of the scaled "
"vector only depends on the $i$-th coordinate of the input one:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:92
msgid ""
"\n"
"M = \\left(\n"
"\\begin{array}{ccc}\n"
"1.0 & 0 & 0 \\\\\n"
"0 & \\text{ratio} & 0 \\\\\n"
"0 & 0 & 0.5\n"
"\\end{array}\n"
"\\right)\n"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:102
msgid ""
"The application of the transform described by the matrix to a vector is "
"denoted as a **product**: $b = M \\times a$ or just $b = Ma$, and `M * a`"
" in code means \"transform the position $a$ using the matrix $M$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:105
msgid ""
"This choice of notation results from the fact that this operation behaves"
" in many ways **like a multiplication** between two numbers (more details"
" later). But note however that it is **not fully the same**. In "
"particular, we cannot swap the operand and write $x \\times M$ (it is "
"called *non-commutative*)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:123
msgid ""
"WGSL (like GLSL and HLSL) expects the arguments of the `mat3x3f` "
"constructor to be given **column by column**, despite the fact that they "
"**visually appear in rows** in our source code. Instead of always "
"thinking in mirror, which is quite prone to error, I added a `transpose` "
"operation after the creation of the matrix in order to **flip it along "
"its diagonal**. It does not make a difference for a diagonal matrix like "
"this one, but this is very important in general."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:127
msgid ""
"The matrix with 1.0 on the diagonal and 0.0 anywhere else is called the "
"**identity matrix** $I$ and has a very special property: it changes "
"nothing ($Ix = x$ for any vector $x$)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:130
msgid "Rotation matrix"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:132
msgid ""
"For a simple scale, matrices seem a bit overkill, but it becomes "
"interesting when we want to **encode a rotation**:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:156
msgid ""
"Perfect, this matrix-based formalism enable us to **represent both "
"scaling and rotation**!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:158
msgid "Homogeneous coordinates"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:161
msgid ""
"But what about the **translation**? There is **good and bad news**. The "
"bad is that a $3 \\times 3$ matrix **cannot encode a translation**. The "
"good is that a $4 \\times 4$ matrix can!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:163
msgid ""
"Let me explain: the matrix tells how to transform a vector by mixing its "
"coordinate with each others. But it does **not allow to add** anything to"
" the mix that is a **constant** value (i.e., something that does not "
"depend on an input coordinate)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:166
msgid ""
"A matrix represents what is known as a **linear transform**, which also "
"gives its name to the whole field of **linear algebra** by the way. The "
"combination of a linear transform with a translation is called an "
"**affine transform**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:169
msgid ""
"How do we address this? We add **an extra coordinate that is meant to "
"always equal 1**. Adding a constant value $t$ now corresponds to adding "
"$t$ times the 4th coordinate and is thus a \"legal\" mix:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:186
msgid ""
"Mathematically, the code above makes sense: a non-square 3x4 matrix takes"
" an input vector of size 4 and returns an output of size 3. However, "
"**WGSL only supports square matrices** (and so do other shading "
"languages)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:189
msgid ""
"There would anyway be only little use of non-square matrices, because "
"this prevents us from **chaining transforms**. Instead of returning a "
"vector $(x, y, z)$, we would rather return the vector $(x, y, z, 1.0)$ so"
" that we may apply again another transform. This should be easy:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:207
msgid ""
"Notice how the upper-left $3 \\times 3$ quadrant is the **identity "
"matrix**. This part of the $4 \\times 4$ matrix corresponds to the scale "
"and/or rotation (and/or skew)."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:210
msgid ""
"It is important to note that this 4th coordinate is **not just a hack** "
"for storing the translation on top of the linear transform. Everything "
"behaves as if there was a 4th dimension, so all the nice **mathematical "
"properties** about matrices **still hold**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:212
msgid ""
"As long as the last coordinate remains $1.0$, these vectors still "
"represent 3D points. This is called the **_homogeneous coordinate_** of "
"the point, and we'll understand why better when talking about "
"perspective!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:214
msgid "Composition"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:217
msgid ""
"Matrices provide a common way to represent rotation, scaling and "
"translation. But the power of matrices gets even crazier when we start "
"**composing** them!"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:219
msgid "Product"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:221
msgid ""
"For instance if we want to combine a scaling and a translation, we can "
"manually coin a matrix that does both:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:241
msgid ""
"But this can be **tedious** when it comes to mixing rotations for "
"instances. We can instead reuse our previous atomic matrices and combine "
"them together with a **matrix multiplication**:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:267
msgid "There are a few **important** things to note here:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:269
msgid "`M` is `T * S` in **this order**, and this is different from `S * T`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:270
msgid "This product **reads backwards**: we apply `S` **then** `T`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:271
msgid ""
"The matrix-matrix product `T * S` is a matrix obtained by taking each "
"column of `S` and transforming it with `T` as if it was a vector."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:273
msgid "**Why does this work?** We can decompose it:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:282
msgid ""
"We can directly write `c = T * (S * a)`, and the math tells us that we "
"can actually evaluate the products with a different precedence: `c = (T *"
" S) * a`. This is why applying the transform `M = T * S` is equivalent to"
" applying `S` **then** `T`."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:285
msgid ""
"This change from `T * (S * a)` to `(T * S) * a` is called the "
"**associativity**. It is a property that the matrix multiplication shares"
" with the real multiplication, and thus one of the motivations for using "
"the same notation. The matrix multiplication is however not "
"*commutative*."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:289
msgid ""
"In this case applying `T` before `S` would lead to an overall translation"
" of only $0.125$ (half $0.25$) because the translation would be affected "
"by the scaling."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:292
msgid "Rotations"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:294
msgid ""
"Equipped with this new multiplication tool, we can start experimenting "
"with more complex transforms that were hard to define before. A good "
"example is the **combination of 2 rotations along different axes**."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:310
msgid ""
"We can define these two transforms independently as matrices, then simply"
" multiply them together:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:348
msgid ""
"This example would have been quite hard to create manually. Furthermore, "
"we will see that it is very useful to keep the model transform separate "
"from the view angle."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:351
msgid "The formula to directly create the matrix `R2 * R1` is:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:361
msgid ""
"This is really **not an intuitive result**, which shows how helpful it is"
" to see combined transforms as matrix multiplications."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:364
msgid "More advanced example"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:366
msgid ""
"We finish this chapter by a little exercise of matrix combination: could "
"you **guess** how to obtain this following transform?"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:369
msgid "The view angle is that same as in the previous example."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:381
msgid "**Answer** We obtain this by applying in this order:"
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:383
msgid "A scaling of factor $0.3$."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:384
msgid "A translation of $0.5$ along the $x$ axis."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:385
msgid "The animated rotation R1."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:386
msgid "The view angle rotation R2."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:412
msgid ""
"Rotations always occur **around the origin** point (the one of "
"coordinates $(0,0,0)$). To rotate around a different point, combine a "
"rotation with one translation before and one after."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:418
msgid ""
"This was an important chapter, that justifies why **matrices are so "
"useful in the graphics pipeline**, and explains why we manipulate $4 "
"\\times 4$ matrices even if we are only in 3D."
msgstr ""

#: ../../basic-3d-rendering/3d-meshes/transformation-matrices.md:420
msgid ""
"The next chapter is still about matrices, but this time for the final "
"**perspective projection**."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:1
msgid "Hello Triangle"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:5
#: ../../basic-3d-rendering/hello-triangle.md:506
msgid ""
"*Resulting code:* [`step030`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step030)"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:9
#: ../../basic-3d-rendering/hello-triangle.md:510
msgid ""
"*Resulting code:* [`step030-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step030-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:12
msgid "In its overall outline, drawing a triangle is as simple as this:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:32
msgid ""
"What is a bit verbose is the configuration of the **render pipeline**, "
"and the creation of **shaders**. This is done only once when initializing"
" the application."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:34
msgid "Render Pipeline"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:37
msgid ""
"In order to achieve high performance real-time 3D rendering, the GPU "
"processes shapes through a predefined pipeline. The pipeline itself is "
"**always the same** (it is generally burnt into the physical architecture"
" of the hardware), but we can **configure** it in many ways. To do so, "
"WebGPU provides a *Render Pipeline* object."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:40
msgid ""
"If you are familiar with OpenGL, you can see WebGPU's render pipeline as "
"a memorized value for all the stateful functions that configure the "
"rendering pipeline."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:43
msgid ""
"The figure below illustrates the sequence of data processing **stages** "
"executed by the render pipeline. Most of them are **fixed-function** "
"stages, for which we can only customize some variables, but the most "
"powerful ones are the **programmable stages**."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:45
msgid ""
"In these programmable stages, a true program, called a **shader**, is "
"executed in a massively parallel way (across input **vertices**, or "
"across rasterized **fragments**)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:62
msgid ""
"Other graphics APIs provide access to more programmable stages (geometry "
"shader, mesh shader, task shader). These are not part of the Web "
"standard. They might be available in the future as native-only "
"extensions, but in a lot of cases one can use general purpose [compute "
"shaders](../basic-compute/index.md) to mimic their behavior."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:65
msgid "As always, we build a descriptor in order to create the render pipeline:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:84
msgid ""
"We now detail the configuration of the different stages. We start with a "
"very minimal setup where we leave a lot of features unused, they will be "
"introduce progressively in the next chapters."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:86
msgid "Vertex pipeline state"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:88
msgid ""
"Both the **vertex fetch** and **vertex shader** stages are configured "
"through the **vertex state** structure, accessible at "
"`pipelineDesc.vertex`."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:90
msgid ""
"The render pipeline first **fetches vertex attributes** from some "
"buffers. This includes usually at least a position, and might include "
"additional per-vertex information like color, normal, texture coordinate,"
" etc. In this first example, we hard-code the position of the 3 vertices "
"of the triangles in shaders so we do not even need a position buffer."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:97
msgid ""
"Then each vertex is processed by a custom **vertex shader**. A shader is "
"the combination of:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:99
msgid "A **shader module**, which contains the actual code of the shader."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:100
msgid ""
"An **entry point**, which is the name of the function in the shader "
"module that must be called for each vertex. This enables a given shader "
"module to include entry points for multiple render pipeline "
"configurations at the same time. In particular, we use the same module "
"for the vertex and fragment shaders."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:101
msgid ""
"An array of value assignments for the **constants** of the shader. We do "
"not use any for now."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:110
msgid "The `shaderModule` will be defined in [the next section](#shaders)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:112
msgid "Primitive pipeline state"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:114
msgid ""
"The **primitive state** structure found at `pipelineDesc.primitive` "
"configures the **primitive assembly** and **rasterization** stages."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:116
msgid ""
"The **rasterization** is the very heart of the 3D rendering algorithm "
"implemented by a GPU. It transforms a **primitive** (a point, a line or a"
" triangle) into a series of **fragments**, that correspond to the pixels "
"covered by the primitive. It **interpolates** any extra attribute output "
"by the vertex shader, such that each fragment receives a value for all "
"attributes."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:118
msgid ""
"The primitive assembly configuration consists in stating how the array of"
" vertices fetched earlier must be connected to for either a point cloud, "
"a wire frame or a triangle soup. We set it to its default configuration:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:163
msgid ""
"Usually we set the cull mode to `Front` to avoid wasting resources in "
"rendering the inside of objects. But for beginners it can be very "
"frustrating to see nothing on screen for hours only to discover that the "
"triangle was just facing in the wrong direction, so I advise you to set "
"it to `None` when developing."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:166
msgid "Fragment shader"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:168
msgid ""
"Once a primitive have been turned into fragments, the **fragment shader**"
" stage is invoked for each one of them. This shader receives the "
"interpolated values generated by the vertex shader, and must output on "
"its turn the **final color** of the fragment."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:171
msgid ""
"Keep in mind that all these stages are happening in a very parallel and "
"asynchronous environment. When rendering a large mesh, the fragment "
"shader for the first primitives may be invoked before the last primitives"
" have been rasterized."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:174
msgid ""
"The configuration is very similar to the configuration of the vertex "
"shader:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:200
msgid ""
"Note that the fragment stage is optional, so `pipelineDesc.fragment` is a"
" (potentially null) pointer instead of directly holding the fragment "
"state structure."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:202
msgid "Stencil/Depth state"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:204
msgid ""
"The **depth test** is used to discard fragments that are **behind** other"
" fragments associated to the same pixel. Remember that a fragment is the "
"projection of a given primitive on a given pixel, so when primitives "
"overlap each others, multiple fragments are emitted for the same pixel. "
"Fragments have a **depth** information, which is used by the depth test."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:206
msgid ""
"The stencil test is another fragment discarding mechanism, used to hide "
"fragments based on previously rendered primitives. Let's ignore the depth"
" and stencil mechanism for now, we will introduce them in the [Depth "
"buffer](3d-meshes/depth-buffer.md) chapter."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:212
msgid "Blending"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:214
msgid ""
"The blending stage takes each fragment's color and \"paints\" it onto the"
" target color attachment. If the original color in the **destination** "
"pixel is $(r_d, g_d, b_d, a_d)$ and the color of the **source** fragment "
"to paint is $(r_s, g_s, b_s, a_s)$, what should be the final color $(r, "
"g, b, a)$ of the final pixel? This is what the **blend state** specifies."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:216
msgid ""
"We must also specify what **format** (i.e., how to represent the values "
"as zeros and ones) the colors are to be stored in the final attachment."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:252
msgid ""
"The blending equation can be set independently for the rgb channels and "
"the alpha channel, in general, it takes the following form:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:254
msgid ""
"\n"
"rgb = \\texttt{srcFactor} \\times rgb_s ~~[\\texttt{operation}]~~ "
"\\texttt{dstFactor} \\times rgb_d\n"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:258
msgid ""
"The usual **alpha blending** equation is configured as $rgb = a_s \\times"
" rgb_s + (1 - a_s) \\times rgb_d$"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:276
msgid "And similarly for the alpha channel:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:278
msgid ""
"\n"
"a = \\texttt{srcFactor} \\times a_s ~~[\\texttt{operation}]~~ "
"\\texttt{dstFactor} \\times a_d\n"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:282
msgid ""
"For instance we can leave the target alpha untouched: $a = a_d = 0 "
"\\times a_s + 1 \\times a_d$"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:300
msgid "Multi-sampling"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:302
msgid ""
"I said previously that a fragment is the portion of a primitive that is "
"projected onto a specific pixel. Actually, we can split pixels into sub-"
"elements, called **samples**, and the fragment is associated to a sample."
" The value of a pixel is computed by averaging its associated samples."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:304
msgid ""
"This mechanism is called multi-sampling and is used for anti-aliasing, "
"but we'll leave it off for now by setting the number of sample per pixel "
"to 1."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:315
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:245
msgid "Shaders"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:318
msgid ""
"Both the vertex and fragment programmable stages use the same **shader "
"module**, that we must first create. This module is a kind of dynamic "
"library, like a .dll, .so or .dylib file, except that it talks the binary"
" language of your GPU rather than your CPU's."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:320
msgid ""
"Like any compiled program, the shader is first written in a **human-"
"writable programming language**, then compiled into low-level machine "
"code. However, the low-level code is highly hardware-dependent, and often"
" not publicly documented. So the application is distributed with the "
"**source code** of the shaders, which is **compiled on the fly** when "
"initializing the application."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:322
msgid "Shader code"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:324
msgid ""
"The shader language officially used by WebGPU is called "
"[WGSL](https://gpuweb.github.io/gpuweb/wgsl/), namely the *WebGPU Shading"
" Language*. Any implementation of WebGPU must support it, and the "
"JavaScript version of the API only supports WGSL, but the native header "
"`webgpu.h` also offers the possibility to provide shaders written in "
"[SPIR-V](https://www.khronos.org/spir) or "
"[GLSL](https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)) (`wgpu-"
"native` only)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:327
msgid ""
"**SPIR-V** is more of an intermediate representation, a **bytecode**, "
"than something that one would write manually. It is the shader language "
"used by the Vulkan API and a lot of tools exist to **cross-compile** code"
" from other common shader languages (HLSL, GLSL) so it is an interesting "
"choice when one needs to reuse **existing shader code bases**."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:331
msgid ""
"Also note that WGSL has been designed to be a human-editable version of "
"SPIR-V programming model, so **transpilation** from SPIR-V to WGSL is "
"efficient and lossless (use [Naga](https://github.com/gfx-rs/naga) or "
"[Tint](https://dawn.googlesource.com/tint) for this)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:334
msgid ""
"In this documentation we mostly use WGSL. Its syntax may seem a bit "
"unfamiliar if you are used to C/C++ so let us start with a very simple "
"function and its equivalent in C++:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:352
msgid ""
"Notice how the **types** are specified **after** instead of **before** "
"the argument names. The type of `z` is automatically inferred, though we "
"could have forced it using `let z: f32 = ...`. The return type is "
"specified after the arguments, using the arrow `->`."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:355
msgid ""
"The keyword `let` defines a constant, i.e., a variable that cannot be "
"reassigned. A regular variable is defined using the `var` keyword."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:358
msgid "Now here is the shader for our triangle:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:380
msgid ""
"The function names `vs_main` (resp. `fs_main`) must have the very same "
"name as what was specified as `entryPoint` in the vertex (resp. fragment)"
" state."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:383
msgid ""
"Shader languages natively support **vector and matrix types** up to size "
"4. The type `vec2f` is a vector of 2 floats, and an **alias** for the "
"*templated* type `vec2<f32>`. As another example, the type `vec4<u32>` is"
" a vector of 4 unsigned integers and has alias `vec4u`."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:386
msgid ""
"Tokens that start with an `@` are called **attributes** and decorate the "
"object that comes afterward with various information. For instance, "
"`@builtin(vertex_index)` tells that the argument `in_vertex_index`, which"
" could have any name, will be populated by the **built-in** input vertex "
"attribute that is the vertex index. We use it to set the output value of "
"the shader, which is labelled with `@builtin(position)` as something that"
" must be interpreted by the rasterizer as the vertex position."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:388
msgid ""
"For more flexibility, the shader code should be loaded from a file, but "
"for now we simply store it in a multi-line string literal in our "
"`main.cpp`:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:396
msgid "Creation of a shader module"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:398
msgid "The creation of the shader module starts as usual:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:416
msgid ""
"At first glance, this descriptor seems to have only an array of "
"compilation \"hints\" to fill, which we leave empty (and even nothing at "
"all when using Dawn):"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:425
msgid "But this time, we do **not** set `nextInChain` to `nullptr`!"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:427
msgid ""
"The `nextInChain` pointer is the entry point of WebGPU's **extension "
"mechanism**. It is either null, or pointing to a structure of type "
"`WGPUChainedStruct`. This structure is very simple. First it may "
"recursively have a `next` element (again, either null or pointing to some"
" `WGPUChainedStruct`). Second, it has a **struct type** `sType`, which is"
" an enum telling in which struct the chain element can be cast. Each "
"struct whose definition starts with a field `WGPUChainedStruct chain` has"
" an associated SType."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:429
msgid ""
"To create a shader module from WGSL code, we use the "
"`ShaderModuleWGSLDescriptor` SType. A SPIR-V shader can similarly be "
"created using the `WGPUShaderModuleSPIRVDescriptor`."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:431
msgid ""
"The field `shaderCodeDesc.chain` corresponds to the chained struct when "
"cast as a simple `WGPUChainedStruct`, which must be set to the "
"corresponding SType enum value:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:455
msgid "Finally we can setup the actual payload of the shader code descriptor:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:462
msgid ""
"The Dawn implementation of WebGPU does not include the "
"`hints`/`hintCount` in the shader module descriptor."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:465
#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:175
msgid "Pipeline layout"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:467
msgid ""
"One last thing before we can run our code: the shaders might need to "
"**access input and output resources** (buffers and/or textures). These "
"resources are made available to the pipeline by configuring a memory "
"**layout**. Our first example does not use any resource:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:474
msgid ""
"Actually, setting the pipeline layout to `nullptr` does not mean that "
"there is no input/output resources. It rather asks the backend to "
"**figure out the layout** by itself by inspecting the shader (which in "
"this very case is equivalent)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:480
msgid ""
"This chapter introduced the core skeleton for rendering triangle-based "
"shapes on the GPU. For now these are 2D graphics, but once everything "
"will be in place, switching to 3D will be straightforward. We have seen "
"two very important concepts:"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:482
msgid ""
"The **render pipeline**, which is based on the way the hardware actually "
"works, with some parts fixed, for the sake of efficiency, and some parts "
"are programmable."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:483
msgid ""
"The **shaders**, which are the GPU-side programs driving the programmable"
" stages of the pipeline."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:488
msgid "Our first triangle rendered using WebGPU."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:492
msgid ""
"When using Dawn, you may see different colors, because the target surface"
" use a **different color space**. More on this [later on](input-geometry"
"/loading-from-file.md#color-issue)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:495
msgid "What's next?"
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:497
msgid ""
"The key algorithms and techniques of computer graphics used for 3D "
"rendering are for a large part implemented in the shaders code. What we "
"still miss at this point though is ways to **communicate** between the "
"C++ code (CPU) and the shaders (GPU)."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:499
msgid ""
"The next two chapters focus on two ways to **feed input** to this render "
"pipeline: **vertex** attributes, where there is one value per vertex, and"
" **uniforms**, which define variable that are common to all vertices and "
"fragments for a given call."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:501
msgid ""
"We then take a break away from pipeline things with the switch to **3D "
"meshes**, which is in the end less about code and more about math. We "
"also introduce a bit of **interaction** with a basic **camera "
"controller**. We then introduce a 3rd way to provide input resource, "
"namely **textures**, and how to map them onto meshes."
msgstr ""

#: ../../basic-3d-rendering/hello-triangle.md:503
msgid ""
"Storage textures, which are used the other way around, to get data out of"
" the render pipeline, will be presented only in advanced chapters. "
"Instead, the last chapter of this section is fully dedicated to the "
"computer graphics matter of **lighting** and **material modeling**."
msgstr ""

#: ../../basic-3d-rendering/index.md:1
msgid "Basic 3D Rendering"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:1
msgid "A first Vertex Attribute"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:5
#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:388
msgid ""
"*Resulting code:* [`step032`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step032)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:9
#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:392
msgid ""
"*Resulting code:* [`step032-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step032-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:12
msgid ""
"This chapter presents a proper way to feed data as **input to the *vertex"
" shader***."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:17
msgid ""
"Remember that we do **not** control the way the `vs_main` function is "
"invoked, the fixed part of the render pipeline does. However, we can "
"**request** some input data by labeling the argument of the function with"
" **WGSL attributes**."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:19
msgid "Actually we do this already, with the `@builtin(vertex_index)` attribute:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:28
msgid ""
"This means that the argument `in_vertex_index` must be populated by the "
"vertex fetch stage with the index of the current vertex."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:31
msgid ""
"Attributes that are built-in can be found in [the WGSL "
"documentation](https://gpuweb.github.io/gpuweb/wgsl/#builtin-values)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:34
msgid ""
"Instead of using a built-in input, we can create our own. For this we "
"need to:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:36
msgid ""
"Create a **buffer** to store the value of the input for each vertex; this"
" data must be stored on the GPU side of course."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:37
msgid ""
"Tell the render pipeline how to interpret the raw buffer data when "
"fetching an entry for each vertex. This is the vertex buffer **layout**."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:38
msgid "Set vertex buffer in the render pass before the draw call."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:40
msgid "On the shader side, we replace the vertex index argument with a new one:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:49
msgid ""
"The `@location(0)` attribute means that this input variable is described "
"by the vertex attribute in the `pipelineDesc.vertex.buffers` array. The "
"type `vec2f` must comply with what we will declare in the layout. The "
"argument name `in_vertex_position` is up to you, it is only internal to "
"the shader code!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:52
msgid ""
"The term *attribute* is used for two different things. We talk about "
"**WGSL attribute** to mean tokens of the form `@something` in a WGSL "
"code, and about **vertex attribute** to mean an input of the vertex "
"shader."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:55
msgid "The vertex shader becomes really simple in the end:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:63
msgid "Device capabilities"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:66
msgid "ðŸ¤“ Hey what is the maximum number of location attributes?"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:68
msgid ""
"Glad you asked! The number of vertex attributes available for our device "
"may vary if we do not specify anything. We can check it as follows:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:103
msgid ""
"The spirit of the adapter + device abstraction provided by WebGPU is to "
"first check on the adapter that it has the capabilities we need, then we "
"**require** the minimal limits we need during the device creation and if "
"the creation succeeds we are **guarantied** to have the limits we asked "
"for."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:105
msgid ""
"And we get nothing more than required, so that if we forget to update the"
" initial check when using more vertex buffers, the program fails. With "
"this **good practice**, we limit the cases of *\"it worked for me\"* "
"where the program runs correctly on your device but not on somebody "
"else's, which can quickly become a nightmare."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:107
msgid ""
"This initial check is done by specifying a non null `requiredLimits` "
"pointer in the device descriptor:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:171
msgid ""
"Notice how I initialized the required limits object with `= Default` "
"above. This is a syntactic helper provided by the `webgpu.hpp` wrapper "
"for all structs to prevent us from manually setting default values. In "
"this case it sets all limits to 0 to mean that there is no requirement."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:174
msgid "I now get these more secure supported limits:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:181
msgid ""
"I recommend you have a look at all the fields of the `WGPULimits` "
"structure in `webgpu.h` so that you know when to add something to the "
"required limits."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:183
msgid "Vertex Buffer"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:186
msgid "For now we hard-code the value of the vertex buffer in the C++ source:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:206
msgid ""
"The GPU-side vertex buffer is created like any other buffer, as "
"introduced in the previous chapter. The main difference is that we must "
"specify `BufferUsage::Vertex` in its `usage` field."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:237
#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:88
msgid "Vertex Buffer Layout"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:240
msgid ""
"For the *vertex fetch* stage to provide data from the vertex buffer to "
"our vertex shader, we need to add a `VertexBufferLayout` to "
"`pipelineDesc.vertex.buffers`:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:265
msgid ""
"It is important to note that **the same vertex buffer** can contain "
"**multiple vertex attributes**. This is why the `maxVertexAttributes` and"
" `maxVertexBuffers` limits are different concepts. So there is yet "
"another array pointer:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:287
msgid ""
"We can now configure our vertex attribute. The value of `shaderLocation` "
"must be the same than what specifies the WGSL attribute `@location(...)` "
"in the vertex shader. The format `Float32x2` corresponds at the same time"
" to the type `vec2f` in the shader and to the sequence of 2 floats in the"
" vertex buffer data."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:313
msgid ""
"The **stride** is a common concept in buffer manipulation: it designates "
"the number of bytes between two consecutive elements. In our case, the "
"positions are **contiguous** so the stride is equal to the size of a "
"`vec2f`, but this will change when adding more attributes in the same "
"buffer."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:315
msgid ""
"Finally the `stepMode` is set to `Vertex` to mean that each vertex "
"corresponds to a different value from the buffer. The step mode is set to"
" `Instance` when each value is shared by all vertices of the same "
"instance (i.e., copy) of the shape."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:333
msgid "Render Pass"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:336
msgid ""
"The last change we need to apply is to \"connect\" the vertex buffer to "
"the pipeline's vertex buffer layout when encoding the render pass:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:362
msgid ""
"And we get... exactly the same triangle as before. Except now we can very"
" easily add some geometry:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:382
msgid "Triangles rendered using a vertex attribute"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/a-first-vertex-attribute.md:385
msgid ""
"We have seen in this chapter how to use **GPU buffers** to feed data as "
"**input** to the vertex shader, and thus to the whole rasterization "
"pipeline. We will refine this in the next chapter by adding **additional "
"attributes**."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index.md:1
msgid "Input Geometry"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:1
msgid "Index Buffer"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:5
#: ../../basic-3d-rendering/input-geometry/index-buffer.md:193
msgid ""
"*Resulting code:* [`step034`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step034)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:9
#: ../../basic-3d-rendering/input-geometry/index-buffer.md:197
msgid ""
"*Resulting code:* [`step034-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step034-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:12
msgid ""
"The index buffer is used to separate the list of vertex attributes from "
"the actual order in which they are connected. To illustrate its interest,"
" let us draw a square, which is made of 2 triangles."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:24
msgid "Index data"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:27
msgid "A straightforward way of doing this is as follows:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:43
msgid ""
"But as you can see some **data is duplicated**. And this duplication "
"could be much worst on larger shapes with connected triangles."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:45
msgid ""
"A more compact way of expressing the square's geometry is to separate the"
" **position** from the **connectivity**:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:65
msgid ""
"The index data must have type `uint16_t` or `uint32_t`. The former is "
"more compact but limited to $2^{16} = 65 536$ vertices."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:68
msgid ""
"I also keep the interleaved color attribute in this example, my vertex "
"data is:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:80
msgid ""
"Using the index buffer adds an overhead of `6 * sizeof(uint16_t)` = 12 "
"bytes but also saves `2 * 5 * sizeof(float)` = 40 bytes, so even on this "
"very simple example it is worth using."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:83
msgid "Terminology"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:84
msgid ""
"I usually replace the name **vertex** data with **point** data when "
"referring to the de-duplicated attribute buffer. In other terms, "
"`vertex[i] = points[index[i]]`. The name *vertex* is used to mean a "
"**corner** of triangle, i.e. a pair of a point and a triangle that uses "
"it."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:87
msgid "Buffer creation"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:90
msgid ""
"Of course the index data must be stored in a GPU-side buffer. This buffer"
" needs a usage of `BufferUsage::Index`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:117
msgid ""
"A `writeBuffer` operation must copy a number of bytes that is a multiple "
"of 4. To ensure so we can switch `bufferDesc.size` for `(bufferDesc.size "
"+ 3) & ~3`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:120
msgid "Render pass"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:123
msgid ""
"To draw with an index buffer, there are two changes in the render pass "
"encoding:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:125
msgid "Set the active index buffer with `renderPass.setIndexBuffer`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:126
msgid "Replace `draw()` with `drawIndexed()`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:159
msgid "The square is deformed."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:162
msgid "Ratio correction"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:165
msgid ""
"The square we obtained is deformed because its coordinates are expressed "
"**relative to the window's dimensions**. This can be fixed by multiplying"
" one of the coordinates by the ratio of the window $640/480$."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:167
msgid ""
"We could do this either in the initial vertex data vector, but this will "
"require is to update these values whenever the window dimension changes. "
"A more interesting option is to use the **power of the vertex shader**:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:175
msgid ""
"Although basic, this is a first step towards what will be the key use of "
"the vertex shader when introducing **3D transforms**."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:178
msgid ""
"It might feel a little unsatisfying to hard-code the window resolution in"
" the shader like this, but we will quickly see how to make this more "
"flexible thanks to uniforms."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:184
msgid "The expected square"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/index-buffer.md:190
msgid ""
"Using an index buffer is a rather simple concept in the end, and can save"
" a lot of VRAM. Additionally, it corresponds to the way traditional "
"formats usually encode 3D meshes."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:5
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:494
msgid ""
"*Resulting code:* [`step037`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step037)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:9
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:498
msgid ""
"*Resulting code:* [`step037-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step037-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:13
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:502
msgid ""
"*Resulting code:* [`step037-dawn`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step037-dawn)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:16
msgid ""
"Now that we are familiar with the representation of geometric data that "
"the GPU expect, we can load it from a file instead of hard-coding it in "
"the source code. This is the occasion to introduce some basic **resource "
"management** to our project (although this is not specific to WebGPU)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:18
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:487
msgid "File format"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:21
msgid "Example"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:23
msgid ""
"The file format I introduce here is not standard, but it is simple enough"
" to parse. Here is the content of `webgpu.txt`, which I put in a "
"`resources/` directory:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:57
msgid ""
"It is basically the content of the `pointData` and `indexData` defined "
"previously as C++ vectors, introduced by a line of the form `[section "
"name]`. Lines that are empty or starting with a `#` are ignored."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:60
msgid "We can already bump up the maximum buffer size limit:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:67
msgid "Parser"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:69
msgid ""
"I am not going to detail the parser. I believe it is rather simple to "
"understand, and it is not the core topic of this lecture."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:71
msgid ""
"Plus once we'll start using 3D data we will switch to a more standard "
"format anyways."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:138
msgid "Loading resources from disc"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:141
msgid "Basic approach"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:143
msgid ""
"We can replace the definition of the `pointData` and `indexData` vectors "
"by a call to our new `loadGeometry` function."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:156
msgid ""
"A problem we have with this hard-coded relative path is that its "
"interpretation depends on the directory from which you run your "
"executable:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:166
msgid ""
"In the second case, your program tries to open "
"`my_project/build/resources/webgpu.txt`, which does not exist. There are "
"a few options to address this:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:168
msgid ""
"**Option A** Don't care, just call your program from the right directory."
" It could be annoying, and the problem is that IDEs usually run the "
"executable from `build/` or even a subdirectory of `build/`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:169
msgid ""
"**Option B** Use an absolute path. This will only work on your machine, "
"which is quite of a limitation."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:170
msgid ""
"**Option C** Use an absolute path that is automatically generated thanks "
"to CMake. This is what we'll do."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:171
msgid ""
"**Option D** Use a command line argument to tell the program where to "
"find the resource directory. This is an interesting option, which can be "
"used in combination with *Option C*, but requires a bit more work."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:172
msgid ""
"**Option E** Automatically copy the resources in the directory from which"
" your IDE launches the program. This will be a problem once we try to "
"modify resources while the program is running (which is quite handy when "
"writing shaders)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:174
#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:486
msgid "Resource path resolution"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:176
msgid "We will do something like this:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:183
msgid ""
"Except that the `#define RESOURCE_DIR` will be added by CMake rather than"
" being explicitly written in our source code!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:186
msgid ""
"When putting two *string literals* next to each others in a C or C++ "
"source code, like in `loadGeometry(\"resource\" \"/webgpu.txt\"`, ...), "
"they are automatically concatenated. This is precisely meant for our use "
"case to work!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:189
msgid ""
"To define `RESOURCE_DIR` in the `CMakeLists.txt` you can add this after "
"creating the `App` target:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:197
msgid ""
"The expression `${CMAKE_CURRENT_SOURCE_DIR}` is replaced by the content "
"of CMake's variable "
"[`CMAKE_CURRENT_SOURCE_DIR`](https://cmake.org/cmake/help/latest/variable/CMAKE_CURRENT_SOURCE_DIR.html),"
" which is a built-in variable containing the full path to the "
"`CMakeLists.txt` file that you are editing."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:200
msgid ""
"When writing a CMake *function*, the `CMAKE_CURRENT_SOURCE_DIR` variable "
"contains the directory of the `CMakeLists.txt` that is currently calling "
"the function. If you want to refer to the directory of the "
"`CMakeLists.txt` that defines the function, use "
"[`CMAKE_CURRENT_LIST_DIR`](https://cmake.org/cmake/help/latest/variable/CMAKE_CURRENT_LIST_DIR.html)"
" instead."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:203
msgid "Portability"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:205
msgid ""
"ðŸ˜’ Hey but in the end our executable uses an **absolute path**, so we have"
" this **portability issue** when trying to share it, right?"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:207
msgid ""
"Yes indeed, but we can easily add an option to globally change the "
"resource directory when building a release that we want to be able to "
"distribute:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:230
msgid ""
"You can then have 2 different builds of your project in two different "
"directories:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:237
msgid ""
"The first one for comfort of development, the second one for the "
"portability of a release."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:240
msgid ""
"The `CMAKE_BUILD_TYPE` option is a built-in option of CMake that is very "
"commonly used. Set it to `Debug` to compile your program with **debugging"
" symbols* (see [debugging](/appendices/debugging.md)), at the expense of "
"a slower and heavier executable. Set it to `Release` to have a fast and "
"lightweight executable with no debugging safe-guard."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:242
msgid ""
"When using some CMake generators, like the Visual Studio one, this is "
"ignored because the generated solution can switch from Debug to Release "
"mode directly in the IDE instead of asking CMake."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:247
msgid ""
"Now that we have a basic resource path resolution mechanism, I strongly "
"suggest we use to load our shader code, instead of hard-coding it in the "
"C++ source as we have been doing from the beginning. We can even include "
"the whole shader module creation call:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:302
msgid ""
"Move the original content of the shaderSource variable into "
"`resources/shader.wgsl` and replace the module creation step by:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:310
msgid ""
"This way, you **no longer need to rebuild** the application when you only"
" want to change the shader!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:312
msgid "Adjustments"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:323
msgid "If you run the program now you should get something like this:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:328
msgid "Our loaded shape is a bit off, we should move it to better center it!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:331
msgid ""
"So how do we \"move\" the object? Similarly to how we fixed the ratio "
"issue in the previous chapter, we can do it in the **vertex shader**, by "
"adding something to the `x` and `y` coordinates:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:339
msgid ""
"It is important to apply the scene transform **before** the viewport "
"transform (the ratio). We will get back on this more in detail when "
"adding the 3D to 2D projection transform needed for [drawing 3D meshes"
"](/basic-3d-rendering/3d-meshes/index.md)!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:345
msgid "The WebGPU Logo loaded from the file, with wrong colors."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:348
msgid "Color issue"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:350
msgid ""
"You are not just being picky, there is indeed **something wrong** with "
"the colors! Compare to the logo in the left panel, the colors in the "
"window seem lighter, and even have a different tint."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:353
msgid ""
"This behavior depends on your device, so you may actually see correct "
"colors. I recommend you read the following anyways though!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:356
msgid "ðŸ™„ Hum maybe you made a mistake when writing the file you provided."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:358
msgid ""
"Nice try, but nope. To convince you let's take a look at the color of the"
" first 3 lines of the file, which correspond to the biggest triangle:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:364
msgid ""
"These are *red*, *green* and *blue* values expressed in the range $(0,1)$"
" but let's **remap** them to the integer range $[0,255]$ (8-bit per "
"channel) which is what your screen most likely displays (and hence what "
"usual image file format store):"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:370
msgid "Now we can check on a screen capture the color of the big triangle:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:375
msgid ""
"Color picking the big triangle in a screenshot of our windows shows a "
"color of $(0, 160, 205)$."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:378
msgid ""
"Oh oh, it does not match. What is happening? We have a **color space** "
"issue, meaning that we are expressing colors in a given space, but they "
"end up being interpreted differently. This may happen in a lot of "
"contexts, so it is quite useful to be aware of the basics (although color"
" science is a non-trivial matter in general)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:380
msgid "Our problem here comes from the `swapChainFormat`. Let us print it:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:386
msgid ""
"This gives *Swapchain format: 24*. The \"24\" must be compared to the "
"values of the `WGPUTextureFormat` enum in `webgpu.h`. Be aware that "
"values there are expressed in base 16 (number literals start with `0x`), "
"so we are looking for `24 = 1 * 16 + 8 = 0x18`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:389
msgid ""
"To avoid the need to manually handle enum values, I recommend to have a "
"look at "
"[magic_enum](https://github.com/Neargye/magic_enum/blob/master/include/magic_enum.hpp)."
" After you copy this file to your source tree you can simply do the "
"following:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:399
msgid ""
"Thanks to advanced C++ template mechanism, this library is able to output"
" *Swapchain format: WGPUTextureFormat_BGRA8UnormSrgb*!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:403
msgid ""
"Since the Dawn implementation only supports the format `BGRA8Unorm` for "
"the surface, you should directly see correct colors in that case."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:406
msgid "In my setup, the preferred format is `BGRA8UnormSrgb`:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:408
msgid ""
"The `BGRA` part means that colors are encoded with the blue channel "
"first, then the green one, then red and alpha."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:409
msgid ""
"The `8` means that each channel is encoded using 8 bits (256 possible "
"values)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:410
msgid ""
"The `Unorm` part means that it is exposed as an unsigned normalized "
"value, so we manipulate floats (well, fixed-point reals actually, not "
"floating-point) in the range $(0,1)$ even if the underlying "
"representation only uses 8-bits. `Snorm` would be in range $(-1,1)$, "
"`Uint` in integer range $[0,255]$, etc."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:411
msgid ""
"And finally, the `Srgb` part tells that values use the "
"[sRGB](https://en.wikipedia.org/wiki/SRGB) scale."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:413
msgid "The sRGB color space"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:415
msgid ""
"The idea of a color space is to answer the following problem: We have a "
"budget of 256 possible values to represent a color channel, how should "
"these 256 **discrete** values (index $i$) be distributed along the "
"**continuous** range of light intensity $x$?"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:427
msgid ""
"The most intuitive approach, the **linear** one, consists in regularly "
"distributing the 256 indices across the range of intensities. But we may "
"need more precision in some parts of the range and less in others. Also, "
"the **physical response** of your screen is typically not linear! **Even "
"your eyes** don't have a linear response when translating physical "
"stimuli into psychological **perception** (and it depends on the "
"surrounding lighting)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:430
msgid ""
"The sRGB color space has been designed specifically to address the non-"
"linearity of the display. On [CRT](https://en.wikipedia.org/wiki/Cathode-"
"ray_tube) displays, this was in line with the spontaneous response "
"behavior of the physical device. Now we have switched to LCD or OLED "
"display so the physical device has a different behavior, but screen "
"manufacturer artificially reproduce the CRT response curve to ensure "
"backward compatibility."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:434
msgid ""
"The sRGB color space is so much the standard that it is the one used by "
"all common image file formats, like PNG and JPG. As a consequence, when "
"not doing any color conversion, everything we do, including the color "
"picking tool, is in sRGB."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:436
msgid ""
"**However**, WebGPU assumes that the colors output by the fragment shader"
" are linear, so when setting the surface format to `BGRA8UnormSrgb` it "
"performs a *linear to sRGB* conversion. **This is what causes our colors "
"to be wrong!**"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:439
msgid "Gamma correction"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:441
msgid "An easy-fix is to force a non-sRGB texture format:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:447
msgid ""
"But ignoring the preferred format of the target surface may result in "
"performance issues (the driver would need to convert formats all the "
"time). Instead, we will handle the **color space conversion in the "
"fragment shader**. A good approximation of the rRGB conversion is "
"$R_{\\text{linear}} = R_{\\text{sRGB}}^{2.2}$:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:460
msgid "The WebGPU Logo with gamma-corrected colors."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:463
msgid ""
"Perfect! We fixed the problem, and we can even check with the color "
"picker:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:468
msgid ""
"Now color picking shows the right value (almost, our gamma curve is an "
"approximation)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:471
msgid ""
"This conversion from linear to non-linear color scale (or the other way "
"around) is called **gamma correction** or **tone mapping**. Here it was "
"for rather technical consideration, but it is common to add an "
"artistically driven tone mapping operation at the end of a 3D rendering "
"pipeline. And the fragment shader is the right place to do so."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:474
msgid ""
"In general a color space is characterized by a **gamut** and a **gamma**."
" The gamma is this non-linearity of the discrete scale of values, and the"
" gamut is the range of intensities that we want to cover (the vertical "
"axis above, generalized to 3 colors). The gamut is often given by 3 "
"*primaries*."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:478
msgid ""
"There is more generally a lot to get lost about with color spaces, don't "
"try to learn it all at once but I personally find it fascinating!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:484
msgid ""
"Loading geometric data from a file was an apparently simple change, but "
"it was actually a good way to introduce multiple concerns that can easily"
" become a nightmare if we don't pay attention to them:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:488
msgid "Color space and more generally data encoding"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:489
msgid "Transform (ratio, position)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/loading-from-file.md:491
msgid ""
"We are going to come back on these from time to time to refine them. We "
"are now ready to move on to a way to avoid hard-coded values in the "
"shader and add a lot of flexibility, namely **uniforms**."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:1
msgid "Multiple Attributes"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:5
#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:358
msgid ""
"*Resulting code:* [`step033`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step033)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:9
#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:362
msgid ""
"*Resulting code:* [`step033-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step033-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:12
msgid ""
"Vertices can contain more than just a position. A typical example is to "
"**add a color attribute** to each vertex. This will also show us how the "
"rasterizer automatically interpolate vertex attributes across triangles."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:17
msgid ""
"You may have guessed that we can simply add a second argument to the "
"vertex shader entry point `vs_main`, with a different `@location` WGSL "
"attribute:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:26
msgid ""
"This works, but you might prefer when the number of input attribute grows"
" to instead take a single argument whose type is a custom struct labeled "
"with locations:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:44
msgid ""
"ðŸ˜ But I don't need the color in the vertex shader, I want it in the "
"fragment shader, can I do `fn fs_main(@location(1) color: vec3f)`?"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:46
msgid ""
"Nope. The vertex attributes are only provided to the vertex shader. "
"However, **the fragment shader can receive what the vertex shader "
"returns!** This is where the structure-based approach becomes handy:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:82
msgid ""
"There is a limit on the number of components that can be forwarded from "
"vertex to fragment shader. In our case, we ask for 3 (float) components:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:91
msgid ""
"There are different ways of feeding multiple attributes to the vertex "
"fetch stage. The choice usually depends on the way your input data is "
"organized, which varies with the context, so I am going to present two "
"different ways."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:93
msgid "Option A: Interleaved attributes"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:95
msgid ""
"Before anything, do not forget to increase the vertex attribute limit of "
"your device:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:101
msgid ""
"Interleaved attributes means that we put in a single buffer the values "
"for all the attributes of the first vertex, then all values for the "
"second vertex, etc:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:121
msgid ""
"The first thing we can remark is that now the **stride** of our position "
"attribute has changed from `2 * sizeof(float)` to `5 * sizeof(float)`:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:128
msgid "We thus need to update the buffer size and stride limits:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:135
msgid ""
"This stride is the same for both attributes, so it is not a problem that "
"the stride is set at the level of the while buffer layout. The main "
"difference between our two attributes actually is the offset at which "
"they start in the buffer: the color starts after 2 floats."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:137
msgid ""
"We now need to provide 2 elements in the `vertexBufferLayout.attributes` "
"array. So instead of passing the address `&vertexAttrib` of a single "
"entry, we use a `std::vector`:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:179
msgid "Option B: Multiple buffers"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:181
msgid ""
"Another possible data layout is to have two different buffers for the two"
" attributes. Make sure to change the device limit to support this:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:187
msgid "We thus have 2 input vectors:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:215
msgid "This time, the maximum buffer size/stride can be lower:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:223
msgid "Which lead to two GPU buffers:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:260
msgid ""
"This time it is not the `VertexAttribute` struct but the "
"`VertexBufferLayout` that is replaced with a vector:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:326
msgid ""
"And finally we also have 2 calls to `renderPass.setVertexBuffer`. The "
"first argument (`slot`) corresponds to the index of the buffer layout in "
"the `pipelineDesc.vertex.buffers` array."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:350
msgid "Triangles with a color attribute (same result for both options)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/multiple-attributes.md:354
msgid ""
"I changed the background color (`clearValue`) to `Color{ 0.05, 0.05, "
"0.05, 1.0 }` to better appreciate the colors of the triangles."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:1
msgid "Playing with buffers"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:5
#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:335
msgid ""
"*Resulting code:* [`step031`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step031)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:9
#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:339
msgid ""
"*Resulting code:* [`step031-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step031-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:12
msgid ""
"Before feeding vertex data to the render pipeline, we need to get "
"familiar with the notion of **buffer**. A buffer is \"just\" a chunk of "
"memory allocated in the VRAM (the GPU's memory). Think of it as some kind"
" of `new` or `malloc` for the GPU."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:14
msgid ""
"One notable difference is that we must state some hint about our use of "
"this memory upon its creation. For instance, if we are going to use it "
"only to write it from the CPU but never to read it back, we set its "
"`CopyDst` flag on but not the `CopySrc` flag. This not fully agnostic "
"memory management helps the device figure out the best memory layout."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:17
msgid ""
"Note that textures are a special kind of memory (because of the way we "
"usually sample them) that they live in a different kind of object."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:20
msgid "Creating a buffer"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:23
msgid "The overall structure of the buffer creation will surprise no one now:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:49
msgid ""
"A GPU buffer is *mapped* when it is connected to a specific part of the "
"CPU-side RAM. The driver then automatically synchronizes its content, "
"either for reading or for writing. We will not use it here."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:52
msgid ""
"For our little exercise, create a second buffer, called `buffer2`. We "
"will load data in the first buffer, issue a copy command so that the GPU "
"copies data from one to another, then read the destination buffer back."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:54
msgid "Also, don't forget to free your buffers once you no longer use them:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:76
msgid "Note that there are two different operations here:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:78
msgid ""
"**Destroy** frees the GPU memory that was allocated for the buffer, but "
"the buffer object itself, which lives on the driver/backend side, still "
"exists."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:79
msgid ""
"**Release** frees the driver/backend side object (or rather decreases its"
" reference pointer and frees it if nobody else uses it)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:81
msgid "Writing to a buffer"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:84
msgid ""
"Let us simply use the `queue.writeBuffer` function (or the C-style "
"`wgpuQueueWriteBuffer`), to which we give a memory address and size from "
"which data is copied:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:109
msgid ""
"Uploading data from the CPU-side memory (RAM) to the GPU-side memory "
"(VRAM) **takes time**. When the function `writeBuffer()` returns, data "
"transfer may not have finished yet but it is **guaranteed** that:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:111
msgid ""
"You can **free up the memory** from the address you just passed, because "
"the backend maintains its own CPU-side copy of the buffer during "
"transfer."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:113
msgid ""
"Commands that are **submitted in the queue after** the `writeBuffer()` "
"operation will not be executed before the data transfer is finished."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:115
msgid ""
"And don't forget that commands sent through the **command encoder** are "
"only submitted when calling `queue.submit()` with the encoded command "
"buffer returned by `encoder.finish()`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:118
msgid ""
"We can thus submit a buffer-buffer copy operation to the command queue, "
"after having created a command encoder:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:133
msgid ""
"Make sure that command encoding operations are called before "
"`encoder.finish()` or `wgpuCommandEncoderFinish()`!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:136
msgid "Reading from a buffer"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:139
msgid ""
"We cannot just use the command queue to read memory back from the GPU, "
"because this is a \"fire and forget\" queue: functions do not return a "
"value since they are run on a different timeline."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:141
msgid ""
"Instead, we use an **asynchronous operation**, namely `buffer.mapAsync` "
"(or `wgpuBufferMapAsync`). This operation maps the GPU buffer into CPU "
"memory, and then whenever it is ready it executes the callback function "
"it was provided."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:143
msgid ""
"This asynchronicity makes the programming workflow more complicated than "
"synchronous operations, but once again it is important to minimize "
"wasteful processor idling."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:145
msgid "Mapping"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:147
msgid ""
"Let us first change the `usage` of the second buffer by adding the "
"`BufferUsage::MapRead` flag, so that the buffer can be mapped for "
"reading:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:162
msgid ""
"The `BufferUsage::MapRead` flag is not compatible with "
"`BufferUsage::CopySrc` one, so make sure not to have both at the same "
"time."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:165
msgid "We can now call the buffer mapping with a simple callback."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:168
msgid ""
"I intentionally use the C-style procedure for now, it helps understanding"
" what is happening under the hood when using the simpler API provided by "
"the C++ wrapper."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:190
msgid ""
"The function `onBuffer2Mapped` is defined here as a [lambda "
"expression](https://en.cppreference.com/w/cpp/language/lambda) but it "
"could also be a regular function declared before `main()`, provided it "
"has the same signature:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:199
msgid "Asynchronous polling"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:201
msgid ""
"If you run the program at this point, you might be surprised (and "
"disappointed) to see that the callback is **never executed**!"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:203
msgid ""
"This is because there is no hidden process executed by the WebGPU library"
" to check that the async operation is ready. Instead, the backend checks "
"for ongoing async operations only when we call another operation, so we "
"will add in the main loop a simple operation that does nothing."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:205
msgid ""
"Unfortunately, this mechanism has no standard solution, so we write it "
"differently for Dawn and `wgpu-native`:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:246
msgid ""
"Make sure the calls to `buffer.destroy` are issued *after* the main loop,"
" otherwise the callback will be called with status "
"`BufferMapAsyncStatus::DestroyedBeforeCallback`."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:249
msgid ""
"You should now see `Buffer 2 mapped with status 0` (0 being the value of "
"`BufferMapAsyncStatus::Success`) when running your program."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:251
msgid "Mapping context"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:253
msgid ""
"Now, we need to get more than a status when running this callback, we "
"need to access the buffer's content. But the `onBuffer2Mapped` function "
"cannot access the `buffer2` variable so far."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:256
msgid ""
"When using a regular function, it is clear that `buffer2` is not "
"accessible. When using a lambda expression, one could be tempted to add "
"`buffer2` in the **capture list** (the brackets before function "
"arguments). But this **does not work** because capturing lambdas have a "
"different type, that cannot be used as a regular callback. The C++ "
"wrapper fixes this."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:259
msgid ""
"We thus use the `void *userdata` pointer communicated from the original "
"call to `wgpuBufferMapAsync` to the callback, like we did in [the adapter"
" request](../../getting-started/the-adapter.md) or [the device request"
"](../../getting-started/the-device.md):"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:314
msgid ""
"For instance we can just display the content of the buffer and check that"
" it corresponds to our initially fed buffer data:"
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:326
msgid ""
"In such a simple example, we could spare ourselves the need to define a "
"`Context struct` and just pass the address of the `buffer` object as the "
"value of `pUserData` (or even the `buffer` object itself, as it is a "
"pointer already)."
msgstr ""

#: ../../basic-3d-rendering/input-geometry/playing-with-buffers.md:332
msgid ""
"Congratulations! We were able to create a GPU-side memory buffer, upload "
"data into it, copy it remotely (operation triggered from the CPU, but "
"executed on the GPU) using the command queue and download data back from "
"the GPU. We can now use a buffer to specify vertex attributes, in "
"particular vertex positions!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:1
msgid "Cube Maps (ðŸš§WIP)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:5
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:209
msgid ""
"*Resulting code:* [`step117`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step117)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:9
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:213
msgid ""
"*Resulting code:* [`step117-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step117-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:12
msgid ""
"The computation of the `ibl_uv` coordinates at which we sampled the "
"environment lighting in the previous chapter is a bit costly, due to the "
"`acos` and `atan2` operations. A more efficient way to store the "
"environment map is as a **cube map**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:14
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:90
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:95
#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:202
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:26
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:75
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:91
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:107
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:299
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:303
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:358
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:407
#: ../../basic-3d-rendering/lighting-and-material/pbr.md:12
msgid "TODO"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:18
msgid "Cube maps are more efficient to sample and hardware accelerated."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:21
msgid "Multi-layer textures"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:24
msgid ""
"We will see in the [Cubemap Conversion](../../basic-compute/image-"
"processing/cubemap-conversion.md) chapter how to convert an "
"equirectangular environment map into a cubemap and vice versa."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:26
msgid ""
"All we need to know for now is that **a cubemap is a special type of "
"texture**. It is stored as a **2D array texture** with **6 layers**, "
"which means that when creating the texture, with specify a dimension of "
"`2D` but the `size` has 3 dimensions:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:35
msgid ""
"**By convention**, the face of the cube are stored in the following "
"**order**:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "Layer"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "Cube Map Face"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "S"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "T"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "0"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Positive X`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`-Z`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`-Y`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "1"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Negative X`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`+Z`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "2"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Positive Y`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`+X`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "3"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Negative Y`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "4"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Positive Z`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "5"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`Negative Z`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:16
msgid "`-X`"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:46
msgid ""
"As you can see, the convention also specifies the world-space direction "
"to which the local texture axes `S` and `T` correspond."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:62
msgid ""
"In practice, we **load the faces one by one**, from individual files. The"
" computations of **MIP levels** is also done face by face. The texture "
"sampler will take care of mixing faces together appropriately."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:87
msgid ""
"Images appear upside down because the convention was designed by people "
"who use $Y$ as the vertical axis, and in this guide we use $Z$ as the "
"vertical. Anyways even when using $Y$-up it is better to stick to the "
"convention table above than to try to intuitively guess the correct S and"
" T texture axes."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:92
msgid "Implementation"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:97
msgid ""
"Unzip [`autumn_park_4k.zip`](../../data/autumn_park_4k.zip) in your "
"`resource` directory."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/cubemap.md:179
msgid ""
"Note that we also add a new extra argument to `writeMipMaps` to specify "
"which layer to upload to:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:1
msgid "Image-Based Lighting (ðŸš§WIP)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:5
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:124
msgid ""
"*Resulting code:* [`step115`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step115)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:9
#: ../../basic-3d-rendering/lighting-and-material/ibl.md:128
msgid ""
"*Resulting code:* [`step115-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step115-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:15
msgid ""
"An environment map is a 360Â° image in high-dynamic range that we use as "
"an omnidirectional light source."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:20
msgid ""
"For each camera ray (i.e., each pixel) we compute the direction reflected"
" by the surface's normal to sample the part of the environment map that "
"contributes the most to the lighting."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:23
msgid "IBL Sampling"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:28
msgid ""
"Add the environment map "
"[`autumn_park_4k.jpg`](../../data/autumn_park_4k.jpg) to the list of "
"loaded textures:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:36
msgid ""
"You can find plenty more examples of environment maps on "
"[PolyHaven](https://polyhaven.com/hdris) and "
"[ambientCG](https://ambientcg.com/list?type=HDRI). These are CC0 "
"licensed, allowing you to use them in any context!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:39
msgid ""
"We test on a simpler model than the boat: "
"[`suzanne.obj`](../../data/suzanne.obj)."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:78
msgid "IBL Prefiltering"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:81
msgid ""
"We can give more roughness to the object by sampling a different MIP "
"level:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:94
msgid ""
"In fact, instead of letting the GPU guess which MIP level we want as done"
" for a regular texture, we specify manually the level we want depending "
"on the desired roughness of each surface element."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:96
msgid "For instance we can create alternating rough and glossy stripes:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:113
msgid "Our approach so far has 3 problems:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:115
msgid ""
"By manually setting the MIP level, we lose the \"smart\" choice that the "
"GPU is doing based on screen-space gradients to avoid aliasing. To get "
"both manual control and this behavior, we can use  `textureSampleBias`."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:117
msgid ""
"The MIP levels are generated as if the texture represented a signal "
"regularly sampled along a grid, but the environment map is sampled along "
"directions, which induces distortion that the mip generation should take "
"into account."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:119
msgid ""
"To be able to represent at the same time the sun and color details in "
"indirectly lit areas, the environment texture usually uses **high-dynamic"
" range** (HDR) image formats like .hdr or .exr."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/ibl.md:121
msgid ""
"We see in the next chapter a more efficient way to sample the environment"
" with a special type of textures, namely **cube maps**. In the [HDR "
"Textures](../../advanced-techniques/hdr-textures.md) chapter we will see "
"how to load HDR textures."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/index.md:1
msgid "Lighting and Material"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:1
msgid "Normal mapping (ðŸš§WIP)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:5
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:466
msgid ""
"*Resulting code:* [`step110`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step110)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:9
#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:470
msgid ""
"*Resulting code:* [`step110-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step110-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:12
msgid "ðŸš§ WIP"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:13
msgid ""
"From this chapter on, the guide is not as up to date. I am currently "
"refreshing it chapter by chapter and this is where I am currently "
"working!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:16
msgid ""
"We have seen that the **normal** of a surface (i.e., the direction "
"perpendicular to it) plays a key role in the way the light bounces on it."
" **Normal mapping** consists in locally perturbing this normal depending "
"on an input map (texture file) to **model the effect of very small "
"geometric details**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:19
msgid ""
"These **micro details** could in theory be represented by subdividing the"
" mesh a lot and slightly moving some vertices, but for the scale that "
"normal maps model, this approach is really not tractable."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:36
msgid "Normal map"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:39
msgid "There are different ways to provide the perturbed normals:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:41
msgid ""
"Specify a perturbed normal **at each vertex**, and interpolate across the"
" face. This is used to **smooth out** the boundaries between faces and "
"thus create smooth surfaces, and we already have this."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:43
msgid ""
"Provide a **texture** that gives the perturbed normal. This is heavier "
"but can bring a lot more details. This texture is called the **normal "
"map**, and is what this chapter is about!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:45
msgid ""
"In a normal map, **the color of each vertex represents a little vector** "
"of length 1. Values of red, green and blue are interpreted as components "
"X, Y and Z and **encode values in range $(-1, 1)$**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:47
msgid ""
"The very meaning of these X, Y and Z axes depends on the **convention**; "
"what matters is to be consistent between your files and your shader code:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:64
msgid ""
"The conventions \"DirectX\" and \"OpenGL\" are no longer constraints from"
" the graphics API because we will write ourselves in the shader how "
"normal map pixels must be interpreted. These names comes from before we "
"could write shaders."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:66
msgid "For the rest of this document, **we will follow the OpenGL convention.**"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:69
msgid "In practice in order to use such a normal map, we need to:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:71
msgid "**Load** the file as a texture and bind it to the shader."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:72
msgid "**Sample** the texel and decode it into a normal vector"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:73
msgid "**Transform** this normal with respect to the orientation of the face"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:75
msgid "On a plane"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:78
msgid ""
"Let us first focus on steps 1. **Load** and 2. **Sample** by using a "
"simple plane (so that there is no need for step 3. **Transform** for "
"now)."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:80
msgid "Loading the normal map"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:82
msgid "Switch the loaded object to the [`plane.obj`](../../data/plane.obj) mesh:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:88
msgid ""
"For this example we use the `cobblestone_floor_08` material from "
"[PolyHaven](https://polyhaven.com/a/cobblestone_floor_08) (a nice source "
"of materials that can be freely used by the way). We only look at the "
"[diffuse](../../images/cobblestone_floor_08_diff_2k.jpg) and "
"[normal](../../images/cobblestone_floor_08_nor_gl_2k.png) maps for now, "
"and load them as textures."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:90
msgid ""
"Since we have more than one texture, we add attributes to our "
"`Application` class:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:118
msgid ""
"We can now update `initTexture()` (which I rename `initTextures()` then),"
" as well as `terminateTextures()`:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:126
msgid ""
"We add this new texture to our bindings, both on the C++ side and the "
"shader side (I chose to insert it next to the base color one):"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:139
msgid "Update `initBindGroup()` and `initBindGroupLayout()` accordingly."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:199
msgid "Lastly, this new texture requires to update our device limits:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:206
msgid ""
"Increase the specular hardness and play with the view point so that you "
"can highlight the problem with this texture:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:211
msgid ""
"Without normal mapping, the cobblestone texture feels completely flat, "
"which is odd for this material."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:214
msgid "Sampling normals"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:216
msgid ""
"The key moment where normal mapping intervenes is when evaluating the "
"normal `N` in the **fragment shader**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:222
msgid ""
"Instead of using the input normal, we sample the normal from the normal "
"map:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:230
msgid ""
"For each channel $r$, $g$ and $b$, the sampled value lies in range "
"$(0,1)$, and we need to map it to range $(-x,x)$ to **decode** it. The "
"value of $x$ does not really matter since we then normalize the vector."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:233
msgid ""
"If you are using the **DirectX** convention, you also need to **flip** "
"the $Y$ value (multiply by -1 after decoding)."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:239
msgid ""
"With normal mapping, the cobblestone material looks like it has a much "
"more realistic relief."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:242
msgid ""
"Normal mapping is **a powerful trick**, but of course it is not fully "
"equivalent to refining geometry. In particular, it **cannot change the "
"silhouette** of the shape, so the illusion fails at grazing angles:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:247
msgid ""
"At **grazing angles**, the normal mapping is not enough to give the "
"feeling of relief to the material. More complex methods like **relief "
"mapping** are needed here."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:251
msgid ""
"If you want to dim down the influence of the normal map, you can mix it "
"with the original normal:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:259
msgid "On a mesh"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:262
msgid "The problem"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:264
msgid ""
"The orientation contained in the normal map is given **relatively** to "
"the global normal of the face."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:266
msgid ""
"In the case of the plane, we could completely ignore the original normal "
"`in.normal` because it matched the Z axis of the normal map. But for any "
"non-horizontal face, we need to **rotate the sampled normal**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:268
msgid ""
"You can for instance test with this "
"[`cylinder.obj`](../../data/cylinder.obj) model:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:273
msgid ""
"Wrong normals: When sampling normals from texture (right), the overall "
"lighting is off and very different from the effect of the input normal "
"(left)."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:276
msgid "The problem becomes even clearer when we display the computed normals:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:286
msgid ""
"Wrong normals: The direction sampled from the normal map (right) should "
"be rotated to be centered around the original surface normal (left)."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:289
msgid "Local frame"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:291
msgid ""
"To fix this, we need to properly define the **local frame** (i.e., a "
"local $X$, $Y$ and $Z$ axes) in which normal maps expresses normal "
"perturbations."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:293
msgid ""
"Our key requirement for the rotation is that when the sampled normal is "
"$(0,0,1)$, it should mean \"no perturbation\". In other words, the end "
"normal vector $N$ must corresponds to `in.normal` in that case."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:295
msgid ""
"We thus know what the $Z$ axis of the normal space is, but still need to "
"define a $X$ and a $Y$ to fully get a rotation. These axes are called "
"respectively **tangent** and **bitangent** directions."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:297
msgid "Tangents and bitangents"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:301
msgid "Vertex attributes"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:305
msgid "We add vertex attributes:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:349
msgid "Don't forget to bump up the limits:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:356
msgid "Computation"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:360
msgid ""
"We compute these tangent and bitangent vectors when loading the mesh, in "
"a new `computeTextureFrameAttributes` private method of the "
"`ResourceManager`:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:375
msgid ""
"The exact procedure is once again a matter of **convention**, to be "
"aligned to what authoring tools export."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:405
#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:352
#: ../../basic-3d-rendering/some-interaction/simple-gui.md:76
msgid "Usage"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:417
msgid "In the vertex shader:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:425
msgid "In the fragment shader:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:443
msgid "Fixed normal maps."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:446
msgid ""
"You can try with the fourareen boat using "
"[`fourareen2K_normals.png`](../../data/fourareen2K_normals.png):"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:451
msgid "The Fourareen boat with normal mapping."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:454
msgid "(TODO: investigate why we still see some cracks and fireflies)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:459
msgid "To recap when normal mapping is about:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:461
msgid ""
"We **perturbate** normals to **emulate micro details** without paying the"
" cost of finer meshes."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:462
msgid "We **sample** this perturbation from a **normal map**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/normal-mapping.md:463
msgid ""
"We need to **combine** this perturbation with the original normal by "
"rotating the sampled value."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:1
msgid "Physically-Based Materials (ðŸš§WIP)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:5
#: ../../basic-3d-rendering/lighting-and-material/pbr.md:72
msgid ""
"*Resulting code:* [`step125`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step125)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:9
#: ../../basic-3d-rendering/lighting-and-material/pbr.md:76
msgid ""
"*Resulting code:* [`step125-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step125-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:14
msgid ""
"The diffuse + specular material model that we have seen so far is an "
"important for step for educational purpose, but it lacks proper physical "
"ground."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:16
msgid ""
"There are two main categories of materials, which corresponds to two very"
" different ways that the light has to bounce on a surface:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:18
msgid ""
"**Metallic** objects conduct electro-magnetic waves and are thus are "
"basically **mirrors**: at the microscopic level the light really bounces "
"on them and leaves along the reflected direction."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:20
msgid ""
"**Dielectric** objects are literally the opposite: they **absorb** the "
"electro-magnetic waves' energy in a thin layer underneath their surface, "
"only to re-emit it in all directions, making them mostly diffuse. The "
"specular part of their shading comes from a part of the light that never "
"gets absorbed due to Snell's law."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:22
msgid "Some rules of thumb that derive from this:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:23
msgid "Metallic surfaces do not have any sort of diffuse lighting."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:24
msgid "Specular highlights on dielectric surfaces cannot be colored."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:25
msgid "Dielectric surfaces only have specular highlights at grazing angles."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:26
msgid "A surface is either metallic or dielectric, there is no in-between."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:28
msgid ""
"It results that we typically use the following parameters to describe a "
"material:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:30
msgid "`metallic`: 1.0 for a metallic surface, 0.0 for a dielectric one."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:31
msgid ""
"`baseColor`: For a dielectric object, this is the diffuse color; for a "
"metallic object, this is the specular color."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:32
msgid ""
"`reflectance`: For dielectrics only, we need to specify the strength of "
"the (non-colored) specular contribution."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:34
msgid ""
"There is no need for two different color maps since a surface is never "
"metallic and dielectric at the same time."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:36
msgid "We also have some geometric information:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:38
msgid ""
"`normal`: Of course you remember a previous chapter where we indicate the"
" local normal."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:39
msgid ""
"`roughness`: This expresses the standard deviation of micro-normals "
"around the mean one (given by the normal map). This goes on a scale from "
"0.0 to 1.0 that is more intuitive to manipulate than the specular's "
"\"hardness\" used previously."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:41
msgid ""
"The normal and roughness information are a statistical representation of "
"the \"Normal Distribution Function\" (NDF), i.e., the probability law "
"telling how microscopic facets are oriented within a texel."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:43
msgid "Test bench"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:46
msgid "We will focus our tests by using a simple sphere."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:51
msgid ""
"The same dielectric object with a roughness varrying from $0.41$ to "
"$0.79$."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:57
msgid "The same metallic object with a roughness varrying from $0.15$ to $0.83$."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:63
msgid ""
"Row 1: Varying from rough to glossy on a dielectric material. Row 2: "
"Varying from dielectric to metallic (one should not use in-between "
"though). Row 3: Varying from rough to glossy on a metallic material."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/pbr.md:69
msgid ""
"I recommend reading the [design "
"document](https://google.github.io/filament/Filament.html) from the "
"Filament render engine, which gives very insightful and ready-to-use "
"information."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:1
msgid "Specularity"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:5
#: ../../basic-3d-rendering/lighting-and-material/specular.md:308
msgid ""
"*Resulting code:* [`step105`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step105)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:9
#: ../../basic-3d-rendering/lighting-and-material/specular.md:312
msgid ""
"*Resulting code:* [`step105-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step105-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:12
#, python-format
msgid ""
"A first thing that our material model lacks is **specular highlight**. "
"This is a visual effect that can be seen on any shiny object, namely any "
"object that is not 100% rough:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:17
msgid "The white highlights on the pawn are a typical specular effect."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:20
msgid ""
"A key difference between diffuse and specular lighting, is that the "
"latter **depends on the view point**!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:22
msgid ""
"Look around, locate any glossy/reflective object, and move your head. You"
" should notice that the specular highlights move as well, while **neither"
" the object nor the light source changed**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:24
msgid ""
"Physically, this is due to the fact that a single point on a surface "
"emits **a different light intensity in different directions**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:40
msgid "Phong model"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:43
msgid ""
"In theory, any surface element reflects to some extent the light that it "
"received from all the directions. But when doing real time rendering, we "
"cannot afford to compute this exactly, we need an **approximation model**"
" that can be efficiently computed."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:45
msgid ""
"The [Phong model](https://en.wikipedia.org/wiki/Phong_reflection_model) "
"considers only the light coming from the direction of the light (it does "
"not account for inter-object reflection). It is one of the oldest "
"reflection models but it is still a good start."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:47
msgid ""
"What we have used so far is called the `diffuse` term, which does not "
"depend on the view point. We now add a `specular` term:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:57
msgid ""
"The Phong model also includes an ambient term that is a constant value "
"coming from the environment. We ignore it because we will soon replace "
"the Phong model altogether to a more physically accurate model."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:60
msgid ""
"In the remainder of this chapter, we focus on the `specular` term, so we "
"set the `diffuse` part to 0."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:62
msgid "Reflected direction"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:64
msgid ""
"We start from an extreme case: **if the surface is a perfect mirror** "
"then the impact of a light source located in direction $L$ is only "
"visible on the surface when looking from the **reflected direction** $R$ "
"(see figure below). And the surface appear black from everywhere else!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:80
msgid ""
"This reflected direction is the **symmetric of the light direction** $L$ "
"with respect to the normal $N$. Since this is a very common operation, it"
" is natively supported by WGSL (and other shading languages):"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:89
msgid ""
"The `reflect` function assumes that the direction we give is the "
"direction coming **from** the light, but for the rest of the code we "
"define *L* as being the direction **towards** the light."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:92
msgid ""
"For a perfect mirror, we would have something like `specular = (R == V)`,"
" but this is never perfectly equal, and **nothing is a perfect mirror "
"anyways**. Instead we use the angle between the view direction V and the "
"reflected direction R, or rather its cosine because it is easier to "
"compute:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:103
msgid "View direction"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:105
msgid "ðŸ¤” How do I get the direction $V$ exactly?"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:107
msgid ""
"It's not obvious indeed. First of all, we are going to compute it in the "
"**vertex shader** and let the rasterizer interpolate it for each "
"fragment:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:123
msgid ""
"As usual, when adding more values transiting from the vertex to the "
"fragment shader, we need to update the following limit to the new size of"
" `VertexOutput` in the shader:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:131
msgid ""
"We normalize `V` **in the fragment shader** because even if all "
"`out.viewDirection` are normalized, their interpolation after the "
"rasterization is in general no longer perfectly normalized."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:134
msgid ""
"So how do we compute the `viewDirection` in the vertex exactly? We can "
"split the line that populates `out.position` in order to get the **world "
"space coordinates** of the current vertex, prior to projecting it:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:146
msgid ""
"We are working in **world space coordinates** because this is the space "
"in which we express our light directions. We could do differently and "
"manipulate only values in camera space for instance, what matters is to "
"**be consistent**."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:149
msgid ""
"The information of camera position is somehow contained in the "
"`viewMatrix`, but extracting it requires to compute a matrix inverse, "
"which is costly. It is thus not advised to perform this in the shader: "
"computing it for each vertex is **wasteful** since it is the same for all"
" vertices."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:152
msgid ""
"When doing GPU programming, it may happen that re-computing multiple "
"times the same quantity is more efficient than storing it in memory: some"
" pipelines are indeed **memory bound**, meaning that the GPU spends more "
"time waiting for memory accesses than for computation. See the "
"[Debugging](../../appendices/debugging.md) chapter for more details."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:155
msgid ""
"In our case it is clearly better to provide the camera position as a "
"uniform:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:172
msgid ""
"Keep in mind to sort fields from the largest one to the smallest one "
"(matrices first, floats at the end), and **also add this in the C++ "
"counterpart** of this struct."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:174
msgid ""
"Now every time we update the view matrix, we can also update this new "
"uniform field:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:209
msgid ""
"Alternatively, you can do the whole shading in **view space**. The camera"
" position in view space is always `vec3f(0.0)` and all you need to do is "
"to transform the light direction like we did for the vertex normal, "
"except using the view matrix:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:216
msgid "Phong specular"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:218
msgid ""
"Now that we can compute `R` and `V`, let us test to set `shading += "
"specular;` (ignore the diffuse term) in the loop over light sources in "
"the shader:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:229
msgid ""
"Using a hard threshold (0.99) on the cosine angle is a bit too strong. A "
"nicer model consists in applying a `pow` to the cosine in order to "
"**remap** it to something that is still condensed around 1.0 but "
"decreases more smoothly when we get away."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:231
msgid ""
"The larger the power exponent, the closest we are from the behavior of a "
"glossy mirror. The Phong model thus calls this power **hardness**:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:249
msgid ""
"The hardness parameter controls the extent of the specular highlight: the"
" higher it is the smallest the highlight."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:260
msgid "Consolidating"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:263
msgid ""
"We can now put back together the diffuse and specular contributions of "
"the lighting. We can slightly reorganize the code so that **only the "
"diffuse term** is multiplied by the base color. This is because for non-"
"metals, specular highlights are always white (we'll refine this in the "
"chapter about [physically-based materials](pbr.md)). We also add "
"constants to balance the diffuse and specular effects:"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:288
msgid ""
"The constants `kd` and `ks` are properties of the material telling "
"whether it is more or less glossy. I suggest you expose these in the GUI "
"so that you can play with them!"
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:299
msgid "The material properties exposed in the Lighting GUI."
msgstr ""

#: ../../basic-3d-rendering/lighting-and-material/specular.md:305
msgid ""
"We have acquired in this chapter a **good intuition** of how to model the"
" specular highlight of material. The next chapters refine this by first "
"modifying the **local normal** against which the light bounces and second"
" by introducing a more **physically grounded** model of materials."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:1
msgid "A first uniform"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:5
#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:402
msgid ""
"*Resulting code:* [`step039`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step039)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:9
#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:406
msgid ""
"*Resulting code:* [`step039-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step039-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:12
msgid "Introduction"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:15
msgid "Motivation"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:17
msgid "If we look at our current shader, we see some hard-coded constants:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:24
msgid ""
"This is not very satisfying, what happens when we want to move the object"
" during the execution of the application? Or change the ratio because the"
" user resized the window?"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:26
msgid ""
"â˜ï¸ We could dynamically change the shader code and rebuild a new shader "
"module!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:28
msgid ""
"It would work, but **building a shader module takes time**. A lot of time"
" if we compare it to the budget for rendering a single frame (typically a"
" 60th of a second). Imagine we want to **animate** our scene and thus "
"change the `offset` at each frame!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:30
msgid "This is why a proper solution is to use a **uniform variable**."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:34
msgid ""
"A uniform is a global variable in a shader whose value is loaded from a "
"GPU buffer. We say that it is **bound** to the buffer."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:36
msgid ""
"Its value is **uniform** across the different vertices and fragment of "
"**a given call** to `draw`, but it change from one call to another one by"
" **updating** the value of the buffer it is *bound* to."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:38
msgid "To use a uniform, we need to:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:40
msgid "Declare the uniform in the *shader*."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:41
msgid "Create the *buffer* it is bound to."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:42
msgid "Configure the properties of the *binding* (a.k.a. the binding's *layout*)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:43
msgid "Create a *bind group*."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:45
#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:60
msgid "Device limits"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:47
msgid ""
"In this chapter, we will require the following limits to be set up for "
"our device:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:58
#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:26
msgid "Shader side"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:61
msgid ""
"In order to animate our scene, we create a uniform called `uTime` that we"
" update at each frame with the current time, expressed in second (as "
"provided by `glfwGetTime()`)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:64
msgid ""
"I usually prefix uniform variables with a 'u' so that it is easy to "
"figure out when reading a long shader when a variable is a uniform rather"
" than a local variable."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:67
msgid ""
"As I said, a uniform is a global variable, so we can declare it in the "
"first line of our shader. A simple variable declaration in WGSL looks as "
"follows:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:74
msgid ""
"The `var` keyword can be labeled with an **address space**, which "
"controls how the variable is stored in the GPU (see [Memory "
"Model](/appendices/memory-model.md)). Here we state that the variable is "
"stored in the *uniform* address space:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:81
msgid ""
"Now we need to tell to which **buffer** the uniform is **bound**. This is"
" done by specifying a **binding index** with the `@binding(...)` WGSL "
"attribute."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:88
msgid ""
"We will then define in the C++ code which buffer is attached to the "
"binding #0. And actually, bindings are organized in **bind groups**, so "
"the binding of a uniform is specified by also providing an `@group(...)` "
"attribute:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:95
msgid ""
"We are now done with the declaration of the uniform variable, we can use "
"it like any other variable in our shader:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:109
msgid ""
"If you are not familiar with the [trigonometric "
"functions](https://en.wikipedia.org/wiki/Trigonometric_functions) like "
"`cos` and `sin`, be aware that the position $(\\cos(a), \\sin(a))$ is the"
" point on the circle of radius $1$ at angle $a$ (expressed in radians). "
"Thus, this formula makes the triangle move along a circle over time. It "
"is multiplied by $0.3$ in order to decrease the radius of this circle."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:112
msgid "Uniform buffer"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:115
msgid ""
"The uniform buffer is created like any other buffer, except we must "
"specify `BufferUsage::Uniform` in its `usage` field. We only need it to "
"contain 1 float for now."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:150
msgid "Then use `Queue::writeBuffer` to upload a value:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:166
msgid "Binding configuration"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:169
msgid ""
"There are two steps in the actual connection of the buffer to the "
"uniform. One is to **declare in the pipeline** that we want a binding, "
"and how exactly. This is the binding layout. And the second one is to "
"create the bind group and enable it (see next section)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:172
msgid ""
"This follows the same spirit than the distinction between the *vertex "
"buffer* and the *vertex buffer layout*."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:177
msgid ""
"The binding layout is specified through the `PipelineLayout` part of the "
"pipeline descriptor. The pipeline layout describes how all the "
"**resources** used by the render pipeline must be bound. A resource is "
"either a texture or a buffer, and its layout specifies to which index it "
"is bound to and properties like whether it is accessed as read-only or "
"write-only, etc."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:179
msgid ""
"A pipeline layout contains multiple **bind groups**, and a bind group "
"contains multiple **bindings**:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:219
#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:72
#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:174
#: ../../basic-3d-rendering/texturing/a-first-texture.md:255
msgid "Binding layout"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:221
msgid ""
"The `BindGroupLayoutEntry` could have been called `BindingLayout` imho. "
"The first setting is the binding index, as used in the shader's "
"`@binding` attribute. Then the `visibility` field tells which stage "
"requires access to this resource, so that it is not needlessly provided "
"to all stages."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:273
msgid ""
"The remaining of the binding layout depends on the type of resource. We "
"fill either the `buffer` field or the `sampler` and `texture` fields or "
"the `storageTexture` field. In our case it is a buffer:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:290
msgid ""
"Notice how I initialized the binding layout object with `= Default` "
"above. It is important because it sets in particular the `buffer`, "
"`sampler`, `texture` and `storageTexture` uses to `Undefined` so that "
"only the resource type we set up is used."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:293
msgid "Bind group"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:296
msgid "Creation"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:298
msgid ""
"A bind group contains the actual bindings. The structure of a bind group "
"mirrors the bind group layout prescribed in the render pipeline and "
"actually connects it to resources. This way, the same pipeline can be "
"reused as is in multiple draw calls depending on different variants of "
"the resources."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:334
msgid "The content of the binding itself is quite straightforward:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:349
msgid ""
"The fields `binding.sampler` and `binding.textureView` are only needed "
"when the binding layout uses them."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:354
msgid ""
"Okay we are now ready to connect the dots! It is as simple as setting the"
" bind group to use before the draw call:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/a-first-uniform.md:374
msgid ""
"It should be working already, though not moving because the content of "
"the buffer does not change yet. So simply add anywhere in the main loop "
"this:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:1
msgid "Dynamic uniforms"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:5
#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:270
msgid ""
"*Resulting code:* [`step044`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step044)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:9
#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:274
msgid ""
"*Resulting code:* [`step044-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step044-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:12
msgid ""
"Imagine we want to issue **two calls** to the `draw` method of our render"
" pipeline **with different values** of the uniforms, in order to draw two"
" WebGPU logos with different colors. Naively we could try this:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:56
msgid ""
"It is legal, but **will not do** what you expect. Remember that commands "
"are executed **asynchronously**! When we call methods of the `renderPass`"
" object, we do not really trigger operations, we rather build a command "
"buffer, that **is sent all at once** at the end. So the calls to "
"`writeBuffer` **do not** get interleaved between the draw calls as we "
"would like."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:58
msgid ""
"Instead, we need to use **dynamic uniform buffers**. This is a simple "
"option to turn on in the binding layout, but requires to be careful with "
"the buffer's **stride** (see below)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:63
msgid ""
"As always, we checkout first that the features we use are somewhere in "
"the `WGPULimits` struct and add our requirements to the device creation "
"code:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:70
msgid ""
"Another related limit is `minUniformBufferOffsetAlignment`, which we "
"already set as the minimum value supported by the adapter (see below)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:75
msgid ""
"When declaring the bind group layout, we can **set the buffer as "
"dynamically offset**:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:98
msgid ""
"The value of this dynamic offset will be later passed to "
"`renderPass.setBindGroup`."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:100
msgid "Buffer data"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:103
msgid ""
"The basic idea is to have a buffer that is **twice the size** of "
"`MyUniforms`. For the first draw call, we set the dynamic offset to 0 so "
"that it uses the first set of values, then we issue a second draw call "
"with an offset of `sizeof(MyUniforms)` to point to the second half of the"
" buffer."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:105
msgid ""
"There is **one thing to keep in mind** though: the value of the offset is"
" constrained to be **a multiple of** the "
"`minUniformBufferOffsetAlignment` limit of the device."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:115
msgid ""
"This means that the **stride** of the uniform buffer, i.e., the number of"
" bytes between the first `r` and the second `r` above, must be rounded up"
" to the closest multiple of `minUniformBufferOffsetAlignment`:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:147
msgid "Where the utility function is given by:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:159
msgid "We can now create the buffer and upload 2 different set of values:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:207
msgid "Drawing"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:210
msgid ""
"In the previous chapters we did not use the last two arguments of "
"`renderPass.setBindGroup`, namely `dynamicOffsetCount` and "
"`dynamicOffsets` array. They are the way to provide an offset that is "
"different for different calls. To change the offset, we re-bind the bind "
"group only with a different offset."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:212
msgid ""
"If we would have multiple dynamic uniforms, we would need to point to an "
"array, but since we only have one, we can just give the address of a "
"`dynamicOffset` variable:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:255
msgid ""
"Another solution could have been to create 2 different bind groups, "
"pointing to 2 different buffers. But the dynamic offset approach **scales"
" better** when issuing a large number of draw calls with varying "
"uniforms."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:261
msgid ""
"We are now quite comfortable with uniforms, we are ready to move on to "
"actual 3D shapes!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/dynamic-uniforms.md:266
msgid "We draw the scene twice with different values of the **dynamic uniforms**."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/index.md:1
msgid "Shader Uniforms"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:1
msgid "More uniforms"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:5
#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:256
msgid ""
"*Resulting code:* [`step043`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step043)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:9
#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:260
msgid ""
"*Resulting code:* [`step043-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step043-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:12
msgid ""
"In order to illustrate the flexibility of the uniform binding process, "
"let us add a second uniform variable, this time controlling the overall "
"color of our scene."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:14
msgid "There are multiple ways to add a second uniform:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:16
msgid "In a different bind group."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:17
msgid "In the same bind group but different binding."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:18
msgid ""
"In the same binding, by replacing the type of the uniform with a custom "
"struct."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:20
msgid ""
"The interest of using different bindings is to set a different "
"`visibility` depending on the binding. In our case, the time is only used"
" in the Vertex shader, while the color is only needed by the Fragment "
"shader, so this could be beneficial. However, we may decide to use the "
"time in the Fragment shader eventually, so we'll use the same binding."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:23
msgid ""
"Another reason is that different bindings should either point to "
"different buffers, or point in the same buffer at **an offset that is at "
"least** `deviceLimits.minUniformBufferOffsetAlignment`. By default, this "
"value is set to 256 bytes for me, and the minimum supported by my adapter"
" is 64. This would be a bit of a waste to add that much padding."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:29
msgid "Let us replace the `f32` uniform with a struct:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:57
msgid ""
"Of course depending on your use case you will find a name more relevant "
"than \"MyUniforms\", but let's stick to this for now."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:59
msgid "Buffer"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:62
msgid "On the CPU side, we define the very same struct:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:76
msgid "The initial buffer upload thus becomes:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:98
msgid ""
"More generally, you should replace all instances of `sizeof(float)` by "
"`sizeof(MyUniforms)` (when setting `bufferDesc.size`, "
"`bindingLayout.buffer.minBindingSize` and `binding.size`)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:100
msgid "Updating the value of the buffer now looks like this:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:118
msgid ""
"And actually we can be more subtle, to only upload the bytes related to "
"the `time` field:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:134
msgid "Similarly we can update only the color bytes:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:154
msgid ""
"Better yet, if we forget the offset, or want to be flexible to the "
"addition of new fields, we can use the built-in `offsetof` macro:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:177
msgid "The only thing to change in the binding layout is the visibility:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:183
msgid "Memory Layout Constraints"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:186
msgid "Alignment"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:188
msgid ""
"There is one thing I have omitted until now: the architecture of the GPU "
"imposes some constraints on the way we can organize fields in a uniform "
"buffer."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:190
msgid ""
"If we look at [the uniform layout "
"constraints](https://gpuweb.github.io/gpuweb/wgsl/#address-space-layout-"
"constraints), we can see that **the offset** (as returned by `offsetof`) "
"of a field of type `vec4f` **must be a multiple** of the size of `vec4f`,"
" namely 16 bytes. We say that the field is **aligned** to 16 bytes."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:192
msgid ""
"In our current `MyUniforms` struct, this property is **not verified** "
"because `color` as an offset of 4 bytes (`sizeof(float)`), which is "
"obviously not a multiple of 16 bytes! An easy fix is simply to swap the "
"`color` and `time` fields:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:214
msgid ""
"And **don't forget** to apply the same change to the struct defined in "
"the shader code!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:217
msgid ""
"If you used the `offsetof` macro to perform partial update of the uniform"
" buffer, you are good to go. But if you did not, make sure to reflect "
"this reordering of the fields of `MyUniforms` everywhere you relied on "
"it!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:220
msgid "Padding"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:222
msgid ""
"Another constraint on uniform types is that they must be [host-"
"shareable](https://gpuweb.github.io/gpuweb/wgsl/#host-shareable), which "
"comes with [a constraint on the total structure "
"size](https://gpuweb.github.io/gpuweb/wgsl/#alignment-and-size)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:224
msgid ""
"Basically, the total size must be **a multiple of the alignment size of "
"its largest field**. In our case, this means it must be a multiple of 16 "
"bytes (the size of `vec4f`)."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:226
msgid ""
"Thus we add **padding** to our structure, namely an unused attribute at "
"the end that fills in extra bytes:"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:238
msgid "And this finally works!"
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:243
msgid "The WebGPU logo, tinted with our new uniform color."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:249
msgid ""
"We have seen here that providing multiple uniforms is commonly done by "
"actually providing a single uniform that is a structure of multiple "
"fields. Importantly these fields have memory alignment constraints."
msgstr ""

#: ../../basic-3d-rendering/shader-uniforms/multiple-uniforms.md:252
msgid ""
"I started writing [an online utility tool](https://eliemichel.github.io"
"/WebGPU-AutoLayout) to automatically derive a C++ struct that matches a "
"WGSL struct. Note that it uses the type `vec3` from the GLM library "
"instead of `std::array<float,3>` but it is easy to replace."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:1
msgid "Camera control"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:5
#: ../../basic-3d-rendering/some-interaction/camera-control.md:276
msgid ""
"*Resulting code:* [`step090`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step090)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:9
#: ../../basic-3d-rendering/some-interaction/camera-control.md:280
msgid ""
"*Resulting code:* [`step090-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step090-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:12
msgid ""
"The very first kind of interaction we usually need with a 3D scene is to "
"**change the point of view**. There are many different types of camera "
"control, depending on the use case, here are a few examples:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:14
msgid ""
"**First person:** The camera position is fixed, and its orientation "
"follows the mouse cursor. This is what is used in first-person video "
"games like shooters."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:15
msgid ""
"**Turntable:** This is what modeling tools typically use: the camera "
"**orbits** around a focus point that it remains centered on."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:16
msgid ""
"**Trackball:** Unlike the turntable, the trackball does not give a "
"particular meaning to the \"up\" axis. This enables one to orbit around "
"an object without any form of [gimbal "
"lock](https://en.wikipedia.org/wiki/Gimbal_lock)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:19
msgid ""
"There are different flavors of *turntable* control depending on how the "
"center of rotation is chosen: it may be fixed, or set as the point of the"
" 3D surface that was clicked at the beginning of each interaction."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:22
msgid ""
"We focus here on the case of the **turntable** model, which I find the "
"most confortable one for a 3D object viewer. Imho most real-life objects "
"have a notion of \"up\" and \"down\", which justifies that the view "
"controller does as well."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:24
msgid "Event handlers"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:27
msgid ""
"Similarly to what we did for the resize, we wire up 3 new GLFW window "
"events:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:57
msgid "Camera state"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:60
msgid ""
"Instead of manipulating the camera view directly as a matrix made of 16 "
"coefficients, we store a camera state that is **closer to what user input"
" affects**:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:73
msgid "We add such a state to our `Application` class."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:81
msgid ""
"We then create a (private) method that converts this state into an actual"
" matrix. We call this any time the camera state is modified:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:123
msgid ""
"You may invoke `updateViewMatrix()` at the end of `initUniforms()` to "
"ensure that the original view matrix is consistent with the camera state."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:126
msgid "Controller"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:129
msgid ""
"An interaction with the camera controller consists in the following "
"sequence of events:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:131
msgid "The mouse is **pressed**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:132
#: ../../basic-3d-rendering/some-interaction/camera-control.md:133
#: ../../basic-3d-rendering/some-interaction/camera-control.md:135
msgid "The mouse is **moved**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:134
msgid "[...]"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:136
msgid "The mouse is **released**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:138
msgid ""
"When the mouse is pressed, we save some information about the current "
"state, that we will need to update the view at each subsequent move. We "
"call this the `DragState`."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:140
msgid ""
"When the mouse is released, we forget about this information to prevent "
"new moves from affecting the view point."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:190
msgid "We also add a simple interaction when the use scrolls, to zoom in/out:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:200
msgid "Bonus: Inertia"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:203
msgid ""
"A nice addition to the **look & feel** of your viewer is to add some "
"**momentum** to the interaction, to fade out the user's gesture."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:205
msgid ""
"For this we add to the drag state the current **velocity** of the angle "
"rotation, and add a little bit of it to the rotation at the next frame."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:230
msgid ""
"We need to define a `updateDragInertia()` that is called at each frame, "
"not just when the user moves the mouse:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:269
msgid ""
"The camera controller is an important step needed before moving on to "
"lighting, because we will need to inspect our model in details."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:271
msgid ""
"Of course feel free to adapt this to your own camera model. With this "
"example you can already do a lot and you should be able to easily add "
"some keyboard interaction on your own using "
"[`glfwSetKeyCallback`](https://www.glfw.org/docs/3.0/group__input.html#ga7e496507126f35ea72f01b2e6ef6d155)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/camera-control.md:273
msgid ""
"Next we see the last bit of general purpose code, to get the base for a "
"**user interface**, after which we'll move back to 3D-specific stuff!"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/index.md:1
msgid "Some interaction"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:1
msgid "Lighting control"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:5
#: ../../basic-3d-rendering/some-interaction/lighting-control.md:394
msgid ""
"*Resulting code:* [`step100`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step100)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:9
#: ../../basic-3d-rendering/some-interaction/lighting-control.md:398
msgid ""
"*Resulting code:* [`step100-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step100-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:12
msgid ""
"Now that we have elements of GUI, we can use them to expose for instance "
"the **lighting settings** to the user. We want them to be able to **live "
"tweak** the direction and color of our light sources."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:14
msgid "Recap on basic shading"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:17
msgid ""
"Let's first recap what we have seen in the [Basic shading](../3d-meshes"
"/basic-shading.md) chapter."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:19
msgid "The shaded look of a surface element depends on its **normal**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:20
msgid ""
"This look also depends on **light sources**, and in particular on their "
"direction."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:21
msgid ""
"The most basic shading we tested with is `shading = max(0.0, "
"dot(lightDirection, normal))`. This is a (lambertian) **diffuse** "
"shading."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:24
msgid ""
"For more details about the rational behind this simple diffuse model, you"
" can consult this nice introduction on Scratchpixel: [Diffuse and "
"Lambertian Shading](https://www.scratchapixel.com/lessons/3d-basic-"
"rendering/introduction-to-shading/diffuse-lambertian-shading.html)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:27
msgid ""
"We can plug this with the texture sampling, by using the texture as the "
"base color before applying the shading:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:55
msgid "I renamed what was called `gradientTexture` into `baseColorTexture`."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:61
msgid "The boat model with some basic lighting."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:64
msgid "Lighting uniforms"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:67
msgid ""
"To facilitate the further testing of lighting and materials in the next "
"chatpers, let's **make the light sources dynamic** and connect them to "
"our GUI."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:69
msgid ""
"Instead of hardcoding the light settings, we would like to pass them "
"through a uniform:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:105
msgid "For this, we need to:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:107
msgid "Create a new **uniform buffer**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:108
msgid "Create a new **binding** in the bind group for this uniform."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:109
msgid "Add this binding to the **bind group layout**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:111
msgid "Uniforms"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:113
msgid ""
"Before anything, we replicate the `LightingUniforms` struct in the C++ "
"code:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:127
msgid ""
"Note how I turned the direction and color to `vec4` instead of `vec3`. "
"This is because of [alignment rules](https://www.w3.org/TR/WGSL"
"/#alignment-and-size): a `vec3` is aligned as if it was a `vec4`."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:130
msgid ""
"We then use this structure to create an attribute, and define its GPU-"
"side counterpart:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:146
msgid "And we create 3 methods to manage this new uniform buffer:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:155
msgid "These are very similar to our other uniforms:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:221
msgid ""
"We will see later when to call `updateLightingUniforms()`, but before "
"that we need to add bindings for this new uniform buffer."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:223
msgid "Bindings"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:225
msgid "In `initBindGroup`, add the new binding:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:253
msgid ""
"Of course we must also add this to the bind group **layout**! Since is is"
" very common to change both the bind group and its layout, I like to "
"create a `initBindGroupLayout()` method that sits next to the "
"`initBindGroup()` in the code, althrough it is not called exactly before:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:268
msgid ""
"Extract this from `initRenderPipeline()`, then add our new lighting "
"uniform buffer:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:289
msgid ""
"Since we are adding a new uniform buffer, don't forget to update the "
"required limits:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:296
msgid "GUI"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:298
msgid ""
"Let us now connect the GUI by replacing the \"Hello, world\" panel in "
"`updateGui()`:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:311
msgid ""
"The `glm::value_ptr` function returns a pointer to where the glm object's"
" raw data is stored, which is what ImGui needs to operate. In practice "
"for vectors it is equivalent to using the address of the vector object "
"itself."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:314
msgid ""
"This changes the value of `m_lightingUniforms` when the user tweaks "
"sliders. In order to reflect these changes in the GPU-side uniforms, we "
"copy at each frame the values that the GUI manipulates to the GPU-side "
"buffer."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:326
msgid "The UI is connected to the lighting uniforms."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:329
msgid "Complement"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:332
msgid "Custom GUI input"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:334
msgid ""
"This `ImGui::DragFloat3` input is not ideal for a direction. It is not so"
" intuitive, and does not ensure that the direction vector always has a "
"length of 1. We can easily create our own input `ImGui::DragDirection` to"
" expose the direction as 2 polar angles:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:349
msgid "It can be used as follows:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:355
msgid "Slight optimization"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:357
msgid ""
"Instead of uploading the lighting uniform buffer at each frame even when "
"nothing changes, we can get from ImGui the information of whether the "
"fields changed:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:385
msgid "In this chapter we have:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:387
msgid "Connected diffuse shading with textures,"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:388
msgid "Connected lighting with GUI."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:389
msgid "Created a custom GUI."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/lighting-control.md:391
msgid "Okey, we are now ready to dive into material models for real!"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:1
msgid "Refactoring"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:5
#: ../../basic-3d-rendering/some-interaction/refactoring.md:276
msgid ""
"*Resulting code:* [`step080`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step080)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:9
#: ../../basic-3d-rendering/some-interaction/refactoring.md:280
msgid ""
"*Resulting code:* [`step080-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step080-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:12
msgid ""
"The goal of this chapter is to **add some interactivity** to our viewer. "
"From a WebGPU standpoint, we know everything we need for this. For "
"instance enabling the user to turn around the object using the mouse is "
"only about **updating the view matrix**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:14
msgid ""
"However, it is also the occasion to **organize a bit our code base**, "
"which we have not been discussing much until now. It was not the primary "
"topic, and the size of the code was still manageable as mostly a big main"
" function, but this never holds for bigger applications."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:16
msgid "An application structure"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:19
msgid "Main class"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:21
msgid ""
"I am going to **avoid over-engineering** things since each use case is "
"different, so you will customize the details for your needs. Nevertheless"
" it always starts with a class (or struct) that holds all the global "
"state of the application."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:23
msgid ""
"We implement this in two new files `Application.h` and `Application.cpp`,"
" where the behavior of the application is distributed across **event "
"handlers**. To make this logic clear, handles start with \"on\", like "
"`onFrame`. We can already think of three events: init, frame and finish."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:50
msgid ""
"I prefix private attribute names with `m_` to better distinguish them "
"from local variables when reading the code. This is a common practice "
"(some people also prefer using only `_foo`, or full caml case `mFoo`)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:54
msgid ""
"When using the C++ wrapper, it is important to initialize WebGPU handles "
"to null (e.g., `m_instance = nullptr`) because they have no default "
"constructor. Otherwise you will experience this kind of error:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:61
msgid ""
"Before actually implementing these methods, we can already try draft how "
"this will be used in our `main` function:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:80
msgid ""
"We hence see that we also need to add a `isRunning` method, that simply "
"calls `glfwWindowShouldClose` behinds the hoods but without exposing the "
"GLFW window to the \"client\" code (namely the main function)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:119
msgid ""
"Do not forget to add these file (most importantly the .cpp) to the source"
" files listed in `CMakeLists.txt`:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:129
msgid "Initialization steps"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:131
msgid ""
"The part of our code that is the **most monolithic** is by far the "
"initialization step. We thus split it into various (private) methods:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:147
msgid ""
"And each `initSomething` step comes with a `terminateSomething` that is "
"called at the end in reverse order:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:162
msgid ""
"This way, it is easier to keep track of what must be released at the end "
"of the application. You can also group the attributes by step when "
"declaring them in `Application.h`."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:164
msgid ""
"I let you **move the largest chunks of code by yourself**, otherwise this"
" chapter would look like a big listing. Most parts of the old `main.cpp` "
"should end up in `Application.cpp`; you can check it against [the "
"reference code](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step080) from this chapter of course."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:166
msgid ""
"The next sections present some **additional design choices** I made on "
"the course of refactoring the code. You may or may not follow them."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:168
msgid "Design choices"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:171
msgid "Resource manager"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:173
msgid ""
"Our three procedure for loading external resources can be moved into a "
"separate namespace or class with only static members."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:175
msgid ""
"We create a `ResourceManager.h` and `ResourceManager.cpp` files, add them"
" to the CMakeLists and move resource loaders there."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:213
msgid "Library implementation"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:215
msgid ""
"As we start including our libraries in multiple files, we must remember "
"that the `#define FOO_IMPLEMENTATION` that some of them require **must "
"appear in only one** C++ file, and the include must be placed before any "
"other one that may recursively include it."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:217
msgid ""
"To avoid some unexpected complication, I recommend to create a file "
"`implementations.cpp` to be the place for this and only this:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:231
msgid "Callback handles"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:234
msgid ""
"This section is **specific to the WebGPU C++ wrapper** I provide. When "
"using the raw C API, the callback cannot be a lambda function and must "
"rather be defined in the global scope."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:237
msgid ""
"In order to prevent the uncaptured error callback from being freed too "
"early, we need to store the handle returned by "
"`device.setUncapturedErrorCallback`. So far this was just done by "
"defining a variable `h` that lives for the whole main function:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:248
msgid ""
"Since we no longer define this in the main function directly but rather "
"in the `Application`'s init, we must store the `h` handle as a class "
"member:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:266
msgid ""
"This way, the callback is released only when the Application object is "
"destroyed."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:271
msgid ""
"We now have a much more mature code base, that will be way easier to "
"extend as we introduce new features in the next chapters!"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/refactoring.md:273
msgid ""
"Remember that any time you add something in an `init` step, you should "
"likely release it in the matching `terminate` method."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:1
msgid "Resizing the window"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:5
#: ../../basic-3d-rendering/some-interaction/resizing-window.md:208
msgid ""
"*Resulting code:* [`step085`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step085)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:9
#: ../../basic-3d-rendering/some-interaction/resizing-window.md:212
msgid ""
"*Resulting code:* [`step085-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step085-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:12
msgid ""
"When we introduced the swap chain, **we prevented the window from "
"resizing** by setting the `GLFW_RESIZABLE` window \"hint\" to false, "
"because the swap chained is tied to a specific size."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:14
msgid ""
"Now that our code is better organized, it becomes easy to **get rid of "
"this limitation**: in this chapter, we restore the possibility to resize "
"the window:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:20
msgid ""
"To do so, we add a `onResize` handler that we call when the window is "
"resized, and **rebuild the swap chain** with the new resolution. And we "
"also need to resize the **depth buffer** by the way."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:22
msgid "Callback setup"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:25
msgid "Let us first add the `onResize()` method:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:35
msgid ""
"GLFW provides a mechanism for setting a callback to be invoked each time "
"the window size changes: "
"[`glfwSetFramebufferSizeCallback`](https://www.glfw.org/docs/3.0/group__window.html#ga3203461a5303bf289f2e05f854b2f7cf)."
" Naively, we could consider the following:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:49
msgid ""
"**This cannot work** because a non-static class method like "
"`Application::onResize` needs a value of `this` when it is called, so it "
"cannot be used as a function pointer (which "
"`glfwSetFramebufferSizeCallback` expects)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:51
msgid ""
"The usual trick here is to define a simple callback function that does "
"nothing but to call the `onResize()` method."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:53
msgid "ðŸ¤” But how do I specify \"this\"? Should I use a global variable?"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:55
msgid ""
"It is precisely for this pattern that GLFW provides a **user pointer**, "
"namely an arbitrary value that can be associated to a window. Since the "
"callback receives the window as first argument, we can get the user "
"pointer back and use it:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:82
msgid ""
"If we want to make this more compact and avoid creating a dedicated "
"function, we can use a **lambda** when calling "
"`glfwSetFramebufferSizeCallback`:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:101
msgid ""
"I did not show the lambda version right away because it is slightly "
"misleading: **it is tempting** to use the **capturing context** of the "
"lambda (the `[]` before the lambda's arguments) to provide `this` to the "
"callback."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:103
msgid ""
"However, **only non-capturing lambdas** may be casted to the raw function"
" pointer that GLFW expects for a callback. This remark goes for any C API"
" by the way."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:106
msgid "Resize event handler"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:109
msgid "Swap Chain and Depth Buffer"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:111
msgid "With our new design, the content of `onResize()` is pretty simple:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:126
msgid ""
"On this simple example, **managing the lifetime** of WebGPU objects "
"(e.g., destroying before rebuild them, releasing at the end of the "
"application, etc.) can be done manually. But since this is in general "
"quite **error-prone**, the [RAII](../../advanced-techniques/raii) chapter"
" presents a common C++ **design pattern** that makes this easier."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:129
msgid ""
"However, we need to **update** `initSwapChain()` and `initDepthBuffer()` "
"to take into account **the actual size of the window**, rather than the "
"hardcoded $(640,480)$."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:154
msgid "Camera Projection"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:156
msgid ""
"If you look for \"640\" in your code to ensure nothing relies any more on"
" the original window size, you'll find that **we use the size when "
"defining the camera projection**. Thus the `onResize` function must also "
"update the projection matrix uniform:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:165
msgid "Where `updateProjectionMatrix` is a new private method:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/resizing-window.md:205
msgid ""
"This pattern that we used to connect the raw GLFW resize event to our C++"
" idiomatic object-oriented application skeleton is **a commonly used "
"pattern**: we will do the same for all the other interaction callbacks we"
" need. We see in the next chapter the case of mouse button and mouse move"
" callbacks to get the **camera controller**!"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:1
msgid "Simple GUI"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:5
#: ../../basic-3d-rendering/some-interaction/simple-gui.md:262
msgid ""
"*Resulting code:* [`step095`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step095)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:9
#: ../../basic-3d-rendering/some-interaction/simple-gui.md:266
msgid ""
"*Resulting code:* [`step095-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step095-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:13
#: ../../basic-3d-rendering/some-interaction/simple-gui.md:270
msgid ""
"*Resulting code:* [`step095-dawn`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step095-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:16
msgid ""
"Multiple solutions exist for writing *graphical user interfaces* (GUI), "
"i.e., buttons, text inputs, value sliders and so on."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:18
msgid ""
"For applications that are mostly about these inputs, it is common to use "
"**a whole *framework*** as a base, like [Qt](https://www.qt.io/), "
"[GTK](https://www.gtk.org/), [wxWidgets](https://www.wxwidgets.org/), "
"[WinUI](https://microsoft.github.io/microsoft-ui-xaml/), etc. These "
"usually manage the main application loop by themselves and are heavy "
"dependencies."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:20
msgid ""
"But in the case of video games or prototypes like ours, one usually turns"
" towards **more lightweights solutions**, among which [Dear "
"ImGui](https://github.com/ocornut/imgui) is a very popular choice."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:23
msgid ""
"ImGui does not try to give a OS-native look to your app. Instead, it "
"focuses on being very **easy to integrate** to any existing project, and "
"**easy to program with**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:25
msgid ""
"This also comes at the price of redrawing the whole GUI from scratch at "
"each frame while frameworks usually only update what is needed."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:28
msgid "Setting up ImGui"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:31
msgid ""
"ImGui fully supports using WebGPU as a backend with both wgpu-native and "
"Dawn since its [version "
"1.89.8](https://github.com/ocornut/imgui/archive/refs/tags/v1.89.8.zip). "
"Unzip it as a `imgui/` directory, remove `examples`, `doc` and `.github` "
"(or keep them but we don't need them)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:33
msgid ""
"ImGui does not provide a `CMakeLists.txt` but it is straightforward to "
"write it ourselves (still in the `imgui/` directory):"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:66
msgid "Then in your root `CMakeLists.txt`, as usual:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:79
msgid "Overview"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:81
msgid ""
"ImGui interface is redrawn at each frame, following a very imperative "
"style:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:103
msgid ""
"Available functions can be found in "
"[`imgui.h`](https://github.com/ocornut/imgui/blob/master/imgui.h), and "
"additional help is given in [their "
"wiki](https://github.com/ocornut/imgui/wiki)."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:105
msgid "Setup"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:107
msgid ""
"We however **need to set-up some boilerplate**, both when starting the "
"application and before/after defining the GUI at each frame."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:109
msgid ""
"To make things clearer, we isolate GUI-related code into specific methods"
" (note that we need to access the render pass in `updateGui`):"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:146
msgid ""
"Here comes the boilerplate itself. For each step (global init, frame "
"init, frame render) there is usually the \"pure\" ImGui function as well "
"as the backend functions. Things are decoupled this way because ImGui can"
" be used together with other libraries than GLFW and WebGPU."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:188
msgid "Example of GUI"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:190
msgid "This ImGui's basic example, that shows some **typical use cases**."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:192
msgid ""
"Note that variables are defined as **static** here, so that they are "
"initialized only once and then **\"remembered\"** across frames."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:221
msgid "Capabilities"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:223
msgid "Using ImGUI requires `maxBindGroups` to be at least 2."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:230
#: ../../basic-3d-rendering/texturing/a-first-texture.md:116
msgid "Misc"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:233
msgid ""
"You may have noticed when playing with sliders that while ImGui is "
"reacting to your mouse, **the camera controller also receives the "
"events**, which is a bit annoying."
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:235
msgid ""
"To prevent this, we can use the `io.WantCaptureMouse` variable that ImGui"
" turns to true when it detected that the user interacts with the widgets."
" When so, we ignore mouse clicks in the camera controller:"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:253
msgid "A basic GUI with ImGUI"
msgstr ""

#: ../../basic-3d-rendering/some-interaction/simple-gui.md:259
msgid ""
"Congratulations, we now have all the tools we need to easily test various"
" parameters and interact with the 3D scene, we can then move on to the "
"lighting and materials!"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:1
msgid "A first texture"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:5
#: ../../basic-3d-rendering/texturing/a-first-texture.md:483
msgid ""
"*Resulting code:* [`step060`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step060)"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:9
#: ../../basic-3d-rendering/texturing/a-first-texture.md:487
msgid ""
"*Resulting code:* [`step060-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step060-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:12
msgid ""
"Textures play **a very important role** in a rendering pipeline, both for"
" 2D or 3D graphics."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:14
msgid ""
"**Theoretically**, a GPU buffer could be used to store the texture data, "
"and the shader would compute at which offset within this buffer a given "
"pixel belongs. But this would be **inefficient** (and maybe not even "
"supported on some devices). Texture access is actually handled by "
"**dedicated fixed units** of the GPU."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:16
msgid ""
"This is why although all types of **resources** live in the VRAM, "
"**buffers**, **textures** and **storage textures** are different objects "
"in the WebGPU API (as well as in all other graphics APIs)."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:18
msgid "Texture creation"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:21
msgid ""
"Let us get back to the texture that we had to create for the depth "
"buffer, and **copy it** to create a new texture in the initialization of "
"the app:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:40
msgid "And add right away the texture destruction at the end of the app:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:56
msgid "Size"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:58
msgid ""
"A simple setting is the size of the texture (which I arbitrarily set to a"
" power of 2 because it usually helps the GPU in aligning memory):"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:76
msgid ""
"A texture can have $1$, $2$ or $3$ dimensions. Meaning it is either a 1D "
"color gradient, a 2D image of a 3D grid of voxels."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:78
msgid "ðŸ¤” When should I use a 1D texture rather than a simple buffer?"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:80
msgid ""
"A texture allows to **sample** values **continuously**. For instance even"
" if your 1D texture has only 10 texels (a **texel** is a pixel of a "
"texture), you may sample its value at a **non-integer coordinate** $4.5 /"
" 10$ and you would automatically get a mix of texels 4 and 5."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:82
msgid ""
"Another powerful feature of textures is the possibility to sample the "
"**average** value over a neighborhood of a texel, thanks to **mip-maps**."
" These make a texture **contain multiple images** (also called "
"*subresources*). So the texture size is not only the `size` field but "
"also the number of mip-maps given by `mipLevelCount`."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:84
msgid ""
"We'll get to why this is useful **later on**, for now we set the mip "
"level count to the minimum value $1$ to deactivate this feature:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:90
msgid ""
"Textures are also able to store **more than one color per texel**, thanks"
" to **multisampling**. This is typically used for handling anti-aliasing "
"([MSAA](https://en.wikipedia.org/wiki/Multisample_anti-aliasing)). Again,"
" we do not use this for our texture:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:96
msgid ""
"Both the mip level count and the sample count have an **impact on the "
"memory size** of the texture, so when not using these features, setting "
"them to $1$ (the minimum) saves memory."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:98
msgid "Format"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:100
msgid ""
"The texture format indicates at the same time the **number of channels** "
"in the texture (R, RG, RGB, RGBA), **their order** (RGBA, BGRA, etc.), "
"and **the way each channel is encoded**, including the number of bits and"
" the scale."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:102
msgid ""
"For instance, `RGBA8Unorm` means 4 channels (RGBA), with 8 bits per "
"channel which represent unsigned values (U) normalized (norm) so that "
"they are manipulated as real numbers in the range $(0,1)$ (instead of "
"integers in $(0,255)$ for instance)."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:118
msgid ""
"Like buffers, textures must **declare their intended usage**, so that "
"they can be places in more appropriate parts of the memory by the GPU's "
"memory allocator."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:120
msgid ""
"In order to be able to **copy pixel data from C++**, the texture needs "
"the `CopyDst` usage. And we will then use the texture by **sampling it "
"from a shader**, so it must be declared with the `TextureBinding` usage:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:134
msgid "Lastly, we initialize the texture view settings to 0 (more on this later):"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:141
msgid "Uploading texture data"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:144
msgid ""
"We created a texture, which allocated memory in VRAM (i.e., on the GPU). "
"But this remains an **uninitialized chunk of memory**, to which we must "
"set data. This is typically done by **uploading** it from the CPU."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:146
msgid "Test data"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:148
msgid ""
"Our first texture will be **a simple gradient**, which we can define in "
"our C++ code as follows:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:167
msgid "The test texture that we generate in our C++ code."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:170
msgid "Write texture"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:172
msgid ""
"Uploading this pixel data to the texture uses `Queue::writeTexture`, to "
"be called once both the texture and its data are created. But a call to "
"`Queue::writeTexture` is a bit more complicated than "
"`Queue::writeBuffer`: since write texture has a lot of arguments, they "
"are grouped in substructures:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:204
msgid "Destination"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:206
msgid ""
"The `writeTexture` procedure writes **only one image** (subresource of "
"the texture) at a time. The argument `destination.mipLevel` tells which "
"one we target, and in our case we have only **one mip level**."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:208
msgid ""
"The `destination.origin` is the equivalent of the **offset** argument of "
"`Queue::writeBuffer`. Together with the `writeSize` argument, it tells "
"**which part of the image** gets updated, so that we may update only a "
"small part of it. Finally, the aspect is not relevant for color textures."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:228
msgid "Source"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:230
msgid ""
"The `source` layout tells how to read from the buffer. The `offset` tells"
" where the data starts after the CPU data pointer we provide in "
"`writeTexture`."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:232
msgid ""
"The `bytesPerRow` tells the stride, i.e., the number of bytes between two"
" consecutive rows in the CPU data."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:234
msgid ""
"And the `rowsPerImage` is the the height of an image, it is important "
"when uploading multiple images at once (only possible when uploading a "
"*texture array*, which we do not use here)."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:236
msgid "In our case, the data is contiguous, so we set this as follows:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:245
msgid ""
"When loading data from an image file, rows might be aligned to a round "
"number of bytes, hence `source.bytesPerRow` would be slightly bigger than"
" `4 * textureDesc.size.width`. This is also needed when uploading very "
"small images because there is **a minimum value** for `bytesPerRow` that "
"is set to 256 by the API."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:248
msgid "Texture drawing"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:251
msgid ""
"Great, we have loaded a texture to the GPU memory... But what can we do "
"with it? How can we check that it was correctly uploaded?"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:253
msgid ""
"Unfortunately, there is no quick way to copy a texture to the texture "
"view `nextTexture` returned by the swap chain. Instead, we **bind our "
"texture to the render pipeline** and sample it from our shader."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:257
msgid ""
"This binding is close to the uniform buffer binding. We first need to add"
" it to the bind group **layout**. We also slightly reorganize our code to"
" handle multiple bindings:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:314
msgid "We can now specifically setup our texture binding layout:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:336
msgid ""
"The visibility is set to the **fragment shader only**, we will not sample"
" this texture in the vertex shader."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:338
msgid ""
"The texture **sample type** tells which variable type will be returned in"
" the shader code when sampling the texture. Since our texture uses a "
"normalized format (`RGBAUnorm`), its values are represented as floats."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:340
msgid "Binding"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:342
msgid ""
"Once both the pipeline layout and the texture itself are created, we can "
"alter the bind group to add the texture binding (and again slightly "
"reorganize):"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:387
msgid ""
"As you can see, we are not allowed to directly pass a texture to the "
"binding, we rather need to create a **texture view**. Create it right "
"after the creation of the texture itself:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:419
msgid ""
"We can now declare a global variable of type `texture_2d<f32>` in our "
"shader, attached to binding 1 in bind group 0. The function `textureLoad`"
" returns the raw texel value at a given coordinate, and the "
"`@builtin(position)` input of the frament shader is the pixel screen "
"coordinate:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:430
msgid ""
"Sampling from a texture in a shader requires to set a new device limit, "
"to be increased each time you add a texture:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:437
msgid ""
"In order to better see the result, we make sure that there is a fragment "
"for each pixel by drawing a plane that covers the whole screen. Load the "
"file [plane.obj](../../data/plane.obj) and set your matrices to:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:452
msgid "Our first texture displayed by drawing a full-screen quad."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:455
msgid "Feel free to play with other formulas to create the texture data:"
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:474
msgid "Changing the pixel array indeed changes the displayed image."
msgstr ""

#: ../../basic-3d-rendering/texturing/a-first-texture.md:480
msgid ""
"We have seen **how to create** a texture and **how to access** its pixels"
" from a shader. In the next chapter we will see **how to map a texture "
"onto a 3D mesh**. And we will realize that we miss a very important "
"ingredient: to fully benefit from the power of a texture, it must be "
"accessed through a **sampler**."
msgstr ""

#: ../../basic-3d-rendering/texturing/index.md:1
msgid "Texturing"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:5
#: ../../basic-3d-rendering/texturing/loading-from-file.md:524
msgid ""
"*Resulting code:* [`step075`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step075)"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:9
#: ../../basic-3d-rendering/texturing/loading-from-file.md:528
msgid ""
"*Resulting code:* [`step075-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step075-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:12
msgid ""
"The goal of this chapter is to **summarize everything we have done** to "
"write a utility function `loadTexture` that creates a texture from a "
"file."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:30
msgid "The stb_image library"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:32
msgid ""
"Once again, to **load standard file format**, we better use existing code"
" than study the specifications ourselves. We use here the `stb_image` "
"single-header library, from the very handy "
"[stb](https://github.com/nothings/stb) set of libraries. It supports all "
"basic image types (png, jpg, bmp, ...)."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:34
msgid ""
"Save "
"[stb_image.h](https://raw.githubusercontent.com/nothings/stb/master/stb_image.h)"
" in your source tree and include it in your main file:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:41
msgid ""
"This provides two functions: `stbi_load` and `stbi_image_free`, to be "
"used as follows:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:56
msgid ""
"The stb_image library triggers a few warnings, that need to be "
"deactivated if you want to treat warnings as errors."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:65
msgid ""
"Note that this disables the warning for your files as well. A solution to"
" only disable warnings for stb_image would be to have the file with "
"`STB_IMAGE_IMPLEMENTATION` isolated in its own CMake target."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:68
msgid "loadTexture"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:70
msgid ""
"With the dimensions of the texture in hand, we can create the texture "
"object."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:129
msgid ""
"We still need to write the `writeMipMaps` auxiliary function. The first "
"mip level is easy, it can directly use the `data` vector:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:187
msgid "Texture view"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:189
msgid ""
"Before dealing with mip maps, we'd like to test our `loadTexture` for mip"
" level 0. But for this we still miss one part: the **texture view**."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:191
msgid ""
"To create the texture view that is used by the sampler, we need the **mip"
" level count** and **format**. We can modify the `loadTexture` either to "
"return these information, or as I do here to create an appropriate "
"texture view and return it."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:193
msgid ""
"This is made **optional** by passing the returned view by a pointer, that"
" is ignored if null."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:239
msgid "We can thus load our texture as follows:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:267
msgid ""
"Copy any image ([example](../../images/cobblestone_floor_08_diff_2k.jpg))"
" to `resources/texture.jpg` and you should see it loaded on the 3D plane!"
" You may have to increase the maximum image size in the **device "
"limits**:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:276
msgid ""
"Here the texture view pointer passed to `loadTexture` is `&textureView`, "
"namely the address of the variable `textureView`. Even if the variable "
"itself is initialized to null, **its address**, called `pTextureView` in "
"the function, **is not null**, and thus a view is created and returned."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:279
msgid "Generating mip-maps"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:281
msgid ""
"Let us now come back on the `writeMipMaps` function. We can import in "
"here the loop of `writeTexture` we implemented to load mip levels in the "
"previous chapter:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:423
msgid ""
"Lastly, we **automatically infer the mip level count** from the texture "
"size, as noted in the previous chapter:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:466
msgid "A textured loaded from a file, with proper mip-mapping."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:469
msgid "Textured model"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:471
msgid ""
"Let us finish this chapter with a nice textured 3D model. Unzip "
"[fourareen.zip](../../data/fourareen.zip) in your resource directory "
"(special thanks to Scottish Maritime Museum for [sharing this "
"model](https://sketchfab.com/3d-models/venus-a-shetland-fourareen-"
"ce4d6915e1d041459e08f2d8da521e86)!) and change the two loading lines:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:489
msgid ""
"If you try this, you'll see that the texture is not correctly projected "
"onto the geometry. A first thing is to make sure you removed the UV "
"multiplication we added in the previous chapter to explore the effect of "
"the sampler:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:495
msgid ""
"We also need to increase again the vertex buffer size limit, because this"
" mesh has almost 150k vertices:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:501
msgid "And finally here is a suggestion of view point:"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:513
msgid "A textured 3D model rendered in our WebGPU viewer."
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:519
msgid ""
"Even if the lighting model is quite basic, we are now able to load and "
"display **complex 3D models with texture**!"
msgstr ""

#: ../../basic-3d-rendering/texturing/loading-from-file.md:521
msgid ""
"The next part will help us **organize a bit our code base**, as it is "
"getting too long to be left as a monolithic main. Once this is done, "
"we'll proceed to the last part of building a basic real-time 3D renderer,"
" namely **lighting**."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:1
msgid "Sampler"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:5
#: ../../basic-3d-rendering/texturing/sampler.md:586
msgid ""
"*Resulting code:* [`step070`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step070)"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:9
#: ../../basic-3d-rendering/texturing/sampler.md:590
msgid ""
"*Resulting code:* [`step070-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step070-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:12
msgid ""
"The `textureLoad` function, that we used in our shader accesses the "
"texture data, acts almost as if a texture was a basic buffer. It **does "
"not benefit** from the interpolation and mip level selection features "
"that the GPU is capable of."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:14
msgid ""
"To **sample** values from a texture with all these capabilities, we "
"define another resource called a **sampler**. We see below why this "
"proper way of fetching texture data is important to **avoid aliasing "
"artifacts**."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:16
msgid "Sampler setup"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:19
msgid "Sampler creation"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:21
msgid ""
"I am going to detail the sampler settings in the second part of this "
"chapter, once everything is wired up. For now just copy it, so that we "
"can start experimenting right away."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:66
msgid "We also need to raise the following device limit:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:72
msgid "Sampler binding"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:74
msgid "Adding a new binding should feel rather straightforward by now:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:118
msgid "Sampler usage"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:120
msgid ""
"In the **shaders**, the sampler simply uses the `sampler` type. Once "
"bound, we can use `textureSample(t, s, uv)` to sample the texture `t` at "
"UV `uv` using the sampler `s`:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:137
msgid "The cube, textured using a filtering sampler."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:141
msgid ""
"We can already see the effect of using a sampler: since our texture has a"
" low resolution, the sampler **interpolates** neighbor texels when asked "
"to sample at a **non-integer texel coordinate**, hence this **less "
"pixelated** result."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:144
msgid "Addressing"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:147
msgid ""
"The first part of the sampler settings is rather easy to understand. The "
"address modes (`addressModeU`, ...) tell for each axis of the coordinate "
"space (U, V, and W for 3D textures) how to handle values that are **out "
"of the range** $(0,1)$."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:149
msgid ""
"To illustrate this, we go back to our plane example and edit the **vertex"
" shader** to scale and offset the UVs."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:158
msgid ""
"With the ClampToEdge mode, UVs out of the $(0,1)$ range are clamped to "
"$0$ or $1$."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:161
msgid ""
"Note that if we switch back to raw texture loading, out of bounds texels "
"return a null color:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:172
msgid "Raw texture loading returns a null color when out of bounds."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:175
msgid ""
"Back to a sampled texture, let us now try a different value for the U "
"address mode:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:192
msgid "The Repeat mode set on U repeats the texture infinitly."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:195
msgid ""
"The last address mode, which we can try on the V axis, repeats with a "
"mirroring effect:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:212
msgid "The Repeat mode set on V repeats the texture with mirroring."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:215
msgid "Filtering"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:218
msgid ""
"The next sampler settings are about **filtering**, which is the **most "
"powerful** part of the sampler. There are **two types of filtering**."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:220
msgid "Magnifying filtering"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:222
msgid ""
"Magnifying filtering consists in interpolating (i.e., mixing) the value "
"of two neighboring pixels when a fragment samples a location that falls "
"**between two round texel coordinates**."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:224
msgid "We can compare the two possible filters:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:256
msgid ""
"The `Nearest` mode corresponds to **rounding** to the closest integer "
"texel coordinate, which corresponds roughly to what we had with raw texel"
" loading (not exactly because we were truncating coordinates rather than "
"rounding)."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:258
msgid ""
"The `Linear` mode, **commonly used**, corresponds to mixing coordinates "
"from `floor(u * width)` and `floor((u + 1) * width)` with factor `fract(u"
" * width)`."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:260
msgid "Minifying filtering"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:262
msgid "Aliasing"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:264
msgid ""
"This other filter is deactivated in our current setup (because we have "
"only 1 mip level), and we can highlight the issue that minifying "
"filtering addresses by moving the camera over the plane:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:308
msgid ""
"This is **terrible**, and appears any time a large texture is applied on "
"an **object that appears small** (e.g., because it is far from the "
"viewer)."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:310
msgid ""
"The key problem is that **when a screen pixel covers a lot of texels**, a"
" naive sampling procedure takes the color of one of the texels only, "
"whereas the pixel should be colored with the **average** color of all the"
" texels it covers."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:327
msgid "Mip-mapping"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:329
msgid ""
"It takes **too much time** to measure the average of all texels in the "
"pixel footprint (imagine when the object is textured with a 4K map but "
"appears on a 100 pixel area)."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:331
msgid ""
"What can we do? We **precompute** many possible averages, store them into"
" extra images called **mip maps**. The minifying filtering is thus more "
"commonly called **mip-mapping**. This takes more memory, but not that "
"much (twice the initial texture memory) compared to how it speeds things "
"up."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:333
msgid ""
"We can already change the description of our texture, and of the texture "
"view provided to the sampler, to allocate room for **storing the extra "
"mip levels**:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:371
msgid ""
"After allocating these mip levels, we can see that the sampler uses our "
"texture data only for the closest part of the plane. Beyond this, it "
"samples black color because we left the **extra mip levels "
"uninitialized**:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:376
msgid ""
"Closest points are sampled from the mip level 0, which contains our "
"texture. Other mip levels are filled with black pixels."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:380
msgid ""
"The size of each mip level is half the size of the previous one, until "
"one of the dimensions reaches 1 and is no longer divisible. The following"
" code snippet defines the **maximum number of mip levels** (as specified "
"[here](https://www.w3.org/TR/webgpu/#abstract-opdef-maximum-miplevel-"
"count)):"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:393
msgid "Mip-level data"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:395
msgid ""
"Now we need to **compute the data** of these other mip levels. Then for "
"each level, we issue a `queue.writeTexture` call to load the data for "
"that level."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:398
msgid ""
"In a later part of this tutorial, we will use **compute shaders** to fill"
" in the mip levels given the level 0 directly on the GPU, as this is more"
" efficient."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:401
msgid ""
"Let us enclose the texture data uploading (our call to "
"`queue.writeTexture`) in a loop over each mip level:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:471
msgid ""
"If the level is 0, `pixels` is filled as previously. For extra levels, "
"let us start with some plain color for debugging:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:495
msgid ""
"You should now see a **gradient** depending on the distance of the points"
" to the camera. Each color of the gradient corresponds to texels sampled "
"from a different mip level."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:497
msgid ""
"Again, **the sampler automatically figures out** which level to sample. "
"It does so based on the difference of UV coordinate between two neighbor "
"pixels."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:513
msgid ""
"Note that the sampler actually blends from multiple mip levels for an "
"even more continuous visual response. This can be deactivated by changing"
" the `mipmapFilter`:"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:530
msgid "The debugging mip levels with Nearest mip-map filter mode."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:533
msgid ""
"We can now fill in the mip levels with the **actual filtered data**: each"
" texel of level $i$ is the average of 4 texels from level $i - 1$."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:560
msgid ""
"For the sake of simplicity, I assumed here that we were using a texture "
"whose dimensions is **a power of 2** so that it is always possible to "
"divide the size by 2. When it is not the case, one must take care of "
"borders."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:563
msgid ""
"Our sampler is thus able to provide texture samples that produce **way "
"less aliasing artifacts**! (Don't forget to switch back the "
"`mipmapFilter` to `Linear`):"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:574
msgid ""
"We can still see a little bit of aliasing at grazing angles. This is due "
"to the fact that the MIP pyramid precomputes **isotropic** averages, "
"which footprint is a regular square, but at grazing angle a pixel's "
"footprint is an elongated trapezoid."
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:576
msgid ""
"This **anisotropy** is partially taken into account by the sampler "
"(through the `maxAnisotropy` option), but not perfectly. Nevertheless, "
"this is much more acceptable that the initial aliasing that we had!"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:581
msgid "We can now **properly use textures** in our scenes!"
msgstr ""

#: ../../basic-3d-rendering/texturing/sampler.md:583
msgid ""
"We have seen how to **fill-in mip maps**, which can be computed in any "
"way you want. Even though they very often contain averages, **filtering "
"is a complex topic**, and other operations can be used. For mip-mapping "
"depth buffers, one would use a max (and the `compare` option that I did "
"not detail). For normal and roughness data (which we'll discover in the "
"[Lighting and Material](../lighting-and-material/index.md) chapter), "
"other techniques must be found because an average is not physically "
"correct."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:1
msgid "Texture mapping"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:5
#: ../../basic-3d-rendering/texturing/texture-mapping.md:209
msgid ""
"*Resulting code:* [`step065`](https://github.com/eliemichel/LearnWebGPU-"
"Code/tree/step065)"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:9
#: ../../basic-3d-rendering/texturing/texture-mapping.md:213
msgid ""
"*Resulting code:* [`step065-vanilla`](https://github.com/eliemichel"
"/LearnWebGPU-Code/tree/step065-vanilla)"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:12
msgid ""
"In the previous chapter we used the **screen pixel coordinate** "
"(`in.position`) to decide which texel from the image to load."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:14
msgid ""
"If our geometry is no longer a full screen quad, this is **not really "
"what we want**. Let us switch back to a perspective projection, and use "
"the handy `glm::lookAt` function to get an interesting point of view:"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:25
msgid "The texture does not \"follow\" the geometry."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:28
msgid "Texel coordinates"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:31
msgid ""
"How to address this? By computing **texel coordinates** in the vertex "
"shader and letting the rasterizer interpolate it for each fragment."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:55
msgid ""
"It is important that the conversion to integers (`vec2i`) is done in the "
"fragment shader rather than in the vertex shader, because integer vertex "
"output do not get interpolated by the rasterizer."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:59
msgid ""
"Since we increase the size of attributes that transit from the vertex to "
"the fragment shader, we need to **update a device limit**:"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:70
msgid "A much better texture mapping, consistent when the viewpoint changes."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:73
msgid "UV coordinates"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:76
msgid ""
"The texture coordinates are in practice expressed in the range $(0,1)$, "
"so that they **do not depend on the resolution** of the texture, instead "
"of explicitly giving texel indices. We call these normalized coordinates "
"the **UV coordinates**."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:78
msgid ""
"We can make our code independent on the texture size using the "
"`textureDimensions` function:"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:105
msgid ""
"UV coordinates are a very common thing, and **there are UVs in the OBJ "
"file** I have been sharing with you, including this plane. We can add a "
"**new attribute** like we did with normals to provide the UVs from the "
"OBJ file up to the shader:"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:137
msgid ""
"Note that when loading UV coordinates from the file, we need to do **a "
"little conversion** on the V axis."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:166
msgid "And in the shader:"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:193
msgid ""
"For the plane this should not change anything, but if you try with "
"[cube.obj](../../data/cube.obj) for instance it also works nicely!"
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:198
msgid "A textured cube, seen from location $(-2, -3, 2)$."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:204
msgid ""
"We are now able to load textures coordinates to map textures onto 3D "
"meshes, but as you might have noticed, there is **a lot of aliasing** in "
"the way we are getting texel data in the fragment shader."
msgstr ""

#: ../../basic-3d-rendering/texturing/texture-mapping.md:206
msgid "The next chapter hence presents **the proper way of sampling** textures!"
msgstr ""

